Directory Structure:
===================

│   core/
│   ├── config.py
│   ├── prompts.py
│   └── svg_converter.py
│   operators/
│   └── svg_generation.py
│   scenes/
│   ├── cluade.blend
│   ├── gpt.blend
│   ├── scripting.blend
│   └── scripting.blend1
│   tests/
│   ├── complete-svg-test.py
│   ├── debug_svg.py
│   ├── gpt2-test_svg_generation.py
│   ├── gpt_test_svg_generation.py
│   ├── svg-test-origin copy.py
│   └── svg-test-origin.py
BelnderGenAI/
├── LICENSE.md
├── ├── ├── project-readme.md
├── prompts.py
├── requirements.txt
├── ├── ├── utilities copy.py
└── utilities.py


==================================================
File Contents:
==================================================

File: BelnderGenAI/utilities.py
Contents:
import bpy
import anthropic
import re
import os
import sys

# def get_api_key(context, addon_name):
#     preferences = context.preferences
#     addon_prefs = preferences.addons[addon_name].preferences
#     return addon_prefs.api_key

# def init_props():
#     bpy.types.Scene.claude_chat_history = bpy.props.CollectionProperty(type=bpy.types.PropertyGroup)
#     bpy.types.Scene.claude_model = bpy.props.EnumProperty(
#         name="Claude Model",
#         description="Select the Claude model to use",
#         items=[
#             ("claude-3-opus-20240229", "Claude 3 Opus (most capable)", "Use Claude 3 Opus"),
#             ("claude-3-sonnet-20240229", "Claude 3 Sonnet (balanced)", "Use Claude 3 Sonnet"),
#             ("claude-3-haiku-20240307", "Claude 3 Haiku (fastest)", "Use Claude 3 Haiku"),
#         ],
#         default="claude-3-opus-20240229",
#     )
#     bpy.types.Scene.claude_chat_input = bpy.props.StringProperty(
#         name="Message",
#         description="Enter your message",
#         default="",
#     )
#     bpy.types.Scene.claude_button_pressed = bpy.props.BoolProperty(default=False)
#     bpy.types.PropertyGroup.type = bpy.props.StringProperty()
#     bpy.types.PropertyGroup.content = bpy.props.StringProperty()

# /BlenderGPT-main/utilities.py
import bpy
from pathlib import Path


def get_api_key(context, addon_name):
    """Get the API key from the addon preferences."""
    preferences = context.preferences
    addon_prefs = preferences.addons[addon_name].preferences
    return addon_prefs.api_key

def split_area_to_text_editor(context):
    """Split the current area and change one of them to a text editor."""
    area = context.area
    for region in area.regions:
        if region.type == 'WINDOW':
            override = {'area': area, 'region': region}
            bpy.ops.screen.area_split(override, direction='VERTICAL', factor=0.5)
            break

    new_area = context.screen.areas[-1]
    new_area.type = 'TEXT_EDITOR'
    return new_area

def init_props():
    """Initialize the property group for chat messages."""
    bpy.types.PropertyGroup.type = bpy.props.StringProperty()
    bpy.types.PropertyGroup.content = bpy.props.StringProperty()

def clear_props():
    del bpy.types.Scene.claude_chat_history
    del bpy.types.Scene.claude_chat_input
    del bpy.types.Scene.claude_button_pressed

def generate_blender_code(prompt, chat_history, context, system_prompt):
    client = anthropic.Client(api_key=get_api_key(context, "your_addon_name"))
    
    messages = [{"role": "system", "content": system_prompt}]
    for message in chat_history[-10:]:
        if message.type == "assistant":
            messages.append({"role": "assistant", "content": "```\n" + message.content + "\n```"})
        else:
            messages.append({"role": message.type.lower(), "content": message.content})

    # Convert messages to Anthropic's format
    formatted_messages = []
    for msg in messages:
        if msg["role"] == "system":
            formatted_messages.append({"role": "assistant", "content": f"System: {msg['content']}"})
        else:
            formatted_messages.append(msg)

    # Add the current user message
    formatted_messages.append({
        "role": "user", 
        "content": "Can you please write Blender code for me that accomplishes the following task: " + prompt + "? \n. Do not respond with anything that is not Python code. Do not provide explanations"
    })

    try:
        # Create a streaming response
        with client.messages.stream(
            model=context.scene.claude_model,
            max_tokens=1500,
            messages=formatted_messages,
        ) as stream:
            completion_text = ''
            for text in stream.text_stream:
                completion_text += text
                print(completion_text, flush=True, end='\r')

        # Extract code from between triple backticks
        completion_text = re.findall(r'```(.*?)```', completion_text, re.DOTALL)[0]
        completion_text = re.sub(r'^python', '', completion_text, flags=re.MULTILINE)
        
        return completion_text
    except Exception as e:
        print(f"Error generating code: {e}")
        return None

def split_area_to_text_editor(context):
    area = context.area
    for region in area.regions:
        if region.type == 'WINDOW':
            override = {'area': area, 'region': region}
            bpy.ops.screen.area_split(override, direction='VERTICAL', factor=0.5)
            break

    new_area = context.screen.areas[-1]
    new_area.type = 'TEXT_EDITOR'
    return new_area

==================================================

File: BelnderGenAI/prompts.py
Contents:
# /BlenderGPT-main/prompts.py
SYSTEM_PROMPT = """You are an assistant made for the purposes of helping the user with Blender, the 3D software. 
- Respond with your answers in markdown (```). 
- Preferably import entire modules instead of bits. 
- Do not perform destructive operations on the meshes. 
- Do not use cap_ends. Do not do more than what is asked (setting up render settings, adding cameras, etc)
- Do not respond with anything that is not Python code.

Example:

user: create 10 cubes in random locations from -10 to 10
assistant:

==================================================

File: BelnderGenAI/project-readme.md
Contents:
# BlenderClaude-SceneX: AI-Powered Animation Framework

## Overview
BlenderClaude-SceneX is an innovative animation framework that combines the natural language processing capabilities of Anthropic's Claude with the precision and power of Blender's 3D animation system. This integration creates a seamless workflow for generating educational and technical animations directly from natural language descriptions.

## Core Components

### 1. BlenderClaude
The BlenderClaude addon serves as the AI interface layer, providing:
- Direct communication with Claude's API
- Natural language processing of scene descriptions
- SVG generation for precise scene layouts
- Python code generation for Blender automation

### 2. SceneX
SceneX is a Manim-inspired animation framework that provides:
- Precise coordinate system for object placement
- Professional camera control and movement
- Advanced animation sequencing
- Material and lighting management
- Pre-built templates for common scenarios

### 3. Claude Integration
Claude's capabilities are leveraged in several key ways:
- Generation of SVG layouts from natural language descriptions
- Translation of technical concepts into visual components
- Creation of optimized scene structures
- Dynamic animation sequence generation

## Key Innovations

### 1. SVG-Based Scene Generation
- Claude generates SVG layouts that perfectly represent the described scene
- SVGs provide exact positioning and relationships between elements
- Automatic conversion of SVG elements to Blender objects
- Preservation of visual hierarchy and composition

### 2. Coordinate System Integration
- SceneX's precise coordinate system ensures accurate object placement
- SVG coordinates map directly to Blender's 3D space
- Automatic camera framing based on scene composition
- Smart object alignment and distribution

### 3. Animation Pipeline
1. Natural language input → Claude processes description
2. SVG generation with precise layout
3. Conversion to SceneX scene structure
4. Generation of animation sequences
5. Final render with professional quality

## Use Cases

### Technical Documentation
- Cloud architecture diagrams
- Network topology visualization
- System architecture animations
- Data flow demonstrations

### Educational Content
- Mathematical concept visualization
- Physics simulations
- Chemical process animations
- Engineering principles illustration

### Training Materials
- Software workflow demonstrations
- Hardware assembly instructions
- Safety procedure animations
- Process flow visualizations

## Technical Architecture

```mermaid
graph TD
    A[Natural Language Input] --> B[BlenderClaude Addon]
    B --> C[Claude API]
    C --> D[SVG Generation]
    D --> E[SceneX Framework]
    E --> F[Scene Construction]
    E --> G[Animation System]
    F --> H[Blender Renderer]
    G --> H
```

## Key Benefits

### 1. Efficiency
- Rapid scene generation from natural language
- Automated layout and positioning
- Reusable animation templates
- Streamlined workflow

### 2. Precision
- Exact object placement from SVG coordinates
- Professional camera framing
- Consistent visual style
- High-quality output

### 3. Flexibility
- Support for diverse content types
- Customizable templates
- Extensible animation system
- Scalable framework

## Getting Started

### Prerequisites
- Blender 4.2 or higher
- Python 3.10+
- Anthropic API key
- SceneX addon installed

### Installation
1. Install BlenderClaude addon
2. Configure API credentials
3. Import SceneX framework
4. Set up project environment

### Basic Usage
```python
# Example: Creating a cloud architecture animation
scene = TechnicalScene()
scene.process_description("""
Create an AWS architecture with:
- API Gateway frontend
- Lambda function for processing
- S3 bucket for storage
Include arrows showing data flow.
""")
scene.animate()
scene.render()
```

## Contributing
We welcome contributions! Please see our contributing guidelines for details on:
- Code style and standards
- Pull request process
- Testing requirements
- Documentation

## License
This project is licensed under the MIT License. See the LICENSE file for details.

## Acknowledgments
- Anthropic for Claude AI
- Blender Foundation
- Manim Community
- Contributors and testers

For more information and documentation, visit our [project wiki](#).



# ---------------------------------------------------------------


Phase 1: BlenderClaude SVG Enhancement
First, we need to enhance the existing BlenderClaude addon to handle SVG generation from Claude and convert it into scene elements.

Let's start by modifying the Claude_OT_GenerateSVG operator in BlenderClaude:

pythonCopyclass Claude_OT_GenerateSVG(Operator):
    bl_idname = "claude.generate_svg"
    bl_label = "Generate SVG"
    bl_options = {'REGISTER', 'UNDO'}

    # Add scene type selector
    scene_type: EnumProperty(
        name="Scene Type",
        description="Type of scene to generate",
        items=[
            ('AWS', "AWS Architecture", "Create AWS architecture diagrams"),
            ('NETWORK', "Network Topology", "Create network topology diagrams"),
            ('AI', "AI/ML Pipeline", "Create AI/ML workflow diagrams")
        ],
        default='AWS'
    )
Would you like me to provide this first modification to the BlenderClaude addon? We can then test it and move forward with the next steps.
Here's our implementation plan:

Enhance BlenderClaude with SVG capabilities ⬅ We are here
Integrate SceneX coordinate system
Create SVG to Scene converter
Implement animation generators
Add specialized scene templates
Create end-to-end workflow

Let me know if you want to proceed with the first step and I'll provide the detailed code implementation. CopyRetryClaude can make mistakes. Please double-check responses.



# ----------------------------------------------------------------



==================================================

File: BelnderGenAI/utilities copy.py
Contents:
import bpy
import openai
import re
import os
import sys


def get_api_key(context, addon_name):
    preferences = context.preferences
    addon_prefs = preferences.addons[addon_name].preferences
    return addon_prefs.api_key


def init_props():
    bpy.types.Scene.gpt4_chat_history = bpy.props.CollectionProperty(type=bpy.types.PropertyGroup)
    bpy.types.Scene.gpt4_model = bpy.props.EnumProperty(
    name="GPT Model",
    description="Select the GPT model to use",
    items=[
        ("gpt-4", "GPT-4 (powerful, expensive)", "Use GPT-4"),
        ("gpt-3.5-turbo", "GPT-3.5 Turbo (less powerful, cheaper)", "Use GPT-3.5 Turbo"),
    ],
    default="gpt-4",
)
    bpy.types.Scene.gpt4_chat_input = bpy.props.StringProperty(
        name="Message",
        description="Enter your message",
        default="",
    )
    bpy.types.Scene.gpt4_button_pressed = bpy.props.BoolProperty(default=False)
    bpy.types.PropertyGroup.type = bpy.props.StringProperty()
    bpy.types.PropertyGroup.content = bpy.props.StringProperty()

def clear_props():
    del bpy.types.Scene.gpt4_chat_history
    del bpy.types.Scene.gpt4_chat_input
    del bpy.types.Scene.gpt4_button_pressed

def generate_blender_code(prompt, chat_history, context, system_prompt):
    messages = [{"role": "system", "content": system_prompt}]
    for message in chat_history[-10:]:
        if message.type == "assistant":
            messages.append({"role": "assistant", "content": "```\n" + message.content + "\n```"})
        else:
            messages.append({"role": message.type.lower(), "content": message.content})

    # Add the current user message
    messages.append({"role": "user", "content": "Can you please write Blender code for me that accomplishes the following task: " + prompt + "? \n. Do not respond with anything that is not Python code. Do not provide explanations"})


    response = openai.ChatCompletion.create(
        model=context.scene.gpt4_model,
        messages=messages,
        stream=True,
        max_tokens=1500,
    )

    try:
        collected_events = []
        completion_text = ''
        # iterate through the stream of events
        for event in response:
            if 'role' in event['choices'][0]['delta']:
                # skip
                continue
            if len(event['choices'][0]['delta']) == 0:
                # skip
                continue
            collected_events.append(event)  # save the event response
            event_text = event['choices'][0]['delta']['content']
            completion_text += event_text  # append the text
            print(completion_text, flush=True, end='\r')
        completion_text = re.findall(r'```(.*?)```', completion_text, re.DOTALL)[0]
        completion_text = re.sub(r'^python', '', completion_text, flags=re.MULTILINE)
        
        return completion_text
    except IndexError:
        return None

def split_area_to_text_editor(context):
    area = context.area
    for region in area.regions:
        if region.type == 'WINDOW':
            override = {'area': area, 'region': region}
            bpy.ops.screen.area_split(override, direction='VERTICAL', factor=0.5)
            break

    new_area = context.screen.areas[-1]
    new_area.type = 'TEXT_EDITOR'
    return new_area

==================================================

File: BelnderGenAI/requirements.txt
Contents:
openai==0.27.2

==================================================

File: BelnderGenAI/LICENSE.md
Contents:
MIT License

Copyright (c) 2023 Aarya Gadekar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


==================================================

File: BelnderGenAI/scenes/gpt.blend
Contents:
[Binary File Content - gpt.blend]


==================================================

File: BelnderGenAI/scenes/scripting.blend1
Contents:
[Binary File Content - scripting.blend1]


==================================================

File: BelnderGenAI/scenes/scripting.blend
Contents:
[Binary File Content - scripting.blend]


==================================================

File: BelnderGenAI/scenes/cluade.blend
Contents:
[Binary File Content - cluade.blend]


==================================================

File: BelnderGenAI/operators/svg_generation.py
Contents:
# File: BlenderClaude/operators/svg_generation.py

"""SVG generation operators for BlenderClaude addon.

This module handles the generation of SVG content using Claude's AI capabilities
and converts them into Blender scenes using SceneX framework.
"""

import bpy
import os
import re
from bpy.types import Operator
from bpy.props import StringProperty, EnumProperty
import anthropic
from ..utilities import get_api_key
from ..core.XV1_svg_converter import SVGToSceneConverter
from ..core.prompts import SVG_SYSTEM_PROMPTS

class CLAUDE_OT_GenerateSVG(Operator):
    """Generate SVG content from natural language description using Claude."""
    
    bl_idname = "claude.generate_svg"
    bl_label = "Generate SVG"
    bl_options = {'REGISTER', 'UNDO'}

    # Scene type selection
    scene_type: EnumProperty(
        name="Scene Type",
        description="Type of scene to generate",
        items=[
            ('AWS', "AWS Architecture", "Create AWS architecture diagrams"),
            ('NETWORK', "Network Topology", "Create network topology diagrams"),
            ('AI', "AI/ML Pipeline", "Create AI/ML workflow diagrams"),
            ('CUSTOM', "Custom", "Create custom technical diagrams")
        ],
        default='AWS'
    )

    # Description input
    description: StringProperty(
        name="Description",
        description="Describe the scene you want to create",
        default="",
    )

    def invoke(self, context, event):
        """Show the scene generation dialog."""
        return context.window_manager.invoke_props_dialog(self, width=400)

    def draw(self, context):
        """Draw the operator's UI."""
        layout = self.layout
        layout.prop(self, "scene_type")
        layout.prop(self, "description", text="")
        layout.label(text="Example: Create a serverless API with Lambda and API Gateway")

    def execute(self, context):
        """Execute the SVG generation operation."""
        try:
            # Get API key
            api_key = get_api_key(context, __name__)
            if not api_key:
                api_key = os.getenv("ANTHROPIC_API_KEY")

            if not api_key:
                self.report({'ERROR'}, "No API key found. Please set in preferences.")
                return {'CANCELLED'}

            # Initialize Claude client
            client = anthropic.Client(api_key=api_key)

            # Get appropriate system prompt based on scene type
            system_prompt = SVG_SYSTEM_PROMPTS.get(
                self.scene_type,
                SVG_SYSTEM_PROMPTS['CUSTOM']
            )

            # Generate SVG using Claude
            response = client.messages.create(
                model=context.scene.claude_model,
                max_tokens=4000,
                messages=[{
                    "role": "user",
                    "content": (
                        f"{system_prompt}\n\n"
                        f"Create an SVG diagram for: {self.description}"
                    )
                }]
            )

            # Extract SVG code
            svg_code = response.content[0].text
            svg_match = re.findall(r'<svg.*?</svg>', svg_code, re.DOTALL)
            
            if not svg_match:
                self.report({'ERROR'}, "No SVG found in response")
                return {'CANCELLED'}

            svg_code = svg_match[0]

            # Convert SVG to scene
            converter = SVGToSceneConverter()
            scene_data = converter.convert(svg_code)

            # Create scene elements
            self._create_scene_elements(context, scene_data)

            # Store in text editor for reference
            self._store_svg_code(context, svg_code)

            # Update UI
            self._update_ui(context, svg_code)

            self.report({'INFO'}, "Scene generated successfully!")
            return {'FINISHED'}

        except Exception as e:
            self.report({'ERROR'}, f"Error generating scene: {str(e)}")
            return {'CANCELLED'}

    def _create_scene_elements(self, context, scene_data):
        """Create Blender objects from scene data."""
        # Create empty parent for scene
        bpy.ops.object.empty_add(type='PLAIN_AXES')
        parent = context.active_object
        parent.name = "Generated_Scene"

        # Create objects based on scene data
        for element in scene_data['elements']:
            if element['type'] == 'component':
                self._create_component(element, parent)
            elif element['type'] == 'connection':
                self._create_connection(element, parent)

    def _create_component(self, element_data, parent):
        """Create a scene component."""
        # Component creation logic here
        pass

    def _create_connection(self, element_data, parent):
        """Create a connection between components."""
        # Connection creation logic here
        pass

    def _store_svg_code(self, context, svg_code):
        """Store SVG code in text editor."""
        text_name = "Generated_SVG.svg"
        text = bpy.data.texts.get(text_name)
        if text is None:
            text = bpy.data.texts.new(text_name)
        text.clear()
        text.write(svg_code)

    def _update_ui(self, context, svg_code):
        """Update UI with generated content."""
        # Add to chat history
        message = context.scene.claude_chat_history.add()
        message.type = 'user'
        message.content = self.description

        message = context.scene.claude_chat_history.add()
        message.type = 'assistant'
        message.content = svg_code

        # Clear input field
        context.scene.claude_chat_input = ""

==================================================

File: BelnderGenAI/core/config.py
Contents:
# File: BlenderClaude/core/config.py

"""Configuration management for BlenderClaude addon.

Handles loading of environment variables and addon configuration.
"""

import os
from pathlib import Path
from dotenv import load_dotenv

class Config:
    """Configuration manager for BlenderClaude."""
    
    def __init__(self):
        self._load_env()
        
    def _load_env(self):
        """Load environment variables from .env file."""
        # Get addon directory
        addon_dir = Path(__file__).parent.parent
        env_path = addon_dir / '.env'
        
        # Create .env if it doesn't exist
        if not env_path.exists():
            self._create_default_env(env_path)
        
        # Load environment variables
        load_dotenv(env_path)
    
    def _create_default_env(self, env_path):
        """Create default .env file."""
        default_env = """# BlenderClaude Environment Configuration
CLAUDE_API_KEY=your_api_key_here
SCENEX_PATH=/path/to/scenex

# Scene Generation Settings
DEFAULT_SCENE_CONFIG={"grid_size": 10, "spacing": 2.0}
"""
        with open(env_path, 'w') as f:
            f.write(default_env)
    
    @property
    def api_key(self) -> str:
        """Get Claude API key."""
        return os.getenv('CLAUDE_API_KEY', '')
    
    @property
    def scenex_path(self) -> str:
        """Get SceneX installation path."""
        return os.getenv('SCENEX_PATH', '')
    
    @property
    def scene_config(self) -> dict:
        """Get default scene configuration."""
        import json
        config_str = os.getenv('DEFAULT_SCENE_CONFIG', '{}')
        return json.loads(config_str)

# Global configuration instance
config = Config()

==================================================

File: BelnderGenAI/core/prompts.py
Contents:
# File: BlenderClaude/core/prompts.py

"""System prompts for SVG generation using Claude.

Contains specialized prompts for different types of technical diagrams.
"""

SVG_SYSTEM_PROMPTS = {
    'AWS': """You are an expert at creating AWS architecture diagrams.
Create a precise SVG diagram following these guidelines:
- Use standard AWS architecture symbols
- Maintain consistent sizing (64x64 for service icons)
- Create logical data flow connections
- Include clear service labels
- Use AWS color scheme
- Organize in logical tiers (frontend, backend, storage)
- Include arrows showing data flow direction
""",

    'NETWORK': """You are an expert at creating network topology diagrams.
Create a precise SVG diagram following these guidelines:
- Use standard network symbols (routers, switches, firewalls)
- Show network segmentation
- Include proper IP addressing zones
- Show security boundaries
- Use consistent connection types
- Label network segments
- Include protocol indicators where relevant
""",

    'AI': """You are an expert at creating AI/ML pipeline diagrams.
Create a precise SVG diagram following these guidelines:
- Show data flow through ML pipeline
- Include data preprocessing steps
- Show model training components
- Include evaluation metrics
- Show deployment pipeline
- Use consistent ML symbols
- Label key components and transformations
""",

    'CUSTOM': """You are an expert at creating technical diagrams.
Create a precise SVG diagram following these guidelines:
- Use clear, consistent symbols
- Show logical flow and relationships
- Include appropriate labels
- Maintain proper spacing
- Use a clear visual hierarchy
- Include directional indicators where needed
"""
}

# Common SVG styling to be applied to all diagrams
SVG_STYLE_TEMPLATE = """
<defs>
    <style type="text/css">
        .component { fill: #f8f9fa; stroke: #495057; stroke-width: 2; }
        .label { font-family: Arial; font-size: 12px; fill: #212529; }
        .connection { stroke: #adb5bd; stroke-width: 2; fill: none; }
        .arrow { fill: #adb5bd; }
    </style>
</defs>
"""

# Example snippets for common components
SVG_COMPONENT_TEMPLATES = {
    'service': '''
    <g class="service-component">
        <rect x="0" y="0" width="64" height="64" class="component"/>
        <text x="32" y="80" class="label" text-anchor="middle">{label}</text>
    </g>
    ''',
    
    'connection': '''
    <g class="connection">
        <path d="M {start_x},{start_y} {end_x},{end_y}" class="connection"/>
        <polygon points="{arrow_points}" class="arrow"/>
    </g>
    '''
}

==================================================

File: BelnderGenAI/core/svg_converter.py
Contents:
# File: /home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI/core/svg_converter.py

import bpy
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Tuple
import re

class SVGToSceneConverter:
    SCALE_FACTOR = 0.02  # Reduced scale
    COMPONENT_DEPTH = 0.2
    CONNECTION_THICKNESS = 0.02
    COMPONENT_SIZE = 1.0  # Fixed component size
    
    def __init__(self):
        self.components = []
        self.connections = []
        self.ns = {'svg': 'http://www.w3.org/2000/svg'}

    def create_component(self, element: ET.Element) -> Optional[bpy.types.Object]:
        try:
            rect = element.find('svg:rect', self.ns)
            if not rect:
                return None

            service_type = element.get('data-service', 'unknown')
            component_id = element.get('id', 'unknown')
            
            # Keep same size but adjust position
            x = float(rect.get('x', 0)) * self.SCALE_FACTOR
            y = -float(rect.get('y', 0)) * self.SCALE_FACTOR - 2  # Offset Y downward
            
            bpy.ops.mesh.primitive_cube_add(location=(x, y, 0))
            obj = bpy.context.active_object
            obj.name = f"{service_type}_{component_id}"
            
            # Fixed size components
            obj.scale = (self.COMPONENT_SIZE, self.COMPONENT_SIZE, self.COMPONENT_DEPTH)
            
            mat = bpy.data.materials.new(name=f"{obj.name}_material")
            mat.use_nodes = True
            nodes = mat.node_tree.nodes
            principled = nodes["Principled BSDF"]
            
            if service_type == "lambda":
                color = (0.95, 0.45, 0.1, 1.0)
            else:
                color = (0.45, 0.2, 0.95, 1.0)
                
            principled.inputs["Base Color"].default_value = color
            principled.inputs["Metallic"].default_value = 0.3
            principled.inputs["Roughness"].default_value = 0.3
            obj.data.materials.append(mat)
            
            self.components.append(obj)
            return obj
            
        except Exception as e:
            print(f"Component creation error: {str(e)}")
            return None

    def create_connection(self, element: ET.Element) -> Optional[bpy.types.Object]:
        try:
            path_data = element.get('d', '')
            if not path_data:
                return None
                
            points = []
            for cmd_match in re.finditer(r'([ML])\s*([\d.-]+)\s*([\d.-]+)', path_data):
                cmd, x, y = cmd_match.groups()
                points.append((
                    float(x) * self.SCALE_FACTOR,
                    (-float(y) * self.SCALE_FACTOR) - 2,  # Offset Y to match components
                    0
                ))
                
            if len(points) < 2:
                return None
                
            curve_data = bpy.data.curves.new('connection', 'CURVE')
            curve_data.dimensions = '3D'
            
            spline = curve_data.splines.new('POLY')
            spline.points.add(len(points) - 1)
            
            for i, point in enumerate(points):
                spline.points[i].co = (*point, 1)
                
            curve_obj = bpy.data.objects.new('connection', curve_data)
            curve_obj.data.bevel_depth = self.CONNECTION_THICKNESS
            
            mat = bpy.data.materials.new(name="connection_material")
            mat.use_nodes = True
            nodes = mat.node_tree.nodes
            principled = nodes["Principled BSDF"]
            principled.inputs["Base Color"].default_value = (0.1, 0.1, 0.1, 1.0)
            principled.inputs["Metallic"].default_value = 0.8
            principled.inputs["Roughness"].default_value = 0.2
            curve_obj.data.materials.append(mat)
            
            bpy.context.scene.collection.objects.link(curve_obj)
            self.connections.append(curve_obj)
            return curve_obj
            
        except Exception as e:
            print(f"Connection creation error: {str(e)}")
            return None

    def convert(self, svg_content: str) -> Dict[str, List[bpy.types.Object]]:
        try:
            self.components = []
            self.connections = []
            
            root = ET.fromstring(svg_content)
            
            components = root.findall(".//svg:g[@class='component aws-component']", self.ns)
            paths = root.findall(".//svg:path[@class='connection']", self.ns)
            
            for comp in components:
                self.create_component(comp)
                
            for path in paths:
                self.create_connection(path)
                
            return {
                'components': self.components,
                'connections': self.connections
            }
            
        except Exception as e:
            print(f"Conversion error: {str(e)}")
            return {
                'components': [],
                'connections': []
            }

==================================================

File: BelnderGenAI/tests/svg-test-origin.py
Contents:
# File: /home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI/tests/test_svg_generation.py

import bpy
import sys
import os
import math
from pathlib import Path

def print_separator(title: str = ""):
    print("\n" + "=" * 50)
    if title:
        print(title)
        print("=" * 50)

def setup_addon_path():
    addon_dir = Path("/home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI").resolve()
    if str(addon_dir) not in sys.path:
        sys.path.append(str(addon_dir))
        print(f"Added to Python path: {addon_dir}")

def debug_svg_input(svg_content: str, source: str = "test"):
    print_separator("Original SVG Input")
    print(f"SVG Source: {source}")
    print("\nSVG Content:")
    print(svg_content)

def test_basic_svg():
    # Test SVG content - important to track if this gets modified
    test_svg = '''<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
    <g class="component aws-component" data-service="lambda" id="lambda1">
        <rect x="100" y="100" width="64" height="64" class="component"/>
        <text x="132" y="180">Lambda Function</text>
    </g>
    <g class="component aws-component" data-service="s3" id="s3bucket">
        <rect x="300" y="100" width="64" height="64" class="component"/>
        <text x="332" y="180">S3 Bucket</text>
    </g>
    <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
</svg>'''

    print_separator("Test Configuration")
    print("Running SVG generation test...")
    debug_svg_input(test_svg, "test_case")

    try:
        from core.XV1_svg_converter import SVGToSceneConverter
        print("\nSuccessfully imported SVGToSceneConverter")
        
        # Clear scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        print("\nCleared scene")

        # Test conversion
        print("\nStarting conversion...")
        converter = SVGToSceneConverter()
        result = converter.convert(test_svg)

        print_separator("Results")
        print(f"Components created: {len(result['components'])}")
        for comp in result['components']:
            print(f"- {comp.name} at {comp.location}")

        print(f"\nConnections created: {len(result['connections'])}")
        for conn in result['connections']:
            print(f"- {conn.name}")

        if not result['components'] and not result['connections']:
            print("\nERROR: No objects created")
            print("Please check:")
            print("1. SVG content is valid")
            print("2. XML namespace handling")
            print("3. Path parsing for connections")

    except Exception as e:
        print_separator("ERROR")
        print(f"Test failed: {str(e)}")
        raise

if __name__ == "__main__":
    setup_addon_path()
    test_basic_svg()


==================================================

File: BelnderGenAI/tests/svg-test-origin copy.py
Contents:
# File: /home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI/tests/test_svg_generation.py

import bpy
import sys
import os
import math
from pathlib import Path

def print_separator(title: str = ""):
    print("\n" + "=" * 50)
    if title:
        print(title)
        print("=" * 50)

def setup_addon_path():
    addon_dir = Path("/home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI").resolve()
    if str(addon_dir) not in sys.path:
        sys.path.append(str(addon_dir))
        print(f"Added to Python path: {addon_dir}")

def debug_svg_input(svg_content: str, source: str = "test"):
    print_separator("Original SVG Input")
    print(f"SVG Source: {source}")
    print("\nSVG Content:")
    print(svg_content)

def test_basic_svg():
    # Test SVG content - important to track if this gets modified
    test_svg = '''<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
    <g class="component aws-component" data-service="lambda" id="lambda1">
        <rect x="100" y="100" width="64" height="64" class="component"/>
        <text x="132" y="180">Lambda Function</text>
    </g>
    <g class="component aws-component" data-service="s3" id="s3bucket">
        <rect x="300" y="100" width="64" height="64" class="component"/>
        <text x="332" y="180">S3 Bucket</text>
    </g>
    <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
</svg>'''

    print_separator("Test Configuration")
    print("Running SVG generation test...")
    debug_svg_input(test_svg, "test_case")

    try:
        from core.XV1_svg_converter import SVGToSceneConverter
        print("\nSuccessfully imported SVGToSceneConverter")
        
        # Clear scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        print("\nCleared scene")

        # Test conversion
        print("\nStarting conversion...")
        converter = SVGToSceneConverter()
        result = converter.convert(test_svg)

        print_separator("Results")
        print(f"Components created: {len(result['components'])}")
        for comp in result['components']:
            print(f"- {comp.name} at {comp.location}")

        print(f"\nConnections created: {len(result['connections'])}")
        for conn in result['connections']:
            print(f"- {conn.name}")

        if not result['components'] and not result['connections']:
            print("\nERROR: No objects created")
            print("Please check:")
            print("1. SVG content is valid")
            print("2. XML namespace handling")
            print("3. Path parsing for connections")

    except Exception as e:
        print_separator("ERROR")
        print(f"Test failed: {str(e)}")
        raise

if __name__ == "__main__":
    setup_addon_path()
    test_basic_svg()


==================================================

File: BelnderGenAI/tests/gpt_test_svg_generation.py
Contents:
import bpy
import sys
import os
import math  # Ensure math is imported
from pathlib import Path

# Set the addon directory path
addon_dir = Path("/home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI").resolve()

# Add addon_dir to sys.path if not already added
if str(addon_dir) not in sys.path:
    sys.path.append(str(addon_dir))
    print(f"Added to Python path: {addon_dir}")

# Debugging paths
print(f"Addon directory: {addon_dir}")
print(f"Current Python path: {sys.path}")

# Import module from core
try:
    from core.XV1_svg_converter import SVGToSceneConverter
    print("Successfully imported SVGToSceneConverter")
except ImportError as e:
    print(f"Error importing SVGToSceneConverter: {e}")
    print(f"Current directory: {addon_dir}")
    print(f"Python path: {sys.path}")
    raise

def setup_test_scene():
    """Setup a clean test scene."""
    print("Setting up test scene...")
    
    # Clear existing scene
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

    # Set render engine
    bpy.context.scene.render.engine = 'CYCLES'  # Use Cycles for Blender 4.3
    
    # Set up camera
    bpy.ops.object.camera_add(location=(0, -10, 5))
    camera = bpy.context.active_object
    camera.rotation_euler = (math.radians(30), 0, 0)  # Use math.radians correctly
    
    print("Test scene setup complete")

def test_basic_svg():
    """Test basic SVG generation and conversion."""
    print("Starting SVG test...")
    setup_test_scene()

    # Test SVG content
    test_svg = '''<?xml version="1.0" encoding="UTF-8"?>
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
        <g class="component aws-component" data-service="lambda" id="lambda1">
            <rect x="100" y="100" width="64" height="64" class="component"/>
            <text x="132" y="180">Lambda Function</text>
        </g>
        <g class="component aws-component" data-service="s3" id="s3bucket">
            <rect x="300" y="100" width="64" height="64" class="component"/>
            <text x="332" y="180">S3 Bucket</text>
        </g>
        <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
    </svg>'''

    try:
        # Create converter instance
        print("Creating SVG converter...")
        converter = SVGToSceneConverter()

        # Convert SVG to scene data
        print("Converting SVG to scene data...")
        scene_data = converter.convert(test_svg)

        # Print conversion results
        print("\nScene Data:")
        print("-----------")
        for key, value in scene_data.items():
            print(f"{key}: {value}")

        # Verify objects were created
        print("\nVerifying created objects:")
        component_count = len([obj for obj in bpy.data.objects if 'component' in obj.name])
        connection_count = len([obj for obj in bpy.data.objects if 'connection' in obj.name])

        print(f"Components created: {component_count}")
        print(f"Connections created: {connection_count}")

        if component_count == 2 and connection_count == 1:
            print("\nTest completed successfully!")
        else:
            print("\nTest completed with unexpected object counts")
            
    except Exception as e:
        print(f"\nError during test: {str(e)}")
        raise

if __name__ == "__main__":
    test_basic_svg()


==================================================

File: BelnderGenAI/tests/debug_svg.py
Contents:
# File: /home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI/tests/debug_svg.py

import xml.etree.ElementTree as ET

def debug_svg_parsing(svg_content: str):
    """Debug SVG parsing issues."""
    print("\nDEBUG SVG PARSING")
    print("=" * 50)
    
    try:
        # Parse SVG
        root = ET.fromstring(svg_content)
        print("\n1. Basic SVG Info:")
        print(f"Root tag: {root.tag}")
        print(f"Root attributes: {root.attrib}")
        
        # Debug namespace
        ns = {'svg': 'http://www.w3.org/2000/svg'}
        print("\n2. Checking for components with namespace:")
        components = root.findall(".//svg:g[@class='component aws-component']", ns)
        print(f"Found {len(components)} components with namespace")
        
        print("\n3. Checking for components without namespace:")
        components = root.findall(".//g[@class='component aws-component']")
        print(f"Found {len(components)} components without namespace")
        
        # Print all groups
        print("\n4. All group elements found:")
        all_groups = root.findall(".//g")
        for i, group in enumerate(all_groups):
            print(f"\nGroup {i + 1}:")
            print(f"  Class: {group.get('class')}")
            print(f"  ID: {group.get('id')}")
            print(f"  Children: {[child.tag for child in group]}")
            
        # Print all path elements
        print("\n5. All path elements:")
        paths = root.findall(".//path")
        for i, path in enumerate(paths):
            print(f"\nPath {i + 1}:")
            print(f"  Class: {path.get('class')}")
            print(f"  ID: {path.get('id')}")
            print(f"  Data: {path.get('d')}")
            
    except Exception as e:
        print(f"\nError during debug: {str(e)}")

# Test SVG content
test_svg = '''<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
    <g class="component aws-component" data-service="lambda" id="lambda1">
        <rect x="100" y="100" width="64" height="64" class="component"/>
        <text x="132" y="180">Lambda Function</text>
    </g>
    <g class="component aws-component" data-service="s3" id="s3bucket">
        <rect x="300" y="100" width="64" height="64" class="component"/>
        <text x="332" y="180">S3 Bucket</text>
    </g>
    <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
</svg>'''

if __name__ == "__main__":
    debug_svg_parsing(test_svg)


==================================================

File: BelnderGenAI/tests/gpt2-test_svg_generation.py
Contents:
import bpy
import sys
import math
from pathlib import Path

addon_dir = Path("/home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI").resolve()

if str(addon_dir) not in sys.path:
    sys.path.append(str(addon_dir))
    print(f"Added to Python path: {addon_dir}")

try:
    from core.XV1_svg_converter import SVGToSceneConverter
    print("Successfully imported SVGToSceneConverter")
except ImportError as e:
    print(f"Error importing SVGToSceneConverter: {e}")
    raise

def clear_scene():
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

def setup_scene():
    clear_scene()
    bpy.ops.object.camera_add(location=(10, -10, 10))
    camera = bpy.context.active_object
    camera.rotation_euler = (math.radians(45), 0, math.radians(45))
    bpy.context.scene.camera = camera
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    light = bpy.context.active_object
    light.data.energy = 5.0

def test_basic_svg():
    setup_scene()
    test_svg = '''<?xml version="1.0"?>
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
        <g class="component aws-component" data-service="lambda" id="lambda1">
            <rect x="100" y="100" width="64" height="64"/>
            <text x="132" y="180">Lambda Function</text>
        </g>
        <g class="component aws-component" data-service="s3" id="s3bucket">
            <rect x="300" y="100" width="64" height="64"/>
            <text x="332" y="180">S3 Bucket</text>
        </g>
        <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
    </svg>'''
    converter = SVGToSceneConverter()
    scene_data = converter.convert(test_svg)
    print("Scene Data:", scene_data)
    components = [obj for obj in bpy.data.objects if 'component' in obj.name]
    connections = [obj for obj in bpy.data.objects if 'connection' in obj.name]
    print(f"Components created ({len(components)}): {components}")
    print(f"Connections created ({len(connections)}): {connections}")

if __name__ == "__main__":
    test_basic_svg()


==================================================

File: BelnderGenAI/tests/complete-svg-test.py
Contents:
# File: /home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI/tests/test_svg_generation.py

import bpy
import sys
import os
import math
from pathlib import Path

# Set the addon directory path
addon_dir = Path("/home/ernestc/.config/blender/4.3/scripts/addons/BelnderGenAI").resolve()

# Add addon_dir to sys.path if not already added
if str(addon_dir) not in sys.path:
    sys.path.append(str(addon_dir))
    print(f"Added to Python path: {addon_dir}")

# Debugging paths
print(f"Addon directory: {addon_dir}")
print(f"Current Python path: {sys.path}")

# Import our converter
try:
    from core.XV1_svg_converter import SVGToSceneConverter
    print("Successfully imported SVGToSceneConverter")
except ImportError as e:
    print(f"Error importing SVGToSceneConverter: {e}")
    print(f"Current directory: {os.getcwd()}")
    raise

def clear_scene():
    """Clear all objects from the scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
def setup_viewport():
    """Configure viewport for better visualization."""
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    space.shading.type = 'MATERIAL'
                    space.shading.use_scene_lights = True
                    # Set a nice default view
                    space.region_3d.view_perspective = 'PERSP'
                    space.region_3d.view_distance = 15

def setup_scene():
    """Setup test scene with camera and light."""
    print("Setting up test scene...")
    
    # Clear scene
    clear_scene()
    
    # Set up camera
    bpy.ops.object.camera_add(location=(10, -10, 10))
    camera = bpy.context.active_object
    camera.rotation_euler = (math.radians(45), 0, math.radians(45))
    bpy.context.scene.camera = camera  # Set as active camera
    
    # Set up light
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    light = bpy.context.active_object
    light.data.energy = 5.0
    
    # Configure viewport
    setup_viewport()
    
    print("Test scene setup complete")

def test_basic_svg():
    """Test SVG to scene conversion."""
    print("\nStarting SVG conversion test...")
    
    # Setup clean scene
    setup_scene()
    
    # Test SVG
    test_svg = '''<?xml version="1.0" encoding="UTF-8"?>
    <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
        <g class="component aws-component" data-service="lambda" id="lambda1">
            <rect x="100" y="100" width="64" height="64" class="component"/>
            <text x="132" y="180">Lambda Function</text>
        </g>
        <g class="component aws-component" data-service="s3" id="s3bucket">
            <rect x="300" y="100" width="64" height="64" class="component"/>
            <text x="332" y="180">S3 Bucket</text>
        </g>
        <path class="connection" id="lambda_to_s3" d="M 164 132 L 300 132"/>
    </svg>'''

    try:
        # Create converter
        print("\nCreating SVG converter...")
        converter = SVGToSceneConverter()

        # Convert SVG
        print("Converting SVG to scene data...")
        scene_data = converter.convert(test_svg)

        # Print conversion results
        print("\nScene Data:")
        print("-----------")
        for key, value in scene_data.items():
            print(f"{key}: {value}")

        # Verify objects
        print("\nVerifying created objects:")
        components = [obj for obj in bpy.data.objects if 'component' in obj.name]
        connections = [obj for obj in bpy.data.objects if 'connection' in obj.name]
        
        print(f"Components created ({len(components)}):")
        for comp in components:
            print(f"- {comp.name} at location {comp.location}")
            
        print(f"\nConnections created ({len(connections)}):")
        for conn in connections:
            print(f"- {conn.name}")

        # Switch to camera view for better visualization
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'

        if len(components) == 2 and len(connections) == 1:
            print("\nTest completed successfully!")
            return True
        else:
            print("\nTest completed with unexpected object counts")
            return False
            
    except Exception as e:
        print(f"\nError during test: {str(e)}")
        raise

if __name__ == "__main__":
    test_basic_svg()


==================================================

