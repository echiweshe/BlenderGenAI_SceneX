Directory Structure:
===================

│   LaTex/
│   └── LaTeX _test_file.tex
│   │   examples/
│   │   ├── educational.md
│   │   ├── mathematical.md
│   │   └── technical.md
│   │   reference/
│   │   ├── animations.md
│   │   ├── camera.md
│   │   ├── geometry.md
│   │   └── scene.md
│       tutorials/
│       ├── animations.md
│       ├── basic_scene.md
│       ├── camera.md
│       └── shapes.md
│   docs/
│   ├── contributing.md
│   ├── │   ├── quickstart.md
│   ├── │   └── │   │   animation/
│   │   ├── base.py
│   │   ├── commonly_used_animations.py
│   │   ├── material_animations.py
│   │   ├── rate_functions.py
│   │   ├── sequence.py
│   │   ├── transform.py
│   │   └── transform_between.py
│   │   aws/
│   │   camera/
│   │   ├── camera copy.py
│   │   ├── camera.py
│   │   └── movements.py
│   │   core/
│   │   ├── config.py
│   │   ├── coordinate_system.py
│   │   ├── mobject.py
│   │   └── scene.py
│   │   geometry/
│   │   ├── alignment.py
│   │   ├── base.py
│   │   ├── complex_shapes.py
│   │   ├── shapes.py
│   │   ├── snapping.py
│   │   └── svg_handler.py
│   │   graphics/
│   │       metal_hdr_photos/
│   │       └── metal_background_197638.jpg
│   │   hdr/
│   │   └── │   │   logs/
│   │   materials/
│   │   ├── material copy.py
│   │   └── material.py
│   │   physics/
│   │   scene/
│   │   ├── grid.py
│   │   ├── groups.py
│   │   └── layout.py
│   │   svg/
│   │   ├── SceneX_logo.svg
│   │   ├── svg.py
│   │   └── svg_handler.py
│   │   templates/
│   │   ├── educational.py
│   │   ├── mathematical.py
│   │   ├── physics.py
│   │   └── technical.py
│   │   text/
│   │   ├── text_support copy 2.py
│   │   ├── text_support copy.py
│   │   ├── text_support.py
│   │   └── text_support_gpt_working 3.py
│       utils/
│       └── logger.py
│   src/
│   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   ├── │   └── │       scenes/
│   templates/
│   └── │   │   example_scenes/
│   │   ├── 10_alignment_test.py
│   │   ├── 11_animation_sequence_test.py
│   │   ├── 12_rate_functions_test.py
│   │   ├── 13_groups_test.py
│   │   ├── 14_grid_test.py
│   │   ├── 15_layout_test.py
│   │   ├── 16_camera_movement_test.py
│   │   ├── 17_template_tests.py
│   │   ├── 18_Other_physics_simulations_to_be_done.txt
│   │   ├── 18_physics_test.py
│   │   ├── 19_transform_and_snap_test.py
│   │   ├── 1_basic_scene_1_placing_mobjects__test.py
│   │   ├── 1_basic_scene_2_add_coordinate_system_test.py
│   │   ├── 1_basic_scene_3_add_camera_test.py
│   │   ├── 1_basic_scene_4_camera_animation_test.py
│   │   ├── 20_material_animations_test.py
│   │   ├── 21_integration_test.py
│   │   ├── 21_scenex_ai_setup_1test.py
│   │   ├── 22_test_integration.py
│   │   ├── 23-blender-compatible-test.py
│   │   ├── 2_animation_test_scene_1_test.py
│   │   ├── 2_animation_test_scene_2_fade_standalone_test.py
│   │   ├── 2_animation_test_scene_3_fade_integrated_test.py
│   │   ├── 2_animation_test_scene_4_commonly_used_animations_test copy.py
│   │   ├── 2_animation_test_scene_4_commonly_used_animations_test.py
│   │   ├── 3_animation_showcase_test_1_FlashAround_test.py
│   │   ├── 3_animation_showcase_test_2_FlashAround_test.py.py
│   │   ├── 4_geometry_test.py
│   │   ├── 5_geometry_complex_shapes_test.py
│   │   ├── 6_material-test-fixed-animation.py
│   │   ├── 6_materials_gpt_1_test.py
│   │   ├── 6_materials_gpt_2_test.py
│   │   ├── 6_materials_test copy.py
│   │   ├── 6_materials_test.py
│   │   ├── 7_text_latex_test.py
│   │   ├── 8_latex-1-test copy.py
│   │   ├── 8_latex-1-test-gpt-working-2.py
│   │   ├── 8_latex-1-test.py
│   │   ├── 8_latex-2-test copy.py
│   │   ├── 8_latex-2-test.py
│   │   └── 9_svg_test.py
│   tests/
│   ├── │   ├── test_camera.py
│   ├── test_coordinate_system.py
│   └── test_mobject.py
    ui/
    ├── ai_panel.py
    ├── handlers.py
    ├── operators.py
    ├── panels.py
    ├── presets.py
    └── properties.py
SceneX/
├── LaTeX _test_file.aux
├── LaTeX _test_file.pdf
├── ├── ├── merge-plan.md
├── scenex-integration-plan.md
├── scenex-v1-og-project-brief.md
├── scenex-v2-project-brief.md
├── ├── ├── └── 

==================================================
File Contents:
==================================================

File: SceneX/scenex-v2-project-brief.md
Contents:
# SceneX Documentation

## Overview
SceneX is a Blender animation framework inspired by Manim, designed for creating educational and technical animations. It provides high-level abstractions for geometry, animations, and scene composition.

## Quick Start

```python
from src.core.scene import Scene
from src.geometry.shapes import Circle, Square
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig
from mathutils import Vector

class MyFirstScene(Scene):
    def construct(self):
        # Create shapes
        circle = Circle(radius=0.5).create()
        square = Square(size=1.0).create()

        # Position objects
        self.coordinate_system.place_object(circle, Vector((-1, 0, 0)))
        self.coordinate_system.place_object(square, Vector((1, 0, 0)))

        # Animate
        config = AnimationConfig(duration=30)
        self.play(FadeInFrom(circle, Vector((0, -1, 0)), config=config))

# Run the scene
scene = MyFirstScene()
scene.construct()
```

## Core Components

### 1. Geometry System
- Basic Shapes: Circle, Square, Rectangle, Line
- Complex Shapes: Arrow, Arc, Star
- Text and LaTeX Support
- SVG Import

Example:
```python
# Creating shapes
circle = Circle(radius=0.5, color=(1, 0, 0, 1)).create()
arrow = Arrow(start=(-1, 0, 0), end=(1, 0, 0)).create()

# Text creation
text = Text("Hello World", size=1.0).create()
```

### 2. Animation System
- Basic Animations: FadeIn, FadeOut, Rotate
- Transform Animations
- Animation Sequences and Groups
- Custom Rate Functions

Example:
```python
# Single animation
self.play(FadeInFrom(circle, Vector((0, -1, 0)), config))

# Animation sequence
sequence = AnimationSequence(
    FadeInFrom(circle, Vector((0, -1, 0)), config),
    Rotate(circle, config)
)
self.play(sequence)
```

### 3. Scene Composition
- Object Groups
- Layout Management
- Camera Control
- Grid System

Example:
```python
# Create and manage groups
group = Group("shapes").add(circle, square)
layout = Layout()
layout.arrange(group.get_all_objects(), LayoutType.HORIZONTAL)

# Camera movement
camera_movement = CameraMovement(self.camera)
camera_movement.frame_object(group)
```

## Advanced Features

### 1. Rate Functions
Available rate functions for animations:
- LINEAR
- SMOOTH
- RUSH_INTO
- RUSH_FROM
- EASE_IN
- EASE_OUT
- EXPONENTIAL
- ELASTIC
- BOUNCE
- BACK

### 2. Layout Types
Available layout arrangements:
- HORIZONTAL
- VERTICAL
- GRID
- CIRCULAR
- SPIRAL

### 3. Camera Movements
- Dolly (forward/backward)
- Orbit
- Frame objects
- Fly to position

## Best Practices

1. Scene Organization
```python
class WellOrganizedScene(Scene):
    def construct(self):
        # Setup
        self.setup_objects()
        
        # Animations
        self.animate_sequence()
        
        # Cleanup
        self.cleanup()
        
    def setup_objects(self):
        # Create and position objects
        pass
        
    def animate_sequence(self):
        # Define animation sequence
        pass
        
    def cleanup(self):
        # Cleanup code
        pass
```

2. Object Naming
```python
# Good practice
main_circle = Circle(radius=0.5).create()
main_circle.name = "main_circle"

# Group related objects
equation_group = Group("equation")
equation_group.add(symbol1, symbol2, equals_sign)
```

3. Animation Timing
```python
# Use consistent timing
standard_duration = 30
quick_duration = 15
slow_duration = 60

config = AnimationConfig(duration=standard_duration)
```

## Common Patterns

1. Creating Technical Diagrams
```python
def create_technical_diagram():
    # Create components
    components = [
        Square(size=1.0).create(),
        Circle(radius=0.5).create(),
        Arrow(start=(0,0), end=(1,1)).create()
    ]
    
    # Arrange components
    layout = Layout()
    layout.arrange(components, LayoutType.HORIZONTAL)
    
    # Add labels
    labels = [
        Text("Component A").create(),
        Text("Component B").create()
    ]
    
    return components, labels
```

2. Educational Animations
```python
def create_math_animation():
    # Create equation
    equation = LaTeXText("E = mc^2").create()
    
    # Highlight parts
    self.play(
        FadeInFrom(equation, Vector((0, -1, 0)), config),
        FlashAround(equation, color=(1, 1, 0))
    )
```

## Troubleshooting

Common issues and solutions:
1. Object not visible: Check material settings and camera position
2. Animation not playing: Verify frame ranges and animation configuration
3. Layout issues: Check object dimensions and spacing parameters

## Contributing

Guidelines for contributing:
1. Follow PEP 8 style guide
2. Add unit tests for new features
3. Update documentation
4. Use type hints
5. Follow existing patterns

==================================================

File: SceneX/scenex-v1-og-project-brief.md
Contents:
# SceneX and PyBlenderAnim Merge Strategy

## Project Overview

### Goals
- Create a unified animation system for technical and educational content
- Leverage Blender's UI through addon architecture
- Maintain Manim-inspired coordinate system and animation concepts
- Support AWS, networking, AI, and technical visualization use cases

## Directory Structure


Copy
SceneX/
├── __init__.py                    # Addon entry point
├── src/
│   ├── animation/
│   │   ├── __init__.py
│   │   ├── base.py               # Base animation classes
│   │   ├── transform.py          # Transform animations
│   │   ├── fade.py              # Fade animations
│   │   └── rate_functions.py     # Animation timing functions
│   ├── camera/
│   │   ├── __init__.py
│   │   └── camera.py            # Enhanced camera system
│   ├── core/
│   │   ├── __init__.py
│   │   ├── config.py            # Configuration classes
│   │   ├── scene.py             # Base scene class
│   │   └── constants.py         # System constants
│   ├── graphics/
│   │   ├── __init__.py
│   │   ├── mobject.py           # Basic mobile objects
│   │   ├── geometry.py          # Geometric shapes
│   │   ├── svg.py              # SVG handling
│   │   └── text.py             # Text handling
│   ├── aws/
│   │   ├── __init__.py
│   │   ├── services.py         # AWS service representations
│   │   ├── connections.py      # Service connections
│   │   └── icons.py           # AWS icon management
│   ├── physics/
│   │   ├── __init__.py
│   │   ├── particles.py        # Particle systems
│   │   └── dynamics.py         # Physics simulations
│   └── utils/
│       ├── __init__.py
│       └── logger.py           # Enhanced logging
├── ui/
│   ├── __init__.py
│   ├── panels.py              # UI panels
│   └── operators.py           # Blender operators
└── templates/
    ├── __init__.py
    └── scenes/                # Pre-built scene templates
        ├── aws.py
        ├── network.py
        └── math.py
## Integration Strategy

### Phase 1: Core Framework
1. Merge base animation system
2. Integrate coordinate system
3. Enhance camera controls
4. Implement material system

### Phase 2: Technical Features
1. AWS visualization system
2. Network topology support
3. Physics and particle systems
4. Graph and plotting capabilities

### Phase 3: UI/UX
1. Blender addon panels
2. Scene templates
3. Asset management
4. Export capabilities

## Key Components to Merge

### From PyBlenderAnim
- Rate functions and animation timing
- Advanced material system
- Physics simulation
- AWS architecture visualization

### From SceneX
- Addon structure
- UI panels and operators
- SVG handling
- Scene management

## Implementation Notes

### Animation System
- Keep PyBlenderAnim's animation classes
- Adapt for Blender addon context
- Add UI controls for animation parameters

### AWS Visualization
- Maintain current AWS service system
- Add UI for service placement
- Enhance connection animations

### Scene Management
- Use SceneX's scene organization
- Incorporate PyBlenderAnim's advanced features
- Add template system

## Future Enhancements

### Phase 4: AI Integration
- ML model visualization
- Neural network animations
- Data flow representations

### Phase 5: Advanced Features
- Real-time preview
- Custom node system
- Asset library
- Community sharing

## Migration Path
1. Set up new directory structure
2. Migrate core components
3. Integrate UI elements
4. Add advanced features
5. Implement templates
6. Test and refine

## Development Guidelines
1. Maintain consistent coding style
2. Document all components
3. Write unit tests
4. Use type hints
5. Follow Blender addon best practices

Current state of projects and code is in this file SceneX_with_API_V2_addon.txt. 

Please think chain of thought and step by step to analyze all files and come up with what it is we need to do to borrow as much as possible from the Manim coordinate system, mobejecta dn camera animation functions, and API.

Guidelines:
1. Lets ensure that the core of the integrated system is in place for a solid foundation for steps 2 and 3 below in further development. Integration testing of this cure system to make sure that the individual parts work together as expected.
2. Start detailed development of the subsystems and enhance their functionality, with unit testing. Create Test scenes that test both the basic and advanced features of each subsystem.
3. Once this is done, Integration testing combining the individual subsystems in creating complex scenes/object and camera animations/rendering, using both python blender scripting, as well as the API we borrowed from Manim. 
4. Step 3 will lead to creation of meaningful scene templates which are basic as well as feature rich 
5. Based on this, develop the Blender  addon as the UI panels leveraging  code snippets from step 3 and 4.

==================================================

File: SceneX/LaTeX _test_file.pdf
Contents:
[Binary File Content - LaTeX _test_file.pdf]


==================================================

File: SceneX/scenex-integration-plan.md
Contents:
# SceneX and Manim Integration Analysis & Implementation Plan

## Current State Analysis

### SceneX Core Components (SceneX_No_API.txt)
- Basic Blender addon structure
- Simple coordinate system
- Basic camera controls
- Scene management
- SVG import capabilities
- Material system

### PyBlenderAnim Components (SceneX_with_APU_V1_from_PyBlenderAnim.py)
- Advanced animation system
- Rate functions
- Physics simulation
- AWS visualization
- Advanced material system

### Target Integration (SceneX_with_API_V2_addon.txt)
- Unified directory structure
- Enhanced coordinate system
- Advanced animation capabilities
- AWS support
- UI panels/operators

## Integration Strategy

### Phase 1: Core Foundation Integration

1. **Coordinate System Enhancement**
```python
class CoordinateSystem:
    def __init__(self, origin=(0, 0, 0), scale=1.0):
        self.origin = mathutils.Vector(origin)
        self.scale = scale
        self.axes = {}
        self.grid = None
        
    def create_grid(self):
        # Manim-style grid creation
        pass
        
    def place_object(self, obj, position):
        # Enhanced object placement with Manim-style coordinates
        world_pos = self.origin + position * self.scale
        obj.location = world_pos
```

2. **Camera System Integration**
```python
class CameraSystem:
    def __init__(self):
        self.camera = None
        self.frame_center = mathutils.Vector((0, 0, 0))
        self.frame_width = 14.0  # Manim default
        
    def frame_point(self, point):
        # Manim-style camera framing
        pass
```

3. **Mobile Object System**
```python
class Mobject:
    def __init__(self):
        self.data = None
        self.points = []
        self.submobjects = []
        
    def add(self, *mobjects):
        # Manim-style object hierarchy
        self.submobjects.extend(mobjects)
```

### Phase 2: Animation System Integration

1. **Animation Base Classes**
```python
class Animation:
    def __init__(self, mobject, **kwargs):
        self.mobject = mobject
        self.rate_func = kwargs.get('rate_func', smooth)
        
    def interpolate(self, alpha):
        # Manim-style interpolation
        pass
```

2. **Transform Animations**
```python
class Transform(Animation):
    def interpolate_submobject(self, submob, start, end, alpha):
        # Manim-style transformation
        pass
```

### Phase 3: Scene System Integration

```python
class Scene:
    def __init__(self):
        self.camera = CameraSystem()
        self.coordinate_system = CoordinateSystem()
        self.mobjects = []
        
    def play(self, *animations):
        # Manim-style animation playing
        pass
        
    def wait(self, duration=1):
        # Manim-style waiting
        pass
```

## Implementation Plan

### Step 1: Core Systems
1. Set up base directory structure
2. Implement enhanced coordinate system
3. Integrate camera system
4. Create basic mobject system

### Step 2: Animation Framework
1. Port rate functions
2. Implement animation base classes
3. Create transform animations
4. Add fade and movement animations

### Step 3: Scene Management
1. Implement scene base class
2. Add animation playing system
3. Create camera movement system
4. Add object management

### Step 4: Testing Structure
1. Create unit tests for each subsystem
2. Implement integration tests
3. Create example scenes
4. Test performance and stability

## Test Scene Examples

```python
class TestScene(Scene):
    def construct(self):
        # Create square at Manim coordinates (-2, 0, 0)
        square = Square().shift(LEFT * 2)
        
        # Create circle at Manim coordinates (2, 0, 0)
        circle = Circle().shift(RIGHT * 2)
        
        # Play Manim-style animation
        self.play(Transform(square, circle))
```

## Integration Testing Plan

1. **Core Systems Testing**
   - Coordinate system accuracy
   - Camera movement and framing
   - Object placement and hierarchy

2. **Animation Testing**
   - Rate function accuracy
   - Transform animations
   - Complex animation sequences

3. **Scene Management Testing**
   - Object lifecycle management
   - Animation scheduling
   - Camera system integration

## Next Steps

1. **Immediate Tasks**
   - Set up project structure
   - Port core coordinate system
   - Implement basic mobject system
   - Create initial test scenes

2. **Short-term Goals**
   - Complete animation system
   - Integrate camera controls
   - Create basic example scenes
   - Initial unit tests

3. **Long-term Goals**
   - AWS visualization system
   - Physics integration
   - UI panel development
   - Template system

## Development Guidelines

1. **Code Structure**
   - Use type hints
   - Follow PEP 8
   - Document all classes and methods
   - Create comprehensive tests

2. **Testing Strategy**
   - Unit tests for each component
   - Integration tests for subsystems
   - Example scenes as functional tests
   - Performance benchmarks

3. **Documentation**
   - Inline documentation
   - API documentation
   - Example usage
   - Tutorial scenes

## Success Criteria

1. **Core Functionality**
   - Accurate coordinate system
   - Smooth animations
   - Stable camera system
   - Reliable object management

2. **Integration**
   - Seamless Manim-style API
   - Compatible with Blender
   - Efficient performance
   - Reliable rendering

3. **User Experience**
   - Intuitive API
   - Comprehensive documentation
   - Example scenes
   - Error handling

## Timeline

1. **Phase 1 (Core Systems): 2 weeks**
   - Directory structure
   - Coordinate system
   - Basic mobject system
   - Initial tests

2. **Phase 2 (Animation): 2 weeks**
   - Animation classes
   - Rate functions
   - Transform system
   - Animation tests

3. **Phase 3 (Scene Management): 2 weeks**
   - Scene system
   - Camera integration
   - Example scenes
   - Integration tests

4. **Phase 4 (Polish): 2 weeks**
   - Documentation
   - Performance optimization
   - Bug fixes
   - User testing

==================================================

File: SceneX/LaTeX _test_file.aux
Contents:
\relax 
\gdef \@abspage@last{1}


==================================================

File: SceneX/merge-plan.md
Contents:
# SceneX and PyBlenderAnim Merge Strategy

## Project Overview

### Goals
- Create a unified animation system for technical and educational content
- Leverage Blender's UI through addon architecture
- Maintain Manim-inspired coordinate system and animation concepts
- Support AWS, networking, AI, and technical visualization use cases

## Directory Structure

```
SceneX/
├── __init__.py                    # Addon entry point
├── src/
│   ├── animation/
│   │   ├── __init__.py
│   │   ├── base.py               # Base animation classes
│   │   ├── transform.py          # Transform animations
│   │   ├── fade.py              # Fade animations
│   │   └── rate_functions.py     # Animation timing functions
│   ├── camera/
│   │   ├── __init__.py
│   │   └── camera.py            # Enhanced camera system
│   ├── core/
│   │   ├── __init__.py
│   │   ├── config.py            # Configuration classes
│   │   ├── scene.py             # Base scene class
│   │   └── constants.py         # System constants
│   ├── graphics/
│   │   ├── __init__.py
│   │   ├── mobject.py           # Basic mobile objects
│   │   ├── geometry.py          # Geometric shapes
│   │   ├── svg.py              # SVG handling
│   │   └── text.py             # Text handling
│   ├── aws/
│   │   ├── __init__.py
│   │   ├── services.py         # AWS service representations
│   │   ├── connections.py      # Service connections
│   │   └── icons.py           # AWS icon management
│   ├── physics/
│   │   ├── __init__.py
│   │   ├── particles.py        # Particle systems
│   │   └── dynamics.py         # Physics simulations
│   └── utils/
│       ├── __init__.py
│       └── logger.py           # Enhanced logging
├── ui/
│   ├── __init__.py
│   ├── panels.py              # UI panels
│   └── operators.py           # Blender operators
└── templates/
    ├── __init__.py
    └── scenes/                # Pre-built scene templates
        ├── aws.py
        ├── network.py
        └── math.py
```

## Integration Strategy

### Phase 1: Core Framework
1. Merge base animation system
2. Integrate coordinate system
3. Enhance camera controls
4. Implement material system

### Phase 2: Technical Features
1. AWS visualization system
2. Network topology support
3. Physics and particle systems
4. Graph and plotting capabilities

### Phase 3: UI/UX
1. Blender addon panels
2. Scene templates
3. Asset management
4. Export capabilities

## Key Components to Merge

### From PyBlenderAnim
- Rate functions and animation timing
- Advanced material system
- Physics simulation
- AWS architecture visualization

### From SceneX
- Addon structure
- UI panels and operators
- SVG handling
- Scene management

## Implementation Notes

### Animation System
- Keep PyBlenderAnim's animation classes
- Adapt for Blender addon context
- Add UI controls for animation parameters

### AWS Visualization
- Maintain current AWS service system
- Add UI for service placement
- Enhance connection animations

### Scene Management
- Use SceneX's scene organization
- Incorporate PyBlenderAnim's advanced features
- Add template system

## Future Enhancements

### Phase 4: AI Integration
- ML model visualization
- Neural network animations
- Data flow representations

### Phase 5: Advanced Features
- Real-time preview
- Custom node system
- Asset library
- Community sharing

## Migration Path
1. Set up new directory structure
2. Migrate core components
3. Integrate UI elements
4. Add advanced features
5. Implement templates
6. Test and refine

## Development Guidelines
1. Maintain consistent coding style
2. Document all components
3. Write unit tests
4. Use type hints
5. Follow Blender addon best practices

==================================================

File: SceneX/LaTex/LaTeX _test_file.tex
Contents:
\documentclass{article}
\usepackage{amsmath}
\begin{document}
Testing $E = mc^2$ with LaTeX.
\end{document}

==================================================

File: SceneX/src/materials/material.py
Contents:
# SceneX/src/materials/material.py

import bpy
from dataclasses import dataclass
from typing import Tuple, Optional, Dict, Any
from enum import Enum
from ..utils.logger import SceneXLogger

class MaterialType(Enum):
    BASIC = "basic"
    GLASS = "glass"
    EMISSION = "emission"
    METALLIC = "metallic"
    TOON = "toon"


@dataclass
class MaterialConfig:
    type: MaterialType = MaterialType.BASIC
    color: Tuple[float, float, float, float] = (1, 1, 1, 1)
    roughness: float = 0.5
    emission_strength: float = 0.0
    emission_color: Optional[Tuple[float, float, float, float]] = None
    alpha: float = 1.0
    ior: float = 1.45


class Material:
    def __init__(self, name: str, config: MaterialConfig):
        self.name = name
        self.config = config
        self.material = None
        self.logger = SceneXLogger("Material")

    def create(self) -> bpy.types.Material:
        self.material = bpy.data.materials.new(name=self.name)
        self.material.use_nodes = True
        self.setup_nodes()
        return self.material

    def setup_nodes(self):
        if not self.material:
            return

        nodes = self.material.node_tree.nodes
        links = self.material.node_tree.links
        nodes.clear()

        principled = nodes.new('ShaderNodeBsdfPrincipled')
        output = nodes.new('ShaderNodeOutputMaterial')

        principled.inputs['Base Color'].default_value = self.config.color
        principled.inputs['Roughness'].default_value = self.config.roughness

        links.new(principled.outputs['BSDF'], output.inputs['Surface'])

        if self.config.alpha < 1.0:
            self.material.blend_method = 'BLEND'


==================================================

File: SceneX/src/materials/material copy.py
Contents:
# SceneX/src/materials/material.py

import bpy
from dataclasses import dataclass
from typing import Tuple, Optional, Dict, Any
from enum import Enum
from ..utils.logger import SceneXLogger

class MaterialType(Enum):
    BASIC = "basic"
    GLASS = "glass" 
    EMISSION = "emission"
    METALLIC = "metallic"
    TOON = "toon"

@dataclass
class MaterialConfig:
    """Configuration for materials"""
    type: MaterialType = MaterialType.BASIC
    color: Tuple[float, float, float, float] = (1, 1, 1, 1)
    metallic: float = 0.0
    roughness: float = 0.5
    emission_strength: float = 0.0
    emission_color: Optional[Tuple[float, float, float, float]] = None
    alpha: float = 1.0
    ior: float = 1.45  # For glass
    use_subsurface: bool = False
    subsurface_color: Optional[Tuple[float, float, float, float]] = None

class Material:
    """Base material class"""
    def __init__(self, name: str, config: MaterialConfig):
        self.name = name
        self.config = config
        self.material = None
        self.logger = SceneXLogger("Material")
        
    def create(self) -> bpy.types.Material:
        """Create Blender material"""
        self.material = bpy.data.materials.new(name=self.name)
        self.material.use_nodes = True
        self.setup_nodes()
        return self.material
        
    def setup_nodes(self):
        """Set up node tree based on material type"""
        if not self.material:
            return
            
        nodes = self.material.node_tree.nodes
        links = self.material.node_tree.links
        nodes.clear()
        
        if self.config.type == MaterialType.BASIC:
            self._setup_basic_material(nodes, links)
        elif self.config.type == MaterialType.GLASS:
            self._setup_glass_material(nodes, links)
        elif self.config.type == MaterialType.EMISSION:
            self._setup_emission_material(nodes, links)
        elif self.config.type == MaterialType.METALLIC:
            self._setup_metallic_material(nodes, links)
        elif self.config.type == MaterialType.TOON:
            self._setup_toon_material(nodes, links)

    def _setup_basic_material(self, nodes, links):
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        principled.inputs['Base Color'].default_value = self.config.color
        principled.inputs['Alpha'].default_value = self.config.alpha
        principled.inputs['Roughness'].default_value = self.config.roughness
        
        links.new(principled.outputs['BSDF'], output.inputs['Surface'])
        
        if self.config.alpha < 1.0:
            self.material.blend_method = 'BLEND'

    def _setup_glass_material(self, nodes, links):
        glass = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        glass.inputs['Color'].default_value = self.config.color
        glass.inputs['Roughness'].default_value = self.config.roughness
        glass.inputs['IOR'].default_value = self.config.ior
        
        links.new(glass.outputs['BSDF'], output.inputs['Surface'])
        self.material.blend_method = 'BLEND'

    def _setup_emission_material(self, nodes, links):
        emission = nodes.new('ShaderNodeEmission')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        emission.inputs['Color'].default_value = self.config.emission_color or self.config.color
        emission.inputs['Strength'].default_value = self.config.emission_strength
        
        links.new(emission.outputs['Emission'], output.inputs['Surface'])

    def _setup_metallic_material(self, nodes, links):
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        principled.inputs['Base Color'].default_value = self.config.color
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = self.config.roughness
        
        links.new(principled.outputs['BSDF'], output.inputs['Surface'])

    def _setup_toon_material(self, nodes, links):
        diffuse = nodes.new('ShaderNodeBsdfDiffuse')
        toon = nodes.new('ShaderNodeBsdfToon')
        mix = nodes.new('ShaderNodeMixShader')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        diffuse.inputs['Color'].default_value = self.config.color
        toon.inputs['Color'].default_value = self.config.color
        mix.inputs[0].default_value = 0.5
        
        links.new(diffuse.outputs['BSDF'], mix.inputs[1])
        links.new(toon.outputs['BSDF'], mix.inputs[2])
        links.new(mix.outputs['Shader'], output.inputs['Surface'])

==================================================

File: SceneX/src/svg/svg.py
Contents:
# src/svg/svg.py
import bpy
import os
from pathlib import Path
import mathutils
from utils.logger import SceneXLogger

# Initialize logger
logger = SceneXLogger("SVG")

def import_svg(svg_filename, scale=5.0, location=(0, 0, 0)):
    """Import an SVG and return the parent container (Empty)."""
    logger.info(f"Starting SVG import process for {svg_filename}")
    
    svg_path = Path(os.path.join(os.path.dirname(__file__), svg_filename))
    logger.debug(f"Full SVG path: {svg_path}")
    
    if not svg_path.exists():
        logger.error(f"SVG file not found at: {svg_path}")
        raise FileNotFoundError(f"SVG file not found at: {svg_path}")

    # Store initial state
    initial_objects = set(bpy.data.objects)
    logger.debug(f"Number of objects before import: {len(initial_objects)}")

    try:
        logger.debug("Attempting to import SVG file...")
        bpy.ops.import_curve.svg(filepath=str(svg_path))
        logger.debug("SVG import operation completed")
    except Exception as e:
        logger.error(f"Error during SVG import: {str(e)}")
        return None
    
    # Get new objects
    new_objects = set(bpy.data.objects) - initial_objects
    logger.debug(f"New objects created: {len(new_objects)}")
    
    imported_objects = [obj for obj in new_objects if obj.type == 'CURVE']
    logger.debug(f"Number of curve objects found: {len(imported_objects)}")
    
    if not imported_objects:
        logger.error("No curve objects were imported from the SVG.")
        return None

    # Create Parent Empty
    logger.debug("Creating parent empty object...")
    bpy.ops.object.empty_add(type='PLAIN_AXES', align='WORLD', location=(0, 0, 0))
    parent = bpy.context.active_object
    parent.name = "Logo_Container"

    # Parent imported objects
    logger.debug("Parenting imported objects...")
    for obj in imported_objects:
        logger.debug(f"Processing object: {obj.name}")
        obj.data.dimensions = '2D'
        obj.data.fill_mode = 'BOTH'
        obj.parent = parent
        obj.location = (0, 0, 0)
    
    # Scale and position
    logger.info("Scaling and positioning logo container...")
    scale_and_position_logo(parent, scale_factor=scale, location=location)
    
    logger.info(f"SVG import complete: {parent.name}")
    return parent

def scale_and_position_logo(logo_container, scale_factor=11.0, location=(0, 0, 0)):
    """Scale and place the logo at specified coordinates."""
    if not logo_container:
        logger.warning("No logo container provided")
        return
    
    logger.debug(f"Initial scale_factor: {scale_factor}")
    logo_container.scale = (scale_factor, scale_factor, scale_factor)
    logger.debug(f"Applied scale: {logo_container.scale}")
    
    logo_container.location = mathutils.Vector(location)
    logger.debug(f"Set position to: {location}")
    
    bpy.context.view_layer.update()
    logger.info(f"Logo positioned with scale factor: {scale_factor}")

def position_logo_bottom_right(logo_container, margin=1.0):
    """Position the logo at the bottom-right corner."""
    if not logo_container:
        logger.warning("No logo container provided for positioning")
        return
    
    logger.debug(f"Starting bottom-right positioning with margin: {margin}")
    position = (7, -4, 0)  # Fixed coordinate position
    
    logo_container.location = mathutils.Vector(position)
    logger.debug(f"Set position to: {position}")
    
    bpy.context.view_layer.update()
    logger.info(f"Logo positioned at: {position}")

def dynamic_scale(logo_container, target_width=1920):
    current_width = bpy.context.scene.render.resolution_x
    scale_factor = target_width / current_width
    logo_container.scale *= scale_factor


==================================================

File: SceneX/src/svg/svg_handler.py
Contents:
# src/svg/svg_handler.py

import bpy
import os
from pathlib import Path
from ..utils.logger import SceneXLogger

class SVGHandler:
    """Handle SVG import and manipulation"""
    def __init__(self):
        self.logger = SceneXLogger("SVGHandler")
        
    def import_svg(self, svg_filename: str, scale: float = 1.0, location=(0, 0, 0)):
        """Import SVG and return parent container"""
        self.logger.info(f"Starting SVG import for {svg_filename}")
        
        # Get SVG path
        svg_path = Path(os.path.join(os.path.dirname(__file__), svg_filename))
        self.logger.debug(f"Full SVG path: {svg_path}")
        
        if not svg_path.exists():
            self.logger.error(f"SVG file not found at: {svg_path}")
            raise FileNotFoundError(f"SVG file not found at: {svg_path}")

        # Store initial state
        initial_objects = set(bpy.data.objects)

        try:
            # Import SVG
            self.logger.debug("Importing SVG file...")
            bpy.ops.import_curve.svg(filepath=str(svg_path))
            
            # Get new objects
            new_objects = [obj for obj in bpy.data.objects 
                         if obj not in initial_objects and obj.type in ['CURVE', 'GPENCIL']]
            
            if not new_objects:
                self.logger.error("No curve objects imported from SVG")
                return None

            # Create parent empty
            bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
            parent = bpy.context.active_object
            parent.name = "SVG_Container"

            # Process imported objects
            for obj in new_objects:
                self.logger.debug(f"Processing {obj.name}")
                if obj.type == 'CURVE':
                    obj.data.dimensions = '2D'
                    obj.data.fill_mode = 'BOTH'
                obj.parent = parent
                obj.location = (0, 0, 0)

            # Apply scale and position
            parent.scale = (scale, scale, scale)
            parent.location = location
            
            self.logger.info("SVG import completed successfully")
            return parent

        except Exception as e:
            self.logger.error(f"Error during SVG import: {str(e)}")
            return None

    def scale_svg(self, svg_container, scale_factor: float = 1.0):
        """Scale SVG container"""
        if not svg_container:
            self.logger.warning("No SVG container provided for scaling")
            return
            
        svg_container.scale = (scale_factor, scale_factor, scale_factor)
        self.logger.info(f"SVG scaled by factor: {scale_factor}")

    def position_svg(self, svg_container, location=(0, 0, 0)):
        """Position SVG container"""
        if not svg_container:
            self.logger.warning("No SVG container provided for positioning")
            return
            
        svg_container.location = location
        self.logger.info(f"SVG positioned at: {location}")

    def get_svg_dimensions(self, svg_container):
        """Get dimensions of SVG container"""
        if not svg_container:
            return (0, 0, 0)
            
        # Calculate bounds from all child objects
        min_x = min_y = min_z = float('inf')
        max_x = max_y = max_z = float('-inf')
        
        for obj in svg_container.children:
            if obj.type == 'CURVE':
                for point in obj.bound_box:
                    x, y, z = point
                    min_x = min(min_x, x)
                    max_x = max(max_x, x)
                    min_y = min(min_y, y)
                    max_y = max(max_y, y)
                    min_z = min(min_z, z)
                    max_z = max(max_z, z)
        
        return (
            max_x - min_x,
            max_y - min_y,
            max_z - min_z
        )

==================================================

File: SceneX/src/svg/SceneX_logo.svg
Contents:
<?xml version="1.0" encoding="utf-8"?>

<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none">

<path fill="#252F3E" d="M4.51 7.687c0 .197.02.357.058.475.042.117.096.245.17.384a.233.233 0 01.037.123c0 .053-.032.107-.1.16l-.336.224a.255.255 0 01-.138.048c-.054 0-.107-.026-.16-.074a1.652 1.652 0 01-.192-.251 4.137 4.137 0 01-.165-.315c-.415.491-.936.737-1.564.737-.447 0-.804-.129-1.064-.385-.261-.256-.394-.598-.394-1.025 0-.454.16-.822.484-1.1.325-.278.756-.416 1.304-.416.18 0 .367.016.564.042.197.027.4.07.612.118v-.39c0-.406-.085-.689-.25-.854-.17-.166-.458-.246-.868-.246-.186 0-.377.022-.574.07a4.23 4.23 0 00-.575.181 1.525 1.525 0 01-.186.07.326.326 0 01-.085.016c-.075 0-.112-.054-.112-.166v-.262c0-.085.01-.15.037-.186a.399.399 0 01.15-.113c.185-.096.409-.176.67-.24.26-.07.537-.101.83-.101.633 0 1.096.144 1.394.432.293.288.442.726.442 1.314v1.73h.01zm-2.161.811c.175 0 .356-.032.548-.096.191-.064.362-.182.505-.342a.848.848 0 00.181-.341c.032-.129.054-.283.054-.465V7.03a4.43 4.43 0 00-.49-.09 3.996 3.996 0 00-.5-.033c-.357 0-.618.07-.793.214-.176.144-.26.347-.26.614 0 .25.063.437.196.566.128.133.314.197.559.197zm4.273.577c-.096 0-.16-.016-.202-.054-.043-.032-.08-.106-.112-.208l-1.25-4.127a.938.938 0 01-.049-.214c0-.085.043-.133.128-.133h.522c.1 0 .17.016.207.053.043.032.075.107.107.208l.894 3.535.83-3.535c.026-.106.058-.176.1-.208a.365.365 0 01.214-.053h.425c.102 0 .17.016.213.053.043.032.08.107.101.208l.841 3.578.92-3.578a.458.458 0 01.107-.208.346.346 0 01.208-.053h.495c.085 0 .133.043.133.133 0 .027-.006.054-.01.086a.76.76 0 01-.038.133l-1.283 4.127c-.032.107-.069.177-.111.209a.34.34 0 01-.203.053h-.457c-.101 0-.17-.016-.213-.053-.043-.038-.08-.107-.101-.214L8.213 5.37l-.82 3.439c-.026.107-.058.176-.1.213-.043.038-.118.054-.213.054h-.458zm6.838.144a3.51 3.51 0 01-.82-.096c-.266-.064-.473-.134-.612-.214-.085-.048-.143-.101-.165-.15a.378.378 0 01-.031-.149v-.272c0-.112.042-.166.122-.166a.3.3 0 01.096.016c.032.011.08.032.133.054.18.08.378.144.585.187.213.042.42.064.633.064.336 0 .596-.059.777-.176a.575.575 0 00.277-.508.52.52 0 00-.144-.373c-.095-.102-.276-.193-.537-.278l-.772-.24c-.388-.123-.676-.305-.851-.545a1.275 1.275 0 01-.266-.774c0-.224.048-.422.143-.593.096-.17.224-.32.384-.438.16-.122.34-.213.553-.277.213-.064.436-.091.67-.091.118 0 .24.005.357.021.122.016.234.038.346.06.106.026.208.052.303.085.096.032.17.064.224.096a.46.46 0 01.16.133.289.289 0 01.047.176v.251c0 .112-.042.171-.122.171a.552.552 0 01-.202-.064 2.427 2.427 0 00-1.022-.208c-.303 0-.543.048-.708.15-.165.1-.25.256-.25.475 0 .149.053.277.16.379.106.101.303.202.585.293l.756.24c.383.123.66.294.825.513.165.219.244.47.244.748 0 .23-.047.437-.138.619a1.436 1.436 0 01-.388.47c-.165.133-.362.23-.591.299-.24.075-.49.112-.761.112z"/>

<g fill="#F90" fill-rule="evenodd" clip-rule="evenodd">

<path d="M14.465 11.813c-1.75 1.297-4.294 1.986-6.481 1.986-3.065 0-5.827-1.137-7.913-3.027-.165-.15-.016-.353.18-.235 2.257 1.313 5.04 2.109 7.92 2.109 1.941 0 4.075-.406 6.039-1.239.293-.133.543.192.255.406z"/>

<path d="M15.194 10.98c-.223-.287-1.479-.138-2.048-.069-.17.022-.197-.128-.043-.24 1-.705 2.645-.502 2.836-.267.192.24-.053 1.89-.99 2.68-.143.123-.281.06-.218-.1.213-.53.687-1.72.463-2.003z"/>

</g>

</svg>

==================================================

File: SceneX/src/camera/movements.py
Contents:
# SceneX/src/camera/movements.py

import bpy
import math
from mathutils import Vector, Matrix, Euler
from typing import List, Optional, Union
from ..utils.logger import SceneXLogger
from ..scene.groups import Group

class CameraMovement:
    def __init__(self, camera_system):
        self.camera = camera_system.camera
        self.target = camera_system.target
        self.logger = SceneXLogger("CameraMovement")

    def dolly(self, distance: float, duration: int = 30):
        """Move camera forward/backward"""
        start_loc = self.camera.location.copy()
        direction = (self.target.location - start_loc).normalized()
        end_loc = start_loc + direction * distance

        self._animate_movement(start_loc, end_loc, duration)

    def orbit(self, angle: float, axis: str = 'Z', duration: int = 30):
        """Orbit around target"""
        center = self.target.location
        radius = (self.camera.location - center).length
        start_angle = math.atan2(self.camera.location.y - center.y, 
                               self.camera.location.x - center.x)

        for frame in range(duration + 1):
            current_angle = start_angle + (angle * frame / duration)
            if axis == 'Z':
                x = center.x + radius * math.cos(current_angle)
                y = center.y + radius * math.sin(current_angle)
                z = self.camera.location.z
            else:  # 'Y' axis
                x = center.x + radius * math.cos(current_angle)
                z = center.z + radius * math.sin(current_angle)
                y = self.camera.location.y

            self.camera.location = Vector((x, y, z))
            self.camera.keyframe_insert(data_path="location", frame=frame)

    def frame_object(self, obj: Union[bpy.types.Object, Group], padding: float = 1.2):
        """Frame camera to focus on object/group"""
        if isinstance(obj, Group):
            bounds = obj.get_bounds()
        else:
            bounds = [(min(v[i] for v in obj.bound_box), 
                      max(v[i] for v in obj.bound_box)) for i in range(3)]

        center = Vector(((bounds[0][0] + bounds[0][1])/2,
                        (bounds[1][0] + bounds[1][1])/2,
                        (bounds[2][0] + bounds[2][1])/2))

        size = max(bounds[0][1] - bounds[0][0],
                  bounds[1][1] - bounds[1][0],
                  bounds[2][1] - bounds[2][0])

        distance = size * padding
        self.target.location = center
        self.camera.location = center + Vector((0, -distance, distance/2))

    def fly_to(self, location: Vector, target: Optional[Vector] = None, 
               duration: int = 30):
        """Smoothly move camera to new position/target"""
        start_loc = self.camera.location.copy()
        start_target = self.target.location.copy()

        if target is None:
            target = self.target.location

        for frame in range(duration + 1):
            factor = frame / duration
            self.camera.location = start_loc.lerp(location, factor)
            self.target.location = start_target.lerp(target, factor)
            
            self.camera.keyframe_insert(data_path="location", frame=frame)
            self.target.keyframe_insert(data_path="location", frame=frame)

    def _animate_movement(self, start: Vector, end: Vector, duration: int):
        """Helper to animate camera movement"""
        for frame in range(duration + 1):
            factor = frame / duration
            self.camera.location = start.lerp(end, factor)
            self.camera.keyframe_insert(data_path="location", frame=frame)

    def set_orthographic(self, orthographic: bool = True):
        """Switch between orthographic and perspective"""
        self.camera.data.type = 'ORTHO' if orthographic else 'PERSP'
        if orthographic:
            self.camera.data.ortho_scale = 10.0

==================================================

File: SceneX/src/camera/camera.py
Contents:
# SceneX/src/camera/camera.py
import bpy
import math
import mathutils
from src.utils.logger import SceneXLogger
from dataclasses import dataclass
from typing import Optional, Tuple

@dataclass
class CameraConfig:
    """Configuration for camera setup"""
    frame_width: float = 14.0
    frame_height: float = 8.0
    focal_length: float = 50
    distance: float = 10.0
    angle: float = 55.0
    position: Tuple[float, float, float] = (7, -7, 5)
    target_origin: bool = True

class CameraSystem:
    def __init__(self, config: Optional[CameraConfig] = None):
        self.config = config or CameraConfig()
        self.camera = None
        self.target = None
        self.logger = SceneXLogger("CameraSystem")
        self.setup()

    def setup(self):
        """Initialize camera with Manim-style defaults"""
        self.logger.info("Setting up camera")
        try:
            # Create camera
            if not self.camera:
                bpy.ops.object.camera_add(location=self.config.position)
                self.camera = bpy.context.active_object
            
            # Set as active camera
            bpy.context.scene.camera = self.camera
            self.camera.rotation_euler = (math.radians(45), 0, math.radians(45))
            
            # Create target for tracking
            if self.config.target_origin:
                bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
                self.target = bpy.context.active_object
                self.target.name = "CameraTarget"
                self._setup_constraints()

            # Setup keyframes
            self.camera.keyframe_insert(data_path="location", frame=1)
            self.camera.keyframe_insert(data_path="rotation_euler", frame=1)
            
            if self.target:
                self.target.keyframe_insert(data_path="location", frame=1)

            # Create animation data
            if not self.camera.animation_data:
                self.camera.animation_data_create()
                
            self.logger.info("Camera setup complete")
            
        except Exception as e:
            self.logger.error(f"Error setting up camera: {str(e)}")

    def _setup_constraints(self):
        """Setup camera constraints for tracking"""
        self.camera.constraints.clear()
        track = self.camera.constraints.new(type='TRACK_TO')
        track.target = self.target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'

    # [Rest of the existing methods remain unchanged: frame_point, 
    #  animate_movement, animate_rotation_around_target, zoom]

    def frame_point(self, point: mathutils.Vector):
        """Frame camera to look at specific point"""
        self.logger.info(f"Framing point: {point}")
        
        try:
            # Move target to point
            self.target.location = point
            
            # Update scene
            bpy.context.view_layer.update()
            
        except Exception as e:
            self.logger.error(f"Error framing point: {str(e)}")

    def animate_movement(self, start_frame: int, end_frame: int, 
                        target_location: mathutils.Vector, 
                        target_rotation: Optional[Tuple[float, float, float]] = None):
        """Animate camera movement between frames"""
        self.logger.info(f"Animating camera from frame {start_frame} to {end_frame}")
        
        try:
            # Set initial keyframe
            self.camera.location.keyframe_insert(data_path="location", frame=start_frame)
            if target_rotation:
                self.camera.rotation_euler.keyframe_insert(data_path="rotation_euler", frame=start_frame)
            
            # Set target keyframe
            self.camera.location = target_location
            self.camera.keyframe_insert(data_path="location", frame=end_frame)
            
            if target_rotation:
                self.camera.rotation_euler = mathutils.Euler(target_rotation)
                self.camera.keyframe_insert(data_path="rotation_euler", frame=end_frame)
                
            # Set interpolation
            if self.camera.animation_data and self.camera.animation_data.action:
                for fc in self.camera.animation_data.action.fcurves:
                    for kf in fc.keyframe_points:
                        kf.interpolation = 'BEZIER'
                        kf.easing = 'EASE_IN_OUT'
                    
        except Exception as e:
            self.logger.error(f"Error animating camera: {str(e)}")

    def animate_rotation_around_target(self, start_frame: int, end_frame: int, 
                                     start_angles: Tuple[float, float], 
                                     end_angles: Tuple[float, float]):
        """Animate camera rotating around target point"""
        self.logger.info(f"Animating camera rotation from frame {start_frame} to {end_frame}")
        
        try:
            # Temporarily clear constraints
            constraints = self.camera.constraints.copy()
            self.camera.constraints.clear()
            
            # Calculate and set start position
            phi_start, theta_start = start_angles
            x_start = self.config.distance * math.sin(theta_start) * math.cos(phi_start)
            y_start = self.config.distance * math.cos(theta_start) * math.cos(phi_start)
            z_start = self.config.distance * math.sin(phi_start)
            
            self.camera.location = (x_start, y_start, z_start)
            self.camera.keyframe_insert(data_path="location", frame=start_frame)
            
            # Calculate and set end position
            phi_end, theta_end = end_angles
            x_end = self.config.distance * math.sin(theta_end) * math.cos(phi_end)
            y_end = self.config.distance * math.cos(theta_end) * math.cos(phi_end)
            z_end = self.config.distance * math.sin(phi_end)
            
            self.camera.location = (x_end, y_end, z_end)
            self.camera.keyframe_insert(data_path="location", frame=end_frame)
            
            # Also animate rotation to keep facing center
            for frame in range(start_frame, end_frame + 1, 10):  # Add intermediate keyframes
                t = (frame - start_frame) / (end_frame - start_frame)
                theta_current = theta_start + t * (theta_end - theta_start)
                phi_current = phi_start + t * (phi_end - phi_start)
                
                # Update camera rotation to look at target
                direction = -mathutils.Vector((
                    math.sin(theta_current) * math.cos(phi_current),
                    math.cos(theta_current) * math.cos(phi_current),
                    math.sin(phi_current)
                ))
                rot_quat = direction.to_track_quat('-Z', 'Y')
                self.camera.rotation_euler = rot_quat.to_euler()
                self.camera.keyframe_insert(data_path="rotation_euler", frame=frame)
            
            # Restore constraints
            for constraint in constraints:
                self.camera.constraints.append(constraint)
            
            # Set smooth interpolation
            if self.camera.animation_data and self.camera.animation_data.action:
                for fc in self.camera.animation_data.action.fcurves:
                    for kf in fc.keyframe_points:
                        kf.interpolation = 'BEZIER'
                        kf.easing = 'EASE_IN_OUT'
                        
        except Exception as e:
            self.logger.error(f"Error animating camera rotation: {str(e)}")

    def zoom(self, factor: float):
        """Zoom camera by factor"""
        try:
            # Adjust camera distance
            current_loc = mathutils.Vector(self.camera.location)
            target_loc = mathutils.Vector(self.target.location)
            direction = (current_loc - target_loc).normalized()
            
            new_distance = self.config.distance * factor
            new_loc = target_loc + direction * new_distance
            
            self.camera.location = new_loc
            
        except Exception as e:
            self.logger.error(f"Error zooming camera: {str(e)}")


==================================================

File: SceneX/src/camera/camera copy.py
Contents:
# SceneX/src/camera/camera.py
import bpy
import math
import mathutils
from src.utils.logger import SceneXLogger
from dataclasses import dataclass
from typing import Optional, Tuple

@dataclass
class CameraConfig:
    """Configuration for camera setup"""
    frame_width: float = 14.0  # Manim-style default
    frame_height: float = 8.0
    focal_length: float = 50
    distance: float = 10.0
    angle: float = 55.0  # Degrees
    position: Tuple[float, float, float] = (0, 0, 0)

class CameraSystem:
    def __init__(self, config: Optional[CameraConfig] = None):
        self.config = config or CameraConfig()
        self.camera = None
        self.target = None
        self.logger = SceneXLogger("CameraSystem")

    def setup(self):
        """Initialize camera with Manim-style defaults"""
        self.logger.info("Setting up camera")
        
        try:
            # Create camera if it doesn't exist
            if not self.camera:
                bpy.ops.object.camera_add()
                self.camera = bpy.context.active_object
                
            # Set as active camera
            bpy.context.scene.camera = self.camera
            
            # Set initial position
            self.camera.location = (0, -self.config.distance, self.config.distance)
            self.camera.rotation_euler = (math.radians(self.config.angle), 0, 0)
            
            # Configure camera settings
            cam_data = self.camera.data
            cam_data.lens = self.config.focal_length
            
            # Create target empty for tracking
            if not self.target:
                bpy.ops.object.empty_add(type='PLAIN_AXES')
                self.target = bpy.context.active_object
                self.target.name = "CameraTarget"
                
            # Setup camera constraints
            self._setup_constraints()
            
            self.logger.info("Camera setup complete")
            
        except Exception as e:
            self.logger.error(f"Error setting up camera: {str(e)}")

    def _setup_constraints(self):
        """Setup camera constraints for tracking"""
        # Clear existing constraints
        self.camera.constraints.clear()
        
        # Add track to constraint
        track = self.camera.constraints.new(type='TRACK_TO')
        track.target = self.target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'

    def frame_point(self, point: mathutils.Vector):
        """Frame camera to look at specific point"""
        self.logger.info(f"Framing point: {point}")
        
        try:
            # Move target to point
            self.target.location = point
            
            # Update scene
            bpy.context.view_layer.update()
            
        except Exception as e:
            self.logger.error(f"Error framing point: {str(e)}")

    def zoom(self, factor: float):
        """Zoom camera by factor"""
        try:
            # Adjust camera distance
            current_loc = mathutils.Vector(self.camera.location)
            target_loc = mathutils.Vector(self.target.location)
            direction = (current_loc - target_loc).normalized()
            
            new_distance = self.config.distance * factor
            new_loc = target_loc + direction * new_distance
            
            self.camera.location = new_loc
            
        except Exception as e:
            self.logger.error(f"Error zooming camera: {str(e)}")

    def rotate(self, phi: float, theta: float):
        """Rotate camera around target (phi: up/down, theta: left/right)"""
        try:
            # Calculate new position
            distance = self.config.distance
            x = distance * math.sin(theta) * math.cos(phi)
            y = distance * math.cos(theta) * math.cos(phi)
            z = distance * math.sin(phi)
            
            # Update camera position
            self.camera.location = (x, y, z)
            
            # Update scene
            bpy.context.view_layer.update()
            
        except Exception as e:
            self.logger.error(f"Error rotating camera: {str(e)}")



    # ANIMATIOM - SceneX/src/camera/camera.py
    # Add to existing CameraSystem class:

    def animate_movement(self, start_frame: int, end_frame: int, 
                        target_location: mathutils.Vector, 
                        target_rotation: Optional[Tuple[float, float, float]] = None):
        """Animate camera movement between frames"""
        self.logger.info(f"Animating camera from frame {start_frame} to {end_frame}")
        
        try:
            # Set initial keyframe
            self.camera.location.keyframe_insert(data_path="location", frame=start_frame)
            if target_rotation:
                self.camera.rotation_euler.keyframe_insert(data_path="rotation_euler", frame=start_frame)
            
            # Set target keyframe
            self.camera.location = target_location
            self.camera.keyframe_insert(data_path="location", frame=end_frame)
            
            if target_rotation:
                self.camera.rotation_euler = mathutils.Euler(target_rotation)
                self.camera.keyframe_insert(data_path="rotation_euler", frame=end_frame)
                
            # Set interpolation
            for fc in self.camera.animation_data.action.fcurves:
                for kf in fc.keyframe_points:
                    kf.interpolation = 'BEZIER'
                    kf.easing = 'EASE_IN_OUT'
                    
        except Exception as e:
            self.logger.error(f"Error animating camera: {str(e)}")

    def animate_rotation_around_target(self, start_frame: int, end_frame: int, 
                                    start_angles: Tuple[float, float], 
                                    end_angles: Tuple[float, float]):
        """Animate camera rotating around target point"""
        self.logger.info(f"Animating camera rotation from frame {start_frame} to {end_frame}")
        
        try:
            # Calculate start position
            phi_start, theta_start = start_angles
            x_start = self.config.distance * math.sin(theta_start) * math.cos(phi_start)
            y_start = self.config.distance * math.cos(theta_start) * math.cos(phi_start)
            z_start = self.config.distance * math.sin(phi_start)
            
            # Calculate end position
            phi_end, theta_end = end_angles
            x_end = self.config.distance * math.sin(theta_end) * math.cos(phi_end)
            y_end = self.config.distance * math.cos(theta_end) * math.cos(phi_end)
            z_end = self.config.distance * math.sin(phi_end)
            
            # Set keyframes
            self.camera.location = (x_start, y_start, z_start)
            self.camera.keyframe_insert(data_path="location", frame=start_frame)
            
            self.camera.location = (x_end, y_end, z_end)
            self.camera.keyframe_insert(data_path="location", frame=end_frame)
            
            # Set interpolation
            if self.camera.animation_data and self.camera.animation_data.action:
                for fc in self.camera.animation_data.action.fcurves:
                    for kf in fc.keyframe_points:
                        kf.interpolation = 'BEZIER'
                        kf.easing = 'EASE_IN_OUT'
                        
        except Exception as e:
            self.logger.error(f"Error animating camera rotation: {str(e)}")

==================================================

File: SceneX/src/geometry/shapes.py
Contents:
# SceneX/src/geometry/shapes.py
import bpy
import mathutils
import math
from typing import Optional, List, Tuple, Union

from src.geometry.base import Geometry
from src.utils.logger import SceneXLogger

class Line(Geometry):
    def __init__(self, start: Tuple[float, float, float], 
                 end: Tuple[float, float, float], **kwargs):
        super().__init__(**kwargs)
        self.start = mathutils.Vector(start)
        self.end = mathutils.Vector(end)
        
    def create(self) -> bpy.types.Object:
        """Create a line between two points"""
        # Create curve
        curve_data = bpy.data.curves.new('line', 'CURVE')
        curve_data.dimensions = '3D'
        
        # Create spline
        spline = curve_data.splines.new('POLY')
        spline.points.add(1)
        
        # Set points
        spline.points[0].co = (*self.start, 1)
        spline.points[1].co = (*self.end, 1)
        
        # Create object
        self.object = bpy.data.objects.new('line', curve_data)
        self.object.data.bevel_depth = self.stroke_width
        
        # Add material
        mat = bpy.data.materials.new(name="line_material")
        mat.use_nodes = True
        principled = mat.node_tree.nodes["Principled BSDF"]
        principled.inputs["Base Color"].default_value = self.color
        self.object.data.materials.append(mat)
        
        # Link to scene
        bpy.context.scene.collection.objects.link(self.object)
        return self.object

class Circle(Geometry):
    def __init__(self, radius: float = 1.0, 
                 segments: int = 32,
                 fill: bool = True, **kwargs):
        super().__init__(**kwargs)
        self.radius = radius
        self.segments = segments
        self.fill = fill
        
    def create(self) -> bpy.types.Object:
        """Create a circle"""
        if self.fill:
            bpy.ops.mesh.primitive_circle_add(
                vertices=self.segments,
                radius=self.radius,
                fill_type='TRIFAN'
            )
        else:
            bpy.ops.curve.primitive_bezier_circle_add(radius=self.radius)
            
        self.object = bpy.context.active_object
        
        # Add material
        mat = bpy.data.materials.new(name="circle_material")
        mat.use_nodes = True
        principled = mat.node_tree.nodes["Principled BSDF"]
        principled.inputs["Base Color"].default_value = self.color
        
        if not self.fill:
            self.object.data.bevel_depth = self.stroke_width
            
        self.object.data.materials.append(mat)
        return self.object

class Rectangle(Geometry):
    def __init__(self, width: float = 2.0, 
                 height: float = 1.0,
                 corner_radius: float = 0.0, **kwargs):
        super().__init__(**kwargs)
        self.width = width
        self.height = height
        self.corner_radius = corner_radius
        
    def create(self) -> bpy.types.Object:
        """Create a rectangle"""
        # Create vertices
        verts = []
        if self.corner_radius > 0:
            # Add rounded corners
            steps = 8  # Steps per corner
            for i in range(4):  # 4 corners
                cx = (self.width/2) * (1 if i in (0,3) else -1)
                cy = (self.height/2) * (1 if i < 2 else -1)
                for j in range(steps):
                    angle = math.pi/2 * (i + j/steps)
                    x = cx + self.corner_radius * math.cos(angle)
                    y = cy + self.corner_radius * math.sin(angle)
                    verts.append((x, y, 0))
        else:
            # Simple rectangle
            verts = [
                (self.width/2, self.height/2, 0),
                (-self.width/2, self.height/2, 0),
                (-self.width/2, -self.height/2, 0),
                (self.width/2, -self.height/2, 0)
            ]

        # Create mesh
        mesh = bpy.data.meshes.new("rectangle")
        mesh.from_pydata(verts, [], [list(range(len(verts)))])
        mesh.update()
        
        self.object = bpy.data.objects.new("rectangle", mesh)
        
        # Add material
        mat = bpy.data.materials.new(name="rectangle_material")
        mat.use_nodes = True
        principled = mat.node_tree.nodes["Principled BSDF"]
        principled.inputs["Base Color"].default_value = self.color
        self.object.data.materials.append(mat)
        
        bpy.context.scene.collection.objects.link(self.object)
        return self.object
    
# Square inherits from Rectangle - should we proceed with rate functions for animations?
class Square(Rectangle):
    def __init__(self, size: float = 1.0, **kwargs):
        super().__init__(width=size, height=size, **kwargs)

==================================================

File: SceneX/src/geometry/snapping.py
Contents:
# src/geometry/snapping.py

import bpy
import mathutils
from ..utils.logger import SceneXLogger

class SnapSystem:
    """Handle object snapping and connections"""
    def __init__(self, grid_size: float = 1.0):
        self.grid_size = grid_size
        self.logger = SceneXLogger("SnapSystem")
        self.connection_lines = []
    
    def snap_to_grid(self, obj: bpy.types.Object):
        """Snap object to nearest grid point"""
        try:
            location = obj.location.copy()
            
            # Snap to grid
            location.x = round(location.x / self.grid_size) * self.grid_size
            location.y = round(location.y / self.grid_size) * self.grid_size
            location.z = round(location.z / self.grid_size) * self.grid_size
            
            obj.location = location
            self.logger.info(f"Snapped {obj.name} to grid")
            
        except Exception as e:
            self.logger.error(f"Error snapping to grid: {str(e)}")
    
    def connect_objects(self, obj1: bpy.types.Object, obj2: bpy.types.Object, 
                       type: str = 'LINE', thickness: float = 0.05):
        """Create a visual connection between two objects"""
        try:
            # Get connection points (object centers for now)
            start = obj1.location
            end = obj2.location
            
            # Create curve
            curve_data = bpy.data.curves.new('connection', 'CURVE')
            curve_data.dimensions = '3D'
            
            # Create spline
            spline = curve_data.splines.new('BEZIER')
            spline.bezier_points.add(1)
            
            # Set points
            spline.bezier_points[0].co = start
            spline.bezier_points[1].co = end
            
            # Set handles
            direction = (end - start).normalized()
            handle_length = (end - start).length / 3
            
            spline.bezier_points[0].handle_right = start + direction * handle_length
            spline.bezier_points[0].handle_left = start
            spline.bezier_points[1].handle_left = end - direction * handle_length
            spline.bezier_points[1].handle_right = end
            
            # Create curve object
            curve_obj = bpy.data.objects.new('connection', curve_data)
            curve_obj.data.bevel_depth = thickness
            
            # Link to scene
            bpy.context.scene.collection.objects.link(curve_obj)
            self.connection_lines.append(curve_obj)
            
            self.logger.info(f"Created connection between {obj1.name} and {obj2.name}")
            return curve_obj
            
        except Exception as e:
            self.logger.error(f"Error creating connection: {str(e)}")
            return None
    
    def update_connections(self):
        """Update all connection line positions"""
        for line in self.connection_lines:
            if len(line.data.splines[0].bezier_points) >= 2:
                points = line.data.splines[0].bezier_points
                start_obj = line.get('start_object')
                end_obj = line.get('end_object')
                
                if start_obj and end_obj:
                    points[0].co = start_obj.location
                    points[1].co = end_obj.location
    
    def remove_connections(self):
        """Remove all connection lines"""
        for line in self.connection_lines:
            bpy.data.objects.remove(line, do_unlink=True)
        self.connection_lines.clear()

class SmartConnector:
    """Automatically create and maintain object connections"""
    def __init__(self):
        self.snap_system = SnapSystem()
        self.logger = SceneXLogger("SmartConnector")
        self.connections = {}  # Store object relationships
    
    def connect_with_type(self, obj1: bpy.types.Object, obj2: bpy.types.Object, 
                         connection_type: str = 'DIRECT'):
        """Create a typed connection between objects"""
        try:
            if connection_type == 'DIRECT':
                curve = self.snap_system.connect_objects(obj1, obj2)
            elif connection_type == 'ORTHOGONAL':
                curve = self._create_orthogonal_connection(obj1, obj2)
            elif connection_type == 'ARC':
                curve = self._create_arc_connection(obj1, obj2)
            
            if curve:
                # Store relationship
                curve['start_object'] = obj1
                curve['end_object'] = obj2
                curve['connection_type'] = connection_type
                
                # Add to connections dict
                key = (obj1.name, obj2.name)
                self.connections[key] = curve
            
            return curve
            
        except Exception as e:
            self.logger.error(f"Error creating typed connection: {str(e)}")
            return None
    
    def _create_orthogonal_connection(self, obj1, obj2):
        """Create connection with orthogonal segments"""
        # Implementation for orthogonal path routing
        pass
    
    def _create_arc_connection(self, obj1, obj2):
        """Create curved arc connection"""
        # Implementation for arc connections
        pass
    
    def update_all_connections(self):
        """Update all connection positions"""
        for (start_name, end_name), curve in self.connections.items():
            start_obj = bpy.data.objects.get(start_name)
            end_obj = bpy.data.objects.get(end_name)
            
            if start_obj and end_obj:
                connection_type = curve.get('connection_type', 'DIRECT')
                if connection_type == 'DIRECT':
                    self.snap_system.update_connections()
                elif connection_type == 'ORTHOGONAL':
                    self._update_orthogonal_connection(curve, start_obj, end_obj)
                elif connection_type == 'ARC':
                    self._update_arc_connection(curve, start_obj, end_obj)
    
    def _update_orthogonal_connection(self, curve, start_obj, end_obj):
        """Update orthogonal connection path"""
        # Implementation for updating orthogonal paths
        pass
    
    def _update_arc_connection(self, curve, start_obj, end_obj):
        """Update arc connection curve"""
        # Implementation for updating arc connections
        pass

==================================================

File: SceneX/src/geometry/complex_shapes.py
Contents:
# SceneX/src/geometry/complex_shapes.py
import bpy
import mathutils
import math
from .base import Geometry
from typing import Optional, List, Tuple

class Arrow(Geometry):
    def __init__(self, 
                 start: Tuple[float, float, float],
                 end: Tuple[float, float, float],
                 head_length: float = 0.2,
                 head_width: float = 0.1,
                 **kwargs):
        super().__init__(**kwargs)
        self.start = mathutils.Vector(start)
        self.end = mathutils.Vector(end)
        self.head_length = head_length
        self.head_width = head_width

    def create(self) -> bpy.types.Object:
        direction = (self.end - self.start).normalized()
        length = (self.end - self.start).length
        right = direction.cross(mathutils.Vector((0, 0, 1)))
        
        # Create vertices for arrow head
        tip = self.end
        base = self.end - direction * self.head_length
        left_vert = base + right * self.head_width
        right_vert = base - right * self.head_width
        
        # Create shaft vertices
        shaft_width = self.head_width * 0.3
        shaft_left = self.start + right * shaft_width
        shaft_right = self.start - right * shaft_width
        
        verts = [self.start, shaft_left, shaft_right, left_vert, right_vert, tip]
        faces = [(0, 1, 2), (1, 3, 4, 2), (3, 5, 4)]

        mesh = bpy.data.meshes.new("arrow")
        mesh.from_pydata(verts, [], faces)
        mesh.update()

        self.object = bpy.data.objects.new("arrow", mesh)
        self._setup_material()
        bpy.context.scene.collection.objects.link(self.object)
        return self.object

class Arc(Geometry):
    def __init__(self, 
                 radius: float = 1.0,
                 start_angle: float = 0,
                 end_angle: float = math.pi/2,
                 segments: int = 32,
                 **kwargs):
        super().__init__(**kwargs)
        self.radius = radius
        self.start_angle = start_angle
        self.end_angle = end_angle
        self.segments = segments

    def create(self) -> bpy.types.Object:
        curve = bpy.data.curves.new('arc', 'CURVE')
        curve.dimensions = '3D'
        
        spline = curve.splines.new('BEZIER')
        angle_range = self.end_angle - self.start_angle
        points_count = int(self.segments * (angle_range / (2 * math.pi)))
        spline.bezier_points.add(points_count - 1)
        
        for i in range(points_count):
            angle = self.start_angle + (angle_range * i / (points_count - 1))
            x = math.cos(angle) * self.radius
            y = math.sin(angle) * self.radius
            point = spline.bezier_points[i]
            point.co = (x, y, 0)
            point.handle_left_type = 'AUTO'
            point.handle_right_type = 'AUTO'
        
        self.object = bpy.data.objects.new('arc', curve)
        self.object.data.bevel_depth = self.stroke_width
        self._setup_material()
        bpy.context.scene.collection.objects.link(self.object)
        return self.object

class Star(Geometry):
    def __init__(self,
                 points: int = 5,
                 outer_radius: float = 1.0,
                 inner_radius: float = 0.5,
                 **kwargs):
        super().__init__(**kwargs)
        self.points = points
        self.outer_radius = outer_radius
        self.inner_radius = inner_radius

    def create(self) -> bpy.types.Object:
        verts = []
        point_angle = math.pi / self.points
        
        for i in range(self.points * 2):
            radius = self.outer_radius if i % 2 == 0 else self.inner_radius
            angle = i * point_angle
            x = math.cos(angle) * radius
            y = math.sin(angle) * radius
            verts.append((x, y, 0))

        faces = [list(range(len(verts)))]
        mesh = bpy.data.meshes.new("star")
        mesh.from_pydata(verts, [], faces)
        mesh.update()

        self.object = bpy.data.objects.new("star", mesh)
        self._setup_material()
        bpy.context.scene.collection.objects.link(self.object)
        return self.object


==================================================

File: SceneX/src/geometry/alignment.py
Contents:
# SceneX/src/geometry/alignment.py

import bpy
from enum import Enum
from typing import List, Tuple
from mathutils import Vector
from ..utils.logger import SceneXLogger

class AlignmentType(Enum):
    LEFT = 'LEFT'
    RIGHT = 'RIGHT'
    TOP = 'TOP'
    BOTTOM = 'BOTTOM'
    CENTER = 'CENTER'
    DISTRIBUTE_H = 'DISTRIBUTE_H'
    DISTRIBUTE_V = 'DISTRIBUTE_V'

class AlignmentHandler:
    def __init__(self):
        self.logger = SceneXLogger("AlignmentHandler")

    def align_objects(self, objects: List[bpy.types.Object], align_type: AlignmentType):
        if not objects:
            return

        bounds = self._get_group_bounds(objects)
        
        for obj in objects:
            if align_type == AlignmentType.LEFT:
                obj.location.x = bounds.min.x
            elif align_type == AlignmentType.RIGHT:
                obj.location.x = bounds.max.x
            elif align_type == AlignmentType.TOP:
                obj.location.y = bounds.max.y
            elif align_type == AlignmentType.BOTTOM:
                obj.location.y = bounds.min.y
            elif align_type == AlignmentType.CENTER:
                center = (bounds.min + bounds.max) / 2
                obj.location.x = center.x
                obj.location.y = center.y

    def distribute_objects(self, objects: List[bpy.types.Object], 
                         spacing: float = 1.0, 
                         direction: AlignmentType = AlignmentType.DISTRIBUTE_H):
        if not objects:
            return

        sorted_objects = sorted(objects, 
            key=lambda obj: obj.location.x if direction == AlignmentType.DISTRIBUTE_H 
            else obj.location.y)

        bounds = self._get_group_bounds(objects)
        total_distance = (bounds.max - bounds.min).length
        interval = total_distance / (len(objects) - 1) if len(objects) > 1 else 0

        for i, obj in enumerate(sorted_objects):
            if direction == AlignmentType.DISTRIBUTE_H:
                obj.location.x = bounds.min.x + (i * interval)
            else:
                obj.location.y = bounds.min.y + (i * interval)

    def grid_arrange(self, objects: List[bpy.types.Object], 
                    rows: int, cols: int, 
                    spacing: Tuple[float, float] = (1.0, 1.0)):
        if not objects:
            return

        x_spacing, y_spacing = spacing
        for i, obj in enumerate(objects):
            row = i // cols
            col = i % cols
            obj.location.x = col * x_spacing
            obj.location.y = -row * y_spacing

    def _get_group_bounds(self, objects: List[bpy.types.Object]):
        """Calculate bounding box for group of objects"""
        vertices = []
        for obj in objects:
            for v in obj.bound_box:
                world_v = obj.matrix_world @ Vector((v[0], v[1], v[2]))
                vertices.append(world_v)

        min_v = Vector((min(v.x for v in vertices),
                       min(v.y for v in vertices),
                       min(v.z for v in vertices)))
        max_v = Vector((max(v.x for v in vertices),
                       max(v.y for v in vertices),
                       max(v.z for v in vertices)))

        return type('Bounds', (), {'min': min_v, 'max': max_v})()

    def snap_to_grid(self, obj: bpy.types.Object, grid_size: float = 1.0):
        """Snap object to nearest grid point"""
        obj.location.x = round(obj.location.x / grid_size) * grid_size
        obj.location.y = round(obj.location.y / grid_size) * grid_size
        obj.location.z = round(obj.location.z / grid_size) * grid_size

    def align_to_axis(self, objects: List[bpy.types.Object], axis: str = 'X'):
        """Align objects along specified axis"""
        if not objects:
            return
            
        avg = sum((obj.location[axis.lower()] for obj in objects)) / len(objects)
        for obj in objects:
            setattr(obj.location, axis.lower(), avg)

==================================================

File: SceneX/src/geometry/base.py
Contents:
# # SceneX/src/geometry/base.py
# import bpy
# import mathutils
# from typing import Optional, List, Tuple, Union
# from ..utils.logger import SceneXLogger

# class Geometry:
#     """Base class for all geometric objects"""
#     def __init__(self, color: Tuple[float, float, float, float] = (1, 1, 1, 1),
#                  stroke_width: float = 0.05,
#                  fill_opacity: float = 1.0):
#         self.logger = SceneXLogger("Geometry")
#         self.color = color
#         self.stroke_width = stroke_width
#         self.fill_opacity = fill_opacity
#         self.object = None  # Blender object reference
        
#     def create(self) -> bpy.types.Object:
#         """Create the geometric object - to be implemented by subclasses"""
#         raise NotImplementedError

#     def set_color(self, color: Tuple[float, float, float, float]):
#         """Set object color"""
#         if not self.object or not self.object.active_material:
#             return
            
#         material = self.object.active_material
#         if material.use_nodes:
#             principled = material.node_tree.nodes.get('Principled BSDF')
#             if principled:
#                 principled.inputs['Base Color'].default_value = color
#                 principled.inputs['Alpha'].default_value = color[3]

#     def set_stroke_width(self, width: float):
#         """Set stroke width for curves"""
#         if self.object and self.object.type == 'CURVE':
#             self.object.data.bevel_depth = width

#     def align_to_grid(self, position: mathutils.Vector):
#         """Align object to grid"""
#         if self.object:
#             self.object.location = position




import bpy
import mathutils
from typing import Optional, List, Tuple, Union
from ..utils.logger import SceneXLogger

class Geometry:
    """Base class for all geometric objects"""
    def __init__(self, color: Tuple[float, float, float, float] = (1, 1, 1, 1),
                 stroke_width: float = 0.05,
                 fill_opacity: float = 1.0):
        self.logger = SceneXLogger("Geometry")
        self.color = color
        self.stroke_width = stroke_width
        self.fill_opacity = fill_opacity
        self.object = None  # Blender object reference
        
    def create(self) -> bpy.types.Object:
        """Create the geometric object - to be implemented by subclasses"""
        raise NotImplementedError

    def _setup_material(self):
        """Create and setup material for the object"""
        if not self.object:
            return
            
        mat = bpy.data.materials.new(name=f"geometry_material_{id(self)}")
        mat.use_nodes = True
        
        # Setup nodes
        nodes = mat.node_tree.nodes
        principled = nodes.get("Principled BSDF")
        if not principled:
            principled = nodes.new('ShaderNodeBsdfPrincipled')
            
        principled.inputs['Base Color'].default_value = self.color
        principled.inputs['Alpha'].default_value = self.fill_opacity
        
        if self.fill_opacity < 1.0:
            mat.blend_method = 'BLEND'
            
        # Assign material
        if self.object.data.materials:
            self.object.data.materials[0] = mat
        else:
            self.object.data.materials.append(mat)

    def set_color(self, color: Tuple[float, float, float, float]):
        """Set object color"""
        if not self.object or not self.object.active_material:
            return
            
        material = self.object.active_material
        if material.use_nodes:
            principled = material.node_tree.nodes.get('Principled BSDF')
            if principled:
                principled.inputs['Base Color'].default_value = color
                principled.inputs['Alpha'].default_value = color[3]

    def set_stroke_width(self, width: float):
        """Set stroke width for curves"""
        if self.object and self.object.type == 'CURVE':
            self.object.data.bevel_depth = width

    def align_to_grid(self, position: mathutils.Vector):
        """Align object to grid"""
        if self.object:
            self.object.location = position

==================================================

File: SceneX/src/geometry/svg_handler.py
Contents:
# SceneX/src/geometry/svg_handler.py

import bpy
import xml.etree.ElementTree as ET
import math
from pathlib import Path
from mathutils import Vector, Matrix
from ..utils.logger import SceneXLogger

class SVGHandler:
    def __init__(self):
        self.logger = SceneXLogger("SVGHandler")
        self.scale = 1.0
        self.commands = {
            'M': self._move_to,
            'L': self._line_to,
            'H': self._horizontal_line_to,
            'V': self._vertical_line_to,
            'C': self._cubic_bezier,
            'S': self._smooth_cubic_bezier,
            'Q': self._quadratic_bezier,
            'T': self._smooth_quadratic_bezier,
            'A': self._arc,
            'Z': self._close_path
        }

    def import_svg(self, filepath: str) -> bpy.types.Object:
        """Import SVG file and convert to Blender curves"""
        try:
            tree = ET.parse(filepath)
            root = tree.getroot()
            
            # Create empty collection for SVG parts
            collection = bpy.data.collections.new("SVG_Parts")
            bpy.context.scene.collection.children.link(collection)
            
            # Process SVG elements
            self._process_element(root, collection)
            
            return collection
            
        except Exception as e:
            self.logger.error(f"Error importing SVG: {str(e)}")
            return None

    def _process_element(self, element: ET.Element, collection: bpy.types.Collection):
        """Process SVG element and its children"""
        if element.tag.endswith('path'):
            path_data = element.get('d')
            if path_data:
                curve = self._create_curve_from_path(path_data)
                if curve:
                    collection.objects.link(curve)
                    
        for child in element:
            self._process_element(child, collection)

    def _create_curve_from_path(self, path_data: str) -> bpy.types.Object:
        """Convert SVG path data to Blender curve"""
        try:
            curve_data = bpy.data.curves.new('path', 'CURVE')
            curve_data.dimensions = '3D'
            
            spline = curve_data.splines.new('BEZIER')
            commands = self._parse_path_data(path_data)
            
            current_point = Vector((0, 0, 0))
            for cmd, params in commands:
                if cmd in self.commands:
                    current_point = self.commands[cmd](spline, current_point, params)
            
            curve_obj = bpy.data.objects.new('path', curve_data)
            return curve_obj
            
        except Exception as e:
            self.logger.error(f"Error creating curve: {str(e)}")
            return None

    def _parse_path_data(self, path_data: str) -> list:
        """Parse SVG path data into command list"""
        commands = []
        current_cmd = None
        current_params = []
        
        # Split path data into tokens
        tokens = path_data.replace(',', ' ').split()
        
        for token in tokens:
            if token[0].isalpha():
                if current_cmd:
                    commands.append((current_cmd, current_params))
                current_cmd = token
                current_params = []
            else:
                current_params.append(float(token))
                
        if current_cmd:
            commands.append((current_cmd, current_params))
            
        return commands

    # Path command implementations
    def _move_to(self, spline, current, params):
        point = Vector((params[0], params[1], 0)) * self.scale
        return point

    def _line_to(self, spline, current, params):
        point = Vector((params[0], params[1], 0)) * self.scale
        self._add_line_point(spline, current, point)
        return point

    def _horizontal_line_to(self, spline, current, params):
        point = Vector((params[0], current.y, 0)) * self.scale
        self._add_line_point(spline, current, point)
        return point

    def _vertical_line_to(self, spline, current, params):
        point = Vector((current.x, params[0], 0)) * self.scale
        self._add_line_point(spline, current, point)
        return point

    def _cubic_bezier(self, spline, current, params):
        c1 = Vector((params[0], params[1], 0)) * self.scale
        c2 = Vector((params[2], params[3], 0)) * self.scale
        end = Vector((params[4], params[5], 0)) * self.scale
        self._add_bezier_point(spline, current, c1, c2, end)
        return end

    def _add_line_point(self, spline, start, end):
        """Add line segment to spline"""
        spline.bezier_points.add(1)
        point = spline.bezier_points[-1]
        point.co = end
        point.handle_left = start
        point.handle_right = end

    def _add_bezier_point(self, spline, start, c1, c2, end):
        """Add bezier curve segment to spline"""
        spline.bezier_points.add(1)
        point = spline.bezier_points[-1]
        point.co = end
        point.handle_left = c1
        point.handle_right = c2

    def _close_path(self, spline, current, params):
        """Close the current path"""
        if len(spline.bezier_points) > 0:
            spline.use_cyclic_u = True
        return current

==================================================

File: SceneX/src/hdr/metal_hdr_photos/metal_background_197638.jpg
Contents:
[Binary File Content - metal_background_197638.jpg]


==================================================

File: SceneX/src/templates/technical.py
Contents:
# SceneX/src/templates/technical.py

import bpy
import math
from mathutils import Vector
from ..core.scene import Scene
from ..geometry.shapes import Circle, Square, Arrow
from ..text.text_support import Text
from ..animation.commonly_used_animations import FadeInFrom, Write
from ..animation.base import AnimationConfig
from ..scene.layout import Layout, LayoutType

class TechnicalDiagramScene(Scene):
    """Base class for technical diagram animations"""
    def __init__(self, title: str = "Technical Diagram"):
        super().__init__()
        self.title = title
        self.components = []
        self.connections = []
        self.labels = []

    def add_component(self, shape_type: str, position: Vector, label: str = ""):
        """Add a component to the diagram"""
        if shape_type == "circle":
            shape = Circle(radius=0.5).create()
        elif shape_type == "square":
            shape = Square(size=1.0).create()
        
        self.coordinate_system.place_object(shape, position)
        
        if label:
            text = Text(label, size=0.3).create()
            self.coordinate_system.place_object(text, position + Vector((0, -0.7, 0)))
            self.labels.append(text)
            
        self.components.append(shape)
        return shape

    def connect_components(self, start_obj, end_obj, arrow: bool = True):
        """Create connection between components"""
        start_pos = start_obj.location
        end_pos = end_obj.location
        
        if arrow:
            connection = Arrow(start=start_pos, end=end_pos).create()
        else:
            # Create line
            pass
            
        self.connections.append(connection)
        return connection

    def animate_diagram(self):
        """Animate the diagram components"""
        config = AnimationConfig(duration=30)
        
        # Fade in components
        for component in self.components:
            self.play(FadeInFrom(component, Vector((0, -1, 0)), config=config))
            
        # Write labels
        for label in self.labels:
            self.play(Write(label, config=config))
            
        # Show connections
        for connection in self.connections:
            self.play(FadeInFrom(connection, Vector((0, 0, -1)), config=config))


==================================================

File: SceneX/src/templates/physics.py
Contents:
# SceneX/src/templates/physics.py

import bpy
import math
from mathutils import Vector
from ..core.scene import Scene
from ..geometry.shapes import Circle, Square, Rectangle
from ..text.text_support import Text
from ..animation.base import AnimationConfig
from typing import List, Dict, Optional, Tuple

class PhysicsSimulationScene(Scene):
    """Base class for physics simulations"""
    def __init__(self):
        super().__init__()
        self.simulation_objects = []
        self.gravity = (0, 0, -9.81)
        self.frame_rate = 60
        self.simulation_duration = 250  # frames

    def setup_physics(self):
        """Configure physics settings"""
        scene = bpy.context.scene
        scene.use_gravity = True
        scene.gravity = self.gravity
        scene.frame_start = 1
        scene.frame_end = self.simulation_duration
        scene.render.fps = self.frame_rate

    def add_rigid_body(self, obj: bpy.types.Object, 
                      mass: float = 1.0,
                      friction: float = 0.5,
                      bounce: float = 0.5,
                      linear_damping: float = 0.05,
                      angular_damping: float = 0.05) -> bpy.types.Object:
        """Add rigid body physics to object"""
        bpy.context.view_layer.objects.active = obj
        bpy.ops.rigidbody.object_add()
        rb = obj.rigid_body
        
        rb.mass = mass
        rb.friction = friction
        rb.restitution = bounce
        rb.linear_damping = linear_damping
        rb.angular_damping = angular_damping
        
        self.simulation_objects.append(obj)
        return obj

    def add_collision_plane(self, location: Vector = Vector((0, 0, 0)), 
                          size: float = 10.0) -> bpy.types.Object:
        """Add collision plane"""
        bpy.ops.mesh.primitive_plane_add(size=size, location=location)
        plane = bpy.context.active_object
        
        bpy.ops.rigidbody.object_add()
        plane.rigid_body.type = 'PASSIVE'
        plane.rigid_body.friction = 0.5
        plane.rigid_body.restitution = 0.5
        
        return plane

    def add_constraint(self, obj1: bpy.types.Object, 
                      obj2: bpy.types.Object,
                      constraint_type: str = 'FIXED',
                      pivot: Optional[Vector] = None) -> None:
        """Add constraint between objects"""
        bpy.ops.rigidbody.constraint_add()
        constraint = bpy.context.object
        constraint.empty_display_size = 0.1
        
        con = constraint.rigid_body_constraint
        con.type = constraint_type
        con.object1 = obj1
        con.object2 = obj2
        
        if pivot:
            constraint.location = pivot

class PendulumScene(PhysicsSimulationScene):
    """Template for pendulum simulation"""
    def __init__(self, length: float = 5.0):
        super().__init__()
        self.length = length

    def setup_pendulum(self):
        # Create anchor point
        anchor = self.add_rigid_body(
            Square(size=0.5).create(),
            mass=0.0  # Make it static
        )
        anchor.location = Vector((0, 0, self.length))
        
        # Create pendulum bob
        bob = self.add_rigid_body(
            Circle(radius=0.3).create(),
            mass=1.0,
            angular_damping=0.3
        )
        bob.location = Vector((self.length, 0, 0))
        
        # Add constraint
        self.add_constraint(anchor, bob, 'POINT', anchor.location)

class CollisionScene(PhysicsSimulationScene):
    """Template for collision simulations"""
    def setup_collision(self, num_objects: int = 5):
        # Add ground plane
        self.add_collision_plane()
        
        # Add objects with different properties
        for i in range(num_objects):
            obj = self.add_rigid_body(
                Circle(radius=0.3).create(),
                mass=1.0,
                bounce=0.8
            )
            obj.location = Vector((i - num_objects/2, 0, 5))

class SpringScene(PhysicsSimulationScene):
    """Template for spring simulations"""
    def setup_spring(self, spring_constant: float = 10.0):
        # Create fixed point
        anchor = self.add_rigid_body(
            Square(size=0.3).create(),
            mass=0.0
        )
        
        # Create mass
        mass = self.add_rigid_body(
            Circle(radius=0.2).create(),
            mass=1.0,
            linear_damping=0.1
        )
        mass.location = Vector((0, 0, -2))
        
        # Add spring constraint
        constraint = self.add_constraint(
            anchor, mass, 'GENERIC_SPRING'
        )
        if constraint.rigid_body_constraint:
            constraint.rigid_body_constraint.spring_stiffness_y = spring_constant

==================================================

File: SceneX/src/templates/mathematical.py
Contents:
# SceneX/src/templates/mathematical.py

class MathematicalScene(Scene):
    """Base class for mathematical animations"""
    def __init__(self):
        super().__init__()
        self.equations = []
        self.graphs = []

    def add_equation(self, tex: str, position: Vector):
        """Add LaTeX equation"""
        equation = LaTeXText(tex, size=0.8).create()
        self.coordinate_system.place_object(equation, position)
        self.equations.append(equation)
        return equation

    def add_graph(self, func, x_range=(-5, 5), position: Vector = Vector((0, 0, 0))):
        """Add mathematical graph"""
        pass  # Implement graphing functionality

    def animate_derivation(self):
        """Animate mathematical derivation"""
        config = AnimationConfig(duration=30)
        
        for equation in self.equations:
            self.play(Write(equation, config=config))

==================================================

File: SceneX/src/templates/educational.py
Contents:
# SceneX/src/templates/educational.py

class PresentationScene(Scene):
    """Base class for educational presentations"""
    def __init__(self, title: str = "Presentation"):
        super().__init__()
        self.slides = []
        self.current_slide = 0

    def add_slide(self, title: str, content: list):
        """Add slide with title and content"""
        slide_group = Group(f"slide_{len(self.slides)}")
        
        # Create title
        title_text = Text(title, size=1.0).create()
        self.coordinate_system.place_object(title_text, Vector((0, 3, 0)))
        slide_group.add(title_text)
        
        # Add content
        layout = Layout()
        y_pos = 2
        for item in content:
            if isinstance(item, str):
                text = Text(item, size=0.6).create()
                self.coordinate_system.place_object(text, Vector((0, y_pos, 0)))
                slide_group.add(text)
            else:
                slide_group.add(item)
            y_pos -= 1
            
        self.slides.append(slide_group)
        return slide_group

    def next_slide(self):
        """Animate transition to next slide"""
        if self.current_slide < len(self.slides) - 1:
            # Fade out current slide
            current = self.slides[self.current_slide]
            config = AnimationConfig(duration=20)
            self.play(FadeOut(current.get_all_objects(), config=config))
            
            # Fade in next slide
            self.current_slide += 1
            next_slide = self.slides[self.current_slide]
            self.play(FadeInFrom(next_slide.get_all_objects(), Vector((1, 0, 0)), config=config))

==================================================

File: SceneX/src/text/text_support copy 2.py
Contents:
import bpy
import os
import tempfile
import subprocess
from pathlib import Path
from ..geometry.base import Geometry
from ..utils.logger import SceneXLogger

# Correct import for matplotlib
import matplotlib.pyplot as plt

class Text(Geometry):
    def __init__(self, text: str, size: float = 1.0, 
                 font_path: str = None, alignment: str = 'CENTER', **kwargs):
        super().__init__(**kwargs)
        self.text = text
        self.size = size
        self.font_path = font_path
        self.alignment = alignment
        self.logger = SceneXLogger("Text")

    def create(self) -> bpy.types.Object:
        bpy.ops.object.text_add(enter_editmode=False)
        self.object = bpy.context.active_object
        self.object.data.body = self.text
        
        # Apply font if specified
        if self.font_path and os.path.exists(self.font_path):
            font = bpy.data.fonts.load(self.font_path)
            self.object.data.font = font
            
        # Set text properties
        self.object.data.size = self.size
        self.object.data.align_x = self.alignment
        
        # Set up material
        self._setup_material()
        
        return self.object

class LaTeXText(Geometry):
    """Convert LaTeX expressions to geometry using pdflatex and svg conversion"""
    
    def __init__(self, tex: str, size: float = 1.0, **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size
        self.logger = SceneXLogger("LaTeX")

    def create(self) -> bpy.types.Object:
        try:
            # Create figure with transparent background
            fig = plt.figure(figsize=(5, 1), dpi=300)
            fig.patch.set_alpha(0.0)
            
            # Add text using matplotlib's LaTeX renderer
            plt.text(0.5, 0.5, f"${self.tex}$", 
                    horizontalalignment='center',
                    verticalalignment='center',
                    transform=fig.transFigure,
                    color=self.color[:3])
            
            plt.axis('off')
            
            # Save to temporary PNG with transparency
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                plt.savefig(tmp.name, 
                            transparent=True,
                            bbox_inches='tight',
                            pad_inches=0.1,
                            dpi=300)
                plt.close()

                # Load image into Blender
                img = bpy.data.images.load(tmp.name)

                # Create plane for the texture
                bpy.ops.mesh.primitive_plane_add(size=self.size)
                self.object = bpy.context.active_object  # Set to newly created plane
                bpy.context.view_layer.objects.active = self.object  # Ensure correct active object

                # Create and assign material
                mat = bpy.data.materials.new(name="latex_material")
                mat.use_nodes = True
                mat.blend_method = 'BLEND'

                # Setup nodes for transparency
                nodes = mat.node_tree.nodes
                links = mat.node_tree.links
                nodes.clear()

                tex_image = nodes.new('ShaderNodeTexImage')
                tex_image.image = img

                principled = nodes.new('ShaderNodeBsdfPrincipled')
                output = nodes.new('ShaderNodeOutputMaterial')

                links.new(tex_image.outputs['Color'], principled.inputs['Base Color'])
                links.new(tex_image.outputs['Alpha'], principled.inputs['Alpha'])
                links.new(principled.outputs['BSDF'], output.inputs['Surface'])

                self.object.data.materials.append(mat)  # Assign material to plane
                
                return self.object
        
        except Exception as e:
            self.logger.error(f"Error creating LaTeX: {str(e)}")
            return None

    def _create_tex_document(self) -> str:
        """Generate a LaTeX document string for rendering"""
        return f"""\\documentclass[preview]{{standalone}}
\\usepackage{{amsmath}}
\\begin{{document}}
${self.tex}$
\\end{{document}}"""


==================================================

File: SceneX/src/text/text_support.py
Contents:
import bpy
import matplotlib
matplotlib.use('Agg')  # Use non-GUI backend for headless rendering
import matplotlib.pyplot as plt
import numpy as np
import tempfile
from PIL import Image
from pathlib import Path
from src.geometry.base import Geometry
from src.utils.logger import SceneXLogger


class LaTeXText(Geometry):
    def __init__(self, tex: str, size: float = 1.0, color=(1, 1, 1, 1), **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size
        self.color = color
        self.logger = SceneXLogger("LaTeX")


    # # In LaTeXText class, update the create method:
    # def create(self) -> bpy.types.Object:
    #     try:
    #         with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    #             # Increase figure size and DPI for better visibility
    #             fig, ax = plt.subplots(figsize=(10, 2), dpi=600)
    #             ax.axis('off')
    #             fig.patch.set_alpha(0.0)

    #             ax.text(0.5, 0.5, f"${self.tex}$",
    #                     horizontalalignment='center',
    #                     verticalalignment='center',
    #                     fontsize=40,  # Larger font size
    #                     color=self.color[:3],
    #                     transform=ax.transAxes)

    def create(self) -> bpy.types.Object:
        try:
            with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
                # Create LaTeX-rendered image with matplotlib
                fig, ax = plt.subplots(figsize=(5, 1), dpi=300)
                ax.axis('off')
                fig.patch.set_alpha(0.0)  # Transparent background

                ax.text(0.5, 0.5, f"${self.tex}$",
                        horizontalalignment='center',
                        verticalalignment='center',
                        fontsize=30,
                        color=self.color[:3],  # RGB for matplotlib
                        transform=ax.transAxes)

   
                
                plt.tight_layout(pad=0)
                plt.savefig(tmp.name, transparent=True, bbox_inches='tight', pad_inches=0.1)
                plt.close(fig)

                # Load image into Blender
                img = bpy.data.images.load(tmp.name)

                # Create plane for texture
                bpy.ops.mesh.primitive_plane_add(size=self.size)
                self.object = bpy.context.active_object

                # Create and assign material
                mat = bpy.data.materials.new(name="latex_material")
                mat.use_nodes = True
                mat.blend_method = 'BLEND'

                nodes = mat.node_tree.nodes
                links = mat.node_tree.links
                nodes.clear()

                tex_image = nodes.new('ShaderNodeTexImage')
                tex_image.image = img

                principled = nodes.new('ShaderNodeBsdfPrincipled')
                output = nodes.new('ShaderNodeOutputMaterial')

                links.new(tex_image.outputs['Color'], principled.inputs['Base Color'])
                links.new(tex_image.outputs['Alpha'], principled.inputs['Alpha'])
                links.new(principled.outputs['BSDF'], output.inputs['Surface'])

                self.object.data.materials.append(mat)

                return self.object

        except Exception as e:
            self.logger.error(f"Error creating LaTeX: {str(e)}")
            return None


==================================================

File: SceneX/src/text/text_support_gpt_working 3.py
Contents:
import bpy
import matplotlib
matplotlib.use('Agg')  # Use non-GUI backend for headless rendering
import matplotlib.pyplot as plt
import numpy as np
import tempfile
from PIL import Image
from pathlib import Path
from src.geometry.base import Geometry
from src.utils.logger import SceneXLogger


class LaTeXText(Geometry):
    def __init__(self, tex: str, size: float = 1.0, color=(1, 1, 1, 1), **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size
        self.color = color
        self.logger = SceneXLogger("LaTeX")

    def create(self) -> bpy.types.Object:
        try:
            with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
                # Create LaTeX-rendered image with matplotlib
                fig, ax = plt.subplots(figsize=(5, 1), dpi=300)
                ax.axis('off')
                fig.patch.set_alpha(0.0)  # Transparent background

                ax.text(0.5, 0.5, f"${self.tex}$",
                        horizontalalignment='center',
                        verticalalignment='center',
                        fontsize=30,
                        color=self.color[:3],  # RGB for matplotlib
                        transform=ax.transAxes)

                plt.tight_layout(pad=0)
                plt.savefig(tmp.name, transparent=True, bbox_inches='tight', pad_inches=0.1)
                plt.close(fig)

                # Load image into Blender
                img = bpy.data.images.load(tmp.name)

                # Create plane for texture
                bpy.ops.mesh.primitive_plane_add(size=self.size)
                self.object = bpy.context.active_object

                # Create and assign material
                mat = bpy.data.materials.new(name="latex_material")
                mat.use_nodes = True
                mat.blend_method = 'BLEND'

                nodes = mat.node_tree.nodes
                links = mat.node_tree.links
                nodes.clear()

                tex_image = nodes.new('ShaderNodeTexImage')
                tex_image.image = img

                principled = nodes.new('ShaderNodeBsdfPrincipled')
                output = nodes.new('ShaderNodeOutputMaterial')

                links.new(tex_image.outputs['Color'], principled.inputs['Base Color'])
                links.new(tex_image.outputs['Alpha'], principled.inputs['Alpha'])
                links.new(principled.outputs['BSDF'], output.inputs['Surface'])

                self.object.data.materials.append(mat)

                return self.object

        except Exception as e:
            self.logger.error(f"Error creating LaTeX: {str(e)}")
            return None


==================================================

File: SceneX/src/text/text_support copy.py
Contents:
# SceneX/src/text/text_support.py

import bpy
import os
import tempfile
import subprocess
from pathlib import Path
from ..geometry.base import Geometry
from ..utils.logger import SceneXLogger

# import matplotlib

class Text(Geometry):
    def __init__(self, text: str, size: float = 1.0, 
                 font_path: str = None, alignment: str = 'CENTER', **kwargs):
        super().__init__(**kwargs)
        self.text = text
        self.size = size
        self.font_path = font_path
        self.alignment = alignment
        self.logger = SceneXLogger("Text")

    def create(self) -> bpy.types.Object:
        bpy.ops.object.text_add(enter_editmode=False)
        self.object = bpy.context.active_object
        self.object.data.body = self.text
        
        # Apply font if specified
        if self.font_path and os.path.exists(self.font_path):
            font = bpy.data.fonts.load(self.font_path)
            self.object.data.font = font
            
        # Set text properties
        self.object.data.size = self.size
        self.object.data.align_x = self.alignment
        
        # Set up material
        self._setup_material()
        
        return self.object

class LaTeXText(Geometry):
    """Convert LaTeX expressions to geometry using pdflatex and svg conversion"""
    
    def __init__(self, tex: str, size: float = 1.0, **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size
        self.logger = SceneXLogger("LaTeX")

    def create(self) -> bpy.types.Object:
        try:
            # Create temporary directory
            with tempfile.TemporaryDirectory() as tmp_dir:
                # Generate LaTeX document
                tex_path = Path(tmp_dir) / "equation.tex"
                with open(tex_path, "w") as f:
                    f.write(self._create_tex_document())
                
                # Convert to PDF
                subprocess.run(["pdflatex", "-interaction=nonstopmode", 
                             str(tex_path)], cwd=tmp_dir, capture_output=True)
                
                # Convert PDF to SVG
                pdf_path = Path(tmp_dir) / "equation.pdf"
                svg_path = Path(tmp_dir) / "equation.svg"
                subprocess.run(["pdftocairo", "-svg", str(pdf_path), str(svg_path)], 
                             capture_output=True)
                
                # Import SVG
                bpy.ops.import_curve.svg(filepath=str(svg_path))
                self.object = bpy.context.selected_objects[-1]
                self.object.scale = (self.size, self.size, self.size)
                
                # Set up material
                self._setup_material()
                
                return self.object
                
        except Exception as e:
            self.logger.error(f"Error creating LaTeX: {str(e)}")
            return None
            
    def _create_tex_document(self) -> str:
        return f"""\\documentclass[preview]{{standalone}}
\\usepackage{{amsmath}}
\\begin{{document}}
${self.tex}$
\\end{{document}}"""

==================================================

File: SceneX/src/scene/groups.py
Contents:
# SceneX/src/scene/groups.py

import bpy
from typing import List, Optional
from mathutils import Vector, Matrix
from ..utils.logger import SceneXLogger

class Group:
    def __init__(self, name: str):
        self.name = name
        self.objects: List[bpy.types.Object] = []
        self.subgroups: List['Group'] = []
        self.parent: Optional['Group'] = None
        self.empty_center: Optional[bpy.types.Object] = None
        self.logger = SceneXLogger("Group")

    def add(self, *objects_or_groups) -> 'Group':
        for item in objects_or_groups:
            if isinstance(item, bpy.types.Object):
                self.objects.append(item)
            elif isinstance(item, Group):
                self.subgroups.append(item)
                item.parent = self
        self._update_center()
        return self

    def remove(self, *objects_or_groups) -> 'Group':
        for item in objects_or_groups:
            if isinstance(item, bpy.types.Object) and item in self.objects:
                self.objects.remove(item)
            elif isinstance(item, Group) and item in self.subgroups:
                self.subgroups.remove(item)
                item.parent = None
        self._update_center()
        return self

    def _update_center(self):
        if not self.empty_center:
            self.empty_center = bpy.data.objects.new("empty", None)
            bpy.context.scene.collection.objects.link(self.empty_center)
        
        all_objects = self.get_all_objects()
        if all_objects:
            center = Vector((0, 0, 0))
            for obj in all_objects:
                center += obj.location
            center /= len(all_objects)
            self.empty_center.location = center

    def get_all_objects(self) -> List[bpy.types.Object]:
        all_objects = self.objects.copy()
        for subgroup in self.subgroups:
            all_objects.extend(subgroup.get_all_objects())
        return all_objects

    def apply_transform(self, matrix: Matrix):
        if self.empty_center:
            current_matrix = self.empty_center.matrix_world.copy()
            for obj in self.get_all_objects():
                obj.matrix_world = matrix @ current_matrix.inverted() @ obj.matrix_world

    def get_bounds(self) -> tuple:
        all_objects = self.get_all_objects()
        if not all_objects:
            return None
            
        min_x = min_y = min_z = float('inf')
        max_x = max_y = max_z = float('-inf')
        
        for obj in all_objects:
            bounds = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
            min_x = min(min_x, *(b.x for b in bounds))
            min_y = min(min_y, *(b.y for b in bounds))
            min_z = min(min_z, *(b.z for b in bounds))
            max_x = max(max_x, *(b.x for b in bounds))
            max_y = max(max_y, *(b.y for b in bounds))
            max_z = max(max_z, *(b.z for b in bounds))
            
        return ((min_x, min_y, min_z), (max_x, max_y, max_z))

    def get_center(self) -> Vector:
        bounds = self.get_bounds()
        if bounds:
            min_point, max_point = bounds
            return Vector((
                (min_point[0] + max_point[0]) / 2,
                (min_point[1] + max_point[1]) / 2,
                (min_point[2] + max_point[2]) / 2
            ))
        return Vector((0, 0, 0))

==================================================

File: SceneX/src/scene/grid.py
Contents:
# SceneX/src/scene/grid.py

import bpy
import math
from mathutils import Vector
from ..utils.logger import SceneXLogger

class GridSystem:
    def __init__(self):
        self.axes = {}
        self.grid_lines = []
        self.labels = []
        self.logger = SceneXLogger("GridSystem")

    def create_coordinate_system(self, 
                               x_range=(-10, 10),
                               y_range=(-10, 10),
                               grid_step=1.0,
                               show_axes=True,
                               show_grid=True,
                               show_labels=True,
                               axis_color=(1, 1, 1, 1),
                               grid_color=(0.2, 0.2, 0.2, 0.5),
                               line_width=0.01):

        if show_axes:
            self._create_axes(x_range, y_range, axis_color, line_width*2)

        if show_grid:
            self._create_grid(x_range, y_range, grid_step, grid_color, line_width)

        if show_labels:
            self._create_labels(x_range, y_range, grid_step, axis_color)

    def _create_axes(self, x_range, y_range, color, width):
        # X-axis
        curve_data = bpy.data.curves.new('x_axis', 'CURVE')
        curve_data.dimensions = '3D'
        spline = curve_data.splines.new('POLY')
        spline.points.add(1)
        spline.points[0].co = (x_range[0], 0, 0, 1)
        spline.points[1].co = (x_range[1], 0, 0, 1)
        x_axis = bpy.data.objects.new('x_axis', curve_data)
        x_axis.data.bevel_depth = width
        self.axes['x'] = x_axis

        # Y-axis
        curve_data = bpy.data.curves.new('y_axis', 'CURVE')
        curve_data.dimensions = '3D'
        spline = curve_data.splines.new('POLY')
        spline.points.add(1)
        spline.points[0].co = (0, y_range[0], 0, 1)
        spline.points[1].co = (0, y_range[1], 0, 1)
        y_axis = bpy.data.objects.new('y_axis', curve_data)
        y_axis.data.bevel_depth = width
        self.axes['y'] = y_axis

        for axis in self.axes.values():
            bpy.context.scene.collection.objects.link(axis)
            mat = bpy.data.materials.new(name=f"{axis.name}_material")
            mat.use_nodes = True
            mat.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = color
            axis.data.materials.append(mat)

    def _create_grid(self, x_range, y_range, step, color, width):
        # Create vertical lines
        for x in range(int(x_range[0]), int(x_range[1]) + 1, int(step)):
            if x == 0:
                continue
            curve_data = bpy.data.curves.new(f'grid_v_{x}', 'CURVE')
            curve_data.dimensions = '3D'
            spline = curve_data.splines.new('POLY')
            spline.points.add(1)
            spline.points[0].co = (x, y_range[0], 0, 1)
            spline.points[1].co = (x, y_range[1], 0, 1)
            line = bpy.data.objects.new(f'grid_v_{x}', curve_data)
            line.data.bevel_depth = width
            self.grid_lines.append(line)

        # Create horizontal lines
        for y in range(int(y_range[0]), int(y_range[1]) + 1, int(step)):
            if y == 0:
                continue
            curve_data = bpy.data.curves.new(f'grid_h_{y}', 'CURVE')
            curve_data.dimensions = '3D'
            spline = curve_data.splines.new('POLY')
            spline.points.add(1)
            spline.points[0].co = (x_range[0], y, 0, 1)
            spline.points[1].co = (x_range[1], y, 0, 1)
            line = bpy.data.objects.new(f'grid_h_{y}', curve_data)
            line.data.bevel_depth = width
            self.grid_lines.append(line)

        for line in self.grid_lines:
            bpy.context.scene.collection.objects.link(line)
            mat = bpy.data.materials.new(name=f"{line.name}_material")
            mat.use_nodes = True
            mat.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = color
            line.data.materials.append(mat)

    def _create_labels(self, x_range, y_range, step, color):
        for x in range(int(x_range[0]), int(x_range[1]) + 1, int(step)):
            if x == 0:
                continue
            bpy.ops.object.text_add(location=(x, -0.5, 0))
            text = bpy.context.active_object
            text.data.body = str(x)
            text.scale = (0.3, 0.3, 0.3)
            self.labels.append(text)

        for y in range(int(y_range[0]), int(y_range[1]) + 1, int(step)):
            if y == 0:
                continue
            bpy.ops.object.text_add(location=(-0.5, y, 0))
            text = bpy.context.active_object
            text.data.body = str(y)
            text.scale = (0.3, 0.3, 0.3)
            self.labels.append(text)

        for label in self.labels:
            mat = bpy.data.materials.new(name=f"{label.name}_material")
            mat.use_nodes = True
            mat.node_tree.nodes["Principled BSDF"].inputs["Base Color"].default_value = color
            label.data.materials.append(mat)

==================================================

File: SceneX/src/scene/layout.py
Contents:
# SceneX/src/scene/layout.py

import bpy
from enum import Enum
from typing import List, Tuple, Optional
from mathutils import Vector
from ..scene.groups import Group
from ..utils.logger import SceneXLogger

class LayoutType(Enum):
    HORIZONTAL = "horizontal"
    VERTICAL = "vertical"
    GRID = "grid"
    CIRCULAR = "circular"
    SPIRAL = "spiral"

class Layout:
    def __init__(self):
        self.logger = SceneXLogger("Layout")

    def arrange(self, objects: List[bpy.types.Object], 
                layout_type: LayoutType,
                spacing: float = 1.0,
                center: Vector = Vector((0, 0, 0)),
                padding: float = 0.5,
                columns: int = 3) -> None:
        
        if not objects:
            return

        if layout_type == LayoutType.HORIZONTAL:
            self._arrange_horizontal(objects, spacing, center, padding)
        elif layout_type == LayoutType.VERTICAL:
            self._arrange_vertical(objects, spacing, center, padding)
        elif layout_type == LayoutType.GRID:
            self._arrange_grid(objects, spacing, center, padding, columns)
        elif layout_type == LayoutType.CIRCULAR:
            self._arrange_circular(objects, spacing, center, padding)
        elif layout_type == LayoutType.SPIRAL:
            self._arrange_spiral(objects, spacing, center, padding)

    def _arrange_horizontal(self, objects, spacing, center, padding):
        total_width = sum(obj.dimensions.x for obj in objects) + spacing * (len(objects) - 1)
        start_x = center.x - total_width/2 + objects[0].dimensions.x/2
        
        current_x = start_x
        for obj in objects:
            obj.location = Vector((current_x, center.y, center.z))
            current_x += obj.dimensions.x + spacing

    def _arrange_vertical(self, objects, spacing, center, padding):
        total_height = sum(obj.dimensions.y for obj in objects) + spacing * (len(objects) - 1)
        start_y = center.y + total_height/2 - objects[0].dimensions.y/2
        
        current_y = start_y
        for obj in objects:
            obj.location = Vector((center.x, current_y, center.z))
            current_y -= obj.dimensions.y + spacing

    def _arrange_grid(self, objects, spacing, center, padding, columns):
        rows = (len(objects) + columns - 1) // columns
        row_heights = []
        col_widths = []
        
        for i in range(rows):
            row_objects = objects[i*columns:min((i+1)*columns, len(objects))]
            row_heights.append(max(obj.dimensions.y for obj in row_objects))
        
        for i in range(columns):
            col_objects = [obj for j, obj in enumerate(objects) if j % columns == i]
            if col_objects:
                col_widths.append(max(obj.dimensions.x for obj in col_objects))
        
        total_width = sum(col_widths) + spacing * (columns - 1)
        total_height = sum(row_heights) + spacing * (rows - 1)
        
        start_x = center.x - total_width/2
        start_y = center.y + total_height/2
        
        for i, obj in enumerate(objects):
            row = i // columns
            col = i % columns
            
            x = start_x + sum(col_widths[:col]) + spacing * col + col_widths[col]/2
            y = start_y - (sum(row_heights[:row]) + spacing * row + row_heights[row]/2)
            
            obj.location = Vector((x, y, center.z))

    def _arrange_circular(self, objects, spacing, center, padding):
        count = len(objects)
        radius = max(obj.dimensions.length/2 for obj in objects) + spacing
        angle_step = 2 * 3.14159 / count
        
        for i, obj in enumerate(objects):
            angle = i * angle_step
            x = center.x + radius * math.cos(angle)
            y = center.y + radius * math.sin(angle)
            obj.location = Vector((x, y, center.z))
            obj.rotation_euler.z = angle + 3.14159/2

    def _arrange_spiral(self, objects, spacing, center, padding):
        count = len(objects)
        base_radius = max(obj.dimensions.length/2 for obj in objects) + spacing
        angle_step = 2 * 3.14159 / 8  # More gradual spiral
        
        for i, obj in enumerate(objects):
            angle = i * angle_step
            radius = base_radius * (1 + i/count)
            x = center.x + radius * math.cos(angle)
            y = center.y + radius * math.sin(angle)
            obj.location = Vector((x, y, center.z))
            obj.rotation_euler.z = angle + 3.14159/2

==================================================

File: SceneX/src/utils/logger.py
Contents:
# SceneX/src/utils/logger.py
import logging
import os
from datetime import datetime

class SceneXLogger:
    def __init__(self, name="SceneX", level=logging.DEBUG):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        
        # Create logs directory if it doesn't exist
        log_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'logs')
        os.makedirs(log_dir, exist_ok=True)
        
        # Create file handler with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        log_file = os.path.join(log_dir, f'scenex_{timestamp}.log')
        
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(level)
        
        # Create console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Add formatter to handlers
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        # Add handlers to logger
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
    
    def debug(self, msg): self.logger.debug(msg)
    def info(self, msg): self.logger.info(msg)
    def warning(self, msg): self.logger.warning(msg)
    def error(self, msg): self.logger.error(msg)
    def critical(self, msg): self.logger.critical(msg)

==================================================

File: SceneX/src/core/config.py
Contents:
"""
Configuration system for SceneX.
Defines all configuration classes used throughout the system.
"""

from dataclasses import dataclass, field
from typing import Optional, List, Tuple, Dict, Any
from enum import Enum, auto

class RateFuncType(Enum):
    """Standard animation rate functions"""
    LINEAR = auto()
    SMOOTH = auto()
    RUSH_INTO = auto()
    RUSH_FROM = auto()
    EASE_IN = auto()
    EASE_OUT = auto()
    EASE_IN_OUT = auto()
    EXPONENTIAL_DECAY = auto()

@dataclass
class AnimationConfig:
    """Configuration for animations"""
    duration: float = 1.0
    rate_func: RateFuncType = RateFuncType.SMOOTH
    frame_rate: int = 60
    delay: float = 0.0
    remover: bool = False

@dataclass
class CameraConfig:
    """Configuration for scene camera"""
    pixel_width: int = 1920
    pixel_height: int = 1080
    frame_rate: int = 60
    focal_distance: float = 10.0
    phi: float = 0  # rotation around X axis
    theta: float = 0  # rotation around Z axis
    frame_width: float = 14.0
    frame_height: float = 8.0
    orthographic: bool = True
    background_color: Tuple[float, float, float, float] = (0.1, 0.1, 0.1, 1)

@dataclass
class MaterialConfig:
    """Configuration for materials"""
    name: str = "default"
    color: Tuple[float, float, float, float] = (1, 1, 1, 1)
    metallic: float = 0.0
    roughness: float = 0.5
    emission_strength: float = 0.0
    alpha: float = 1.0


==================================================

File: SceneX/src/core/coordinate_system.py
Contents:
# SceneX/src/core/coordinate_system.py
import bpy
import mathutils
from src.utils.logger import SceneXLogger
from dataclasses import dataclass
from typing import Optional, Tuple, List, Dict

@dataclass
class GridConfig:
    """Configuration for coordinate grid"""
    x_range: Tuple[float, float] = (-8, 8)
    y_range: Tuple[float, float] = (-4, 4)
    x_step: float = 1.0
    y_step: float = 1.0
    color: Tuple[float, float, float, float] = (0.2, 0.2, 0.2, 1.0)
    line_thickness: float = 0.02
    show_axes: bool = True
    axes_color: Tuple[float, float, float, float] = (1.0, 1.0, 1.0, 1.0)
    show_numbers: bool = True
    number_scale: float = 0.3

class CoordinateSystem:
    """Manim-style coordinate system"""
    
    def __init__(self, origin=(0, 0, 0), scale=1.0):
        self.origin = mathutils.Vector(origin)
        self.scale = scale
        self.axes: Dict[str, bpy.types.Object] = {}
        self.grid_lines: List[bpy.types.Object] = []
        self.numbers: List[bpy.types.Object] = []
        self.logger = SceneXLogger("CoordinateSystem")

    def create_grid(self, config: Optional[GridConfig] = None):
        """Create Manim-style grid with axes"""
        if config is None:
            config = GridConfig()
            
        self.logger.info("Creating coordinate grid")
        try:
            self._create_axes(config)
            self._create_grid_lines(config)
            if config.show_numbers:
                self._create_numbers(config)
        except Exception as e:
            self.logger.error(f"Error creating grid: {str(e)}")

    def _create_axes(self, config: GridConfig):
        """Create x and y axes"""
        self.logger.info("Creating axes")
        
        # Create X axis
        x_start = mathutils.Vector((config.x_range[0], 0, 0)) * self.scale
        x_end = mathutils.Vector((config.x_range[1], 0, 0)) * self.scale
        self.axes['x'] = self._create_line(x_start, x_end, config.axes_color, config.line_thickness * 2)
        
        # Create Y axis
        y_start = mathutils.Vector((0, config.y_range[0], 0)) * self.scale
        y_end = mathutils.Vector((0, config.y_range[1], 0)) * self.scale
        self.axes['y'] = self._create_line(y_start, y_end, config.axes_color, config.line_thickness * 2)

    def _create_grid_lines(self, config: GridConfig):
        """Create grid lines"""
        self.logger.info("Creating grid lines")
        
        # Create vertical lines
        for x in range(int(config.x_range[0]), int(config.x_range[1]) + 1):
            if x == 0:  # Skip zero as it's the axis
                continue
            start = mathutils.Vector((x, config.y_range[0], 0)) * self.scale
            end = mathutils.Vector((x, config.y_range[1], 0)) * self.scale
            line = self._create_line(start, end, config.color, config.line_thickness)
            self.grid_lines.append(line)

        # Create horizontal lines
        for y in range(int(config.y_range[0]), int(config.y_range[1]) + 1):
            if y == 0:  # Skip zero as it's the axis
                continue
            start = mathutils.Vector((config.x_range[0], y, 0)) * self.scale
            end = mathutils.Vector((config.x_range[1], y, 0)) * self.scale
            line = self._create_line(start, end, config.color, config.line_thickness)
            self.grid_lines.append(line)

    def _create_line(self, start: mathutils.Vector, end: mathutils.Vector, 
                    color: Tuple[float, float, float, float], thickness: float) -> bpy.types.Object:
        """Create a single line"""
        # Create curve data
        curve_data = bpy.data.curves.new(name="line", type='CURVE')
        curve_data.dimensions = '3D'
        curve_data.resolution_u = 2
        
        # Create spline
        spline = curve_data.splines.new('POLY')
        spline.points.add(1)  # Add second point
        
        # Set coordinates
        spline.points[0].co = (*start, 1)
        spline.points[1].co = (*end, 1)
        
        # Create object
        line = bpy.data.objects.new("line", curve_data)
        line.data.bevel_depth = thickness
        
        # Create material
        mat = bpy.data.materials.new(name="line_material")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        nodes["Principled BSDF"].inputs["Base Color"].default_value = color
        line.data.materials.append(mat)
        
        # Link to scene
        bpy.context.scene.collection.objects.link(line)
        
        return line

    def _create_numbers(self, config: GridConfig):
        """Create number labels for axes"""
        self.logger.info("Creating number labels")
        
        # Create x axis numbers
        for x in range(int(config.x_range[0]), int(config.x_range[1]) + 1):
            if x == 0:
                continue
            pos = mathutils.Vector((x, -0.3, 0)) * self.scale
            self._create_number_text(str(x), pos, config.number_scale)

        # Create y axis numbers
        for y in range(int(config.y_range[0]), int(config.y_range[1]) + 1):
            if y == 0:
                continue
            pos = mathutils.Vector((-0.3, y, 0)) * self.scale
            self._create_number_text(str(y), pos, config.number_scale)

    def _create_number_text(self, text: str, location: mathutils.Vector, scale: float):
        """Create a number text object"""
        bpy.ops.object.text_add(location=location)
        text_obj = bpy.context.active_object
        text_obj.data.body = text
        text_obj.scale = (scale, scale, scale)
        self.numbers.append(text_obj)

    def place_object(self, obj: bpy.types.Object, position: mathutils.Vector):
        """Place object using Manim-style coordinates"""
        world_pos = self.origin + position * self.scale
        obj.location = world_pos
        self.logger.debug(f"Placed object at world position: {world_pos}")

==================================================

File: SceneX/src/core/scene.py
Contents:
# SceneX/src/core/scene.py
import bpy
import mathutils
from src.core.coordinate_system import CoordinateSystem
from src.camera.camera import CameraSystem
from src.utils.logger import SceneXLogger

class Scene:
    def __init__(self):
        self.logger = SceneXLogger("Scene")
        self.coordinate_system = CoordinateSystem()
        self.camera = CameraSystem()
        self.mobjects = []
        self.logger.info("Scene initialized")

    def create_text(self, content: str, location: tuple[float, float, float] = (0, 0, 0), 
                    size: float = 1.0) -> bpy.types.Object:
        """Create a text object in the scene"""
        self.logger.info(f"Creating text object: {content}")
        try:
            bpy.ops.object.text_add(location=location)
            text_obj = bpy.context.active_object
            text_obj.data.body = content
            text_obj.data.size = size  # Control text size
            
            # Create default material for text
            mat = bpy.data.materials.new(name=f"text_material_{text_obj.name}")
            mat.use_nodes = True
            principled = mat.node_tree.nodes["Principled BSDF"]
            principled.inputs["Base Color"].default_value = (1, 1, 1, 1)  # White text
            
            if text_obj.data.materials:
                text_obj.data.materials[0] = mat
            else:
                text_obj.data.materials.append(mat)
                
            return text_obj
        except Exception as e:
            self.logger.error(f"Error creating text: {str(e)}")
            return None

    def create_cube(self, size: float = 1.0, location: tuple[float, float, float] = (0, 0, 0)) -> bpy.types.Object:
        """Create a cube in the scene"""
        self.logger.info(f"Creating cube at location {location}")
        try:
            bpy.ops.mesh.primitive_cube_add(size=size, location=location)
            cube = bpy.context.active_object
            self.mobjects.append(cube)  # Add to mobjects list
            return cube
        except Exception as e:
            self.logger.error(f"Error creating cube: {str(e)}")
            return None

    def create_sphere(self, radius: float = 1.0, location: tuple[float, float, float] = (0, 0, 0)) -> bpy.types.Object:
        """Create a UV sphere in the scene"""
        self.logger.info(f"Creating sphere at location {location}")
        try:
            bpy.ops.mesh.primitive_uv_sphere_add(radius=radius, location=location)
            sphere = bpy.context.active_object
            self.mobjects.append(sphere)  # Add to mobjects list
            return sphere
        except Exception as e:
            self.logger.error(f"Error creating sphere: {str(e)}")
            return None

    def create_cylinder(self, radius: float = 1.0, depth: float = 2.0, 
                       location: tuple[float, float, float] = (0, 0, 0)) -> bpy.types.Object:
        """Create a cylinder in the scene"""
        self.logger.info(f"Creating cylinder at location {location}")
        try:
            bpy.ops.mesh.primitive_cylinder_add(radius=radius, depth=depth, location=location)
            cylinder = bpy.context.active_object
            self.mobjects.append(cylinder)  # Add to mobjects list
            return cylinder
        except Exception as e:
            self.logger.error(f"Error creating cylinder: {str(e)}")
            return None

    def create_circle(self, radius=1.0, location=(0, 0, 0)):
        """Create a circle primitive"""
        self.logger.info(f"Creating circle at location {location}")
        try:
            bpy.ops.mesh.primitive_circle_add(radius=radius, location=location)
            circle = bpy.context.active_object
            self.mobjects.append(circle)
            return circle
        except Exception as e:
            self.logger.error(f"Error creating circle: {str(e)}")
            return None

    def create_empty(self, location=(0, 0, 0)):
        """Create an empty object"""
        self.logger.info(f"Creating empty at location {location}")
        try:
            bpy.ops.object.empty_add(location=location)
            empty = bpy.context.active_object
            self.mobjects.append(empty)
            return empty
        except Exception as e:
            self.logger.error(f"Error creating empty: {str(e)}")
            return None

    def setup(self):
        """Setup the scene"""
        self.logger.info("Setting up scene")
        try:
            # Clear existing objects
            bpy.ops.object.select_all(action='SELECT')
            bpy.ops.object.delete()

            # Initialize coordinate system
            self.coordinate_system = CoordinateSystem()
            
            # Setup camera
            self.camera.setup()
            
        except Exception as e:
            self.logger.error(f"Error setting up scene: {str(e)}")

    def play(self, *animations):
        """Play animations"""
        self.logger.info("Playing animations")
        # Animation implementation will go here
        pass

    def construct(self):
        """Override this method in subclasses"""
        raise NotImplementedError("Must implement construct() method")

==================================================

File: SceneX/src/core/mobject.py
Contents:
import bpy
import mathutils
from typing import List, Optional
from ..utils.logger import SceneXLogger

class Mobject:
    """Base class for mobile objects with Manim-style functionality"""
    def __init__(self):
        self.object = None
        self.points = []
        self.submobjects = []
        self.logger = SceneXLogger("Mobject")
        
    def add(self, *mobjects):
        """Add submobjects (Manim-style)"""
        
    def shift(self, vector):
        """Move by vector (Manim-style)"""

==================================================

File: SceneX/src/animation/rate_functions.py
Contents:
# """
# Animation rate functions for SceneX.
# Controls timing and easing of animations.
# """

# import math
# from typing import Callable
# from ..core.config import RateFuncType

# class RateFunc:
#     """Collection of animation rate functions"""
    
#     @staticmethod
#     def linear(t: float) -> float:
#         return t
    
#     @staticmethod
#     def smooth(t: float) -> float:
#         return t * t * (3 - 2 * t)
    
#     @staticmethod
#     def rush_into(t: float) -> float:
#         return 2 * t * t
    
#     @staticmethod
#     def rush_from(t: float) -> float:
#         return t * (2 - t)
    
#     @staticmethod
#     def ease_in(t: float) -> float:
#         return t * t * t
    
#     @staticmethod
#     def ease_out(t: float) -> float:
#         return (t - 1) * (t - 1) * (t - 1) + 1
    
#     @staticmethod
#     def get_function(rate_type: RateFuncType) -> Callable[[float], float]:
#         return {
#             RateFuncType.LINEAR: RateFunc.linear,
#             RateFuncType.SMOOTH: RateFunc.smooth,
#             RateFuncType.RUSH_INTO: RateFunc.rush_into,
#             RateFuncType.RUSH_FROM: RateFunc.rush_from,
#             RateFuncType.EASE_IN: RateFunc.ease_in,
#             RateFuncType.EASE_OUT: RateFunc.ease_out,
#         }[rate_type]


# SceneX/src/animation/rate_functions.py

import math
from enum import Enum, auto
from typing import Callable

class RateFuncType(Enum):
    LINEAR = auto()
    SMOOTH = auto()
    RUSH_INTO = auto()
    RUSH_FROM = auto()
    EASE_IN = auto()
    EASE_OUT = auto()
    EASE_IN_OUT = auto()
    EXPONENTIAL = auto()
    ELASTIC = auto()
    BOUNCE = auto()
    BACK = auto()

class RateFunc:
    @staticmethod
    def linear(t: float) -> float:
        return t
    
    @staticmethod
    def smooth(t: float) -> float:
        return t * t * (3 - 2 * t)
    
    @staticmethod
    def rush_into(t: float) -> float:
        return 2 * t * t
    
    @staticmethod
    def rush_from(t: float) -> float:
        return t * (2 - t)
    
    @staticmethod
    def ease_in(t: float) -> float:
        return t * t * t
    
    @staticmethod
    def ease_out(t: float) -> float:
        return 1 - (1 - t) * (1 - t) * (1 - t)
    
    @staticmethod
    def ease_in_out(t: float) -> float:
        t *= 2
        if t < 1:
            return 0.5 * t * t * t
        t -= 2
        return 0.5 * (t * t * t + 2)

    @staticmethod
    def exponential(t: float) -> float:
        if t == 0:
            return 0
        return math.pow(2, 10 * (t - 1))
    
    @staticmethod
    def elastic(t: float) -> float:
        if t == 0 or t == 1:
            return t
        p = 0.3
        s = p / 4
        return -math.pow(2, 10 * (t - 1)) * math.sin((t - s) * (2 * math.pi) / p)
    
    @staticmethod
    def bounce(t: float) -> float:
        if t < (1/2.75):
            return 7.5625 * t * t
        elif t < (2/2.75):
            t -= (1.5/2.75)
            return 7.5625 * t * t + 0.75
        elif t < (2.5/2.75):
            t -= (2.25/2.75)
            return 7.5625 * t * t + 0.9375
        else:
            t -= (2.625/2.75)
            return 7.5625 * t * t + 0.984375
    
    @staticmethod
    def back(t: float) -> float:
        s = 1.70158
        return t * t * ((s + 1) * t - s)

    @classmethod
    def get_function(cls, rate_type: RateFuncType) -> Callable[[float], float]:
        return {
            RateFuncType.LINEAR: cls.linear,
            RateFuncType.SMOOTH: cls.smooth,
            RateFuncType.RUSH_INTO: cls.rush_into,
            RateFuncType.RUSH_FROM: cls.rush_from,
            RateFuncType.EASE_IN: cls.ease_in,
            RateFuncType.EASE_OUT: cls.ease_out,
            RateFuncType.EASE_IN_OUT: cls.ease_in_out,
            RateFuncType.EXPONENTIAL: cls.exponential,
            RateFuncType.ELASTIC: cls.elastic,
            RateFuncType.BOUNCE: cls.bounce,
            RateFuncType.BACK: cls.back
        }[rate_type]

==================================================

File: SceneX/src/animation/transform.py
Contents:
# SceneX/src/animation/transform.py
import bpy
import mathutils
from typing import Optional
from .base import Animation, AnimationConfig

class Transform(Animation):
    """Transform from current state to target state"""
    
    def __init__(self, target: bpy.types.Object, end_state: dict, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.end_state = end_state

    def create_keyframes(self, start_frame: int, end_frame: int):
        # Initial keyframe
        self.target.location = self.start_state["location"]
        self.target.rotation_euler = self.start_state["rotation"]
        self.target.scale = self.start_state["scale"]
        
        self.target.keyframe_insert(data_path="location", frame=start_frame)
        self.target.keyframe_insert(data_path="rotation_euler", frame=start_frame)
        self.target.keyframe_insert(data_path="scale", frame=start_frame)
        
        # End keyframe
        self.target.location = self.end_state.get("location", self.start_state["location"])
        self.target.rotation_euler = self.end_state.get("rotation", self.start_state["rotation"])
        self.target.scale = self.end_state.get("scale", self.start_state["scale"])
        
        self.target.keyframe_insert(data_path="location", frame=end_frame)
        self.target.keyframe_insert(data_path="rotation_euler", frame=end_frame)
        self.target.keyframe_insert(data_path="scale", frame=end_frame)

class FadeIn(Animation):
    """Fade in animation using material transparency"""
    
    def create_keyframes(self, start_frame: int, end_frame: int):
        # Create material if it doesn't exist
        if not self.target.active_material:
            mat = bpy.data.materials.new(name=f"{self.target.name}_material")
            mat.use_nodes = True
            self.target.active_material = mat
        
        mat = self.target.active_material
        mat.blend_method = 'BLEND'
        
        # Get the principled BSDF node
        principled = mat.node_tree.nodes.get("Principled BSDF")
        if not principled:
            principled = mat.node_tree.nodes.new('ShaderNodeBsdfPrincipled')
        
        # Set up and keyframe the alpha value
        principled.inputs['Alpha'].default_value = 0
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=start_frame)
        
        principled.inputs['Alpha'].default_value = 1
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=end_frame)

class FadeOut(Animation):
    """Fade out animation using material transparency"""
    
    def create_keyframes(self, start_frame: int, end_frame: int):
        # Create material if it doesn't exist
        if not self.target.active_material:
            mat = bpy.data.materials.new(name=f"{self.target.name}_material")
            mat.use_nodes = True
            self.target.active_material = mat
        
        mat = self.target.active_material
        mat.blend_method = 'BLEND'
        
        # Get the principled BSDF node
        principled = mat.node_tree.nodes.get("Principled BSDF")
        if not principled:
            principled = mat.node_tree.nodes.new('ShaderNodeBsdfPrincipled')
        
        # Set up and keyframe the alpha value
        principled.inputs['Alpha'].default_value = 1
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=start_frame)
        
        principled.inputs['Alpha'].default_value = 0
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=end_frame)

class Scale(Animation):
    """Scale animation"""
    
    def __init__(self, target: bpy.types.Object, scale_factor: float, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.scale_factor = scale_factor

    def create_keyframes(self, start_frame: int, end_frame: int):
        # Start at current scale
        self.target.keyframe_insert(data_path="scale", frame=start_frame)
        
        # End at scaled value
        self.target.scale = self.target.scale * self.scale_factor
        self.target.keyframe_insert(data_path="scale", frame=end_frame)

==================================================

File: SceneX/src/animation/commonly_used_animations.py
Contents:
# SceneX/src/animation/manim_animations.py
import bpy
import mathutils
from typing import Optional, List, Tuple, Union
from .base import Animation, AnimationConfig
from ..utils.logger import SceneXLogger  # Add this import

class GrowFromCenter(Animation):
    """Grow an object from its center point"""
    def __init__(self, target: bpy.types.Object, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.original_scale = target.scale.copy()
        
    def create_keyframes(self, start_frame: int, end_frame: int):
        # Start from zero scale
        self.target.scale = (0, 0, 0)
        self.target.keyframe_insert(data_path="scale", frame=start_frame)
        
        # End at original scale
        self.target.scale = self.original_scale
        self.target.keyframe_insert(data_path="scale", frame=end_frame)

class GrowFromPoint(Animation):
    """Grow an object from a specific point"""
    def __init__(self, target: bpy.types.Object, point: mathutils.Vector, 
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.point = point
        self.original_scale = target.scale.copy()
        self.original_location = target.location.copy()
        
    def create_keyframes(self, start_frame: int, end_frame: int):
        # Calculate offset between center and grow point
        offset = self.original_location - self.point
        
        # Start from point with zero scale
        self.target.scale = (0, 0, 0)
        self.target.location = self.point
        self.target.keyframe_insert(data_path="scale", frame=start_frame)
        self.target.keyframe_insert(data_path="location", frame=start_frame)
        
        # End at original position and scale
        self.target.scale = self.original_scale
        self.target.location = self.original_location
        self.target.keyframe_insert(data_path="scale", frame=end_frame)
        self.target.keyframe_insert(data_path="location", frame=end_frame)

class Write(Animation):
    """Write text character by character"""
    
    def __init__(self, target: bpy.types.Object, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        if not target.type == 'FONT':
            raise ValueError("Write animation can only be applied to text objects")
        self.full_text = target.data.body
        self.handler = None
        
    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            # Calculate frames per character
            text_length = len(self.full_text)
            frames_per_char = max(1, (end_frame - start_frame) // max(1, text_length))
            
            # Create a custom property to store the text progress
            self.target["text_progress"] = 0.0
            
            # Keyframe the custom property
            self.target.keyframe_insert(data_path='["text_progress"]', frame=start_frame)
            self.target["text_progress"] = float(text_length)
            self.target.keyframe_insert(data_path='["text_progress"]', frame=end_frame)
            
            # Set up the frame change handler
            def text_update(scene):
                obj = self.target
                if obj is None or scene.frame_current < start_frame:
                    return
                    
                if scene.frame_current > end_frame:
                    obj.data.body = self.full_text
                    return
                    
                progress = min(text_length, int(obj.get("text_progress", 0)))
                obj.data.body = self.full_text[:progress]
            
            # Remove any existing handlers for this object
            for handler in bpy.app.handlers.frame_change_post:
                if hasattr(handler, "__name__") and handler.__name__ == f"text_update_{self.target.name}":
                    bpy.app.handlers.frame_change_post.remove(handler)
            
            # Add the new handler
            text_update.__name__ = f"text_update_{self.target.name}"
            bpy.app.handlers.frame_change_post.append(text_update)
            self.handler = text_update
            
            # Set smooth interpolation
            if self.target.animation_data and self.target.animation_data.action:
                for fc in self.target.animation_data.action.fcurves:
                    if fc.data_path == '["text_progress"]':
                        for kf in fc.keyframe_points:
                            kf.interpolation = 'LINEAR'
            
            self.logger.info(f"Write animation setup for text: {self.full_text[:10]}...")
            return end_frame
            
        except Exception as e:
            self.logger.error(f"Error creating write animation: {str(e)}")
            return start_frame
    
    def cleanup(self):
        """Remove the frame handler when animation is done"""
        if self.handler and self.handler in bpy.app.handlers.frame_change_post:
            bpy.app.handlers.frame_change_post.remove(self.handler)


class FadeInFrom(Animation):
    """Fade in while moving from a direction"""
    def __init__(self, target: bpy.types.Object, direction: mathutils.Vector, 
                 distance: float = 5.0, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.direction = direction.normalized()
        self.distance = distance
        self.original_location = target.location.copy()
        
    def create_keyframes(self, start_frame: int, end_frame: int):
        # Setup material for fade
        if not self.target.active_material:
            mat = bpy.data.materials.new(name=f"{self.target.name}_material")
            mat.use_nodes = True
            self.target.active_material = mat
        
        mat = self.target.active_material
        mat.blend_method = 'BLEND'
        principled = mat.node_tree.nodes["Principled BSDF"]
        
        # Start position and fully transparent
        start_pos = self.original_location + self.direction * self.distance
        self.target.location = start_pos
        principled.inputs['Alpha'].default_value = 0
        
        self.target.keyframe_insert(data_path="location", frame=start_frame)
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", 
                                                 frame=start_frame)
        
        # End position and fully opaque
        self.target.location = self.original_location
        principled.inputs['Alpha'].default_value = 1
        
        self.target.keyframe_insert(data_path="location", frame=end_frame)
        principled.inputs['Alpha'].keyframe_insert(data_path="default_value", 
                                                 frame=end_frame)

class Rotate(Animation):
    """Rotate object around an axis"""
    def __init__(self, target: bpy.types.Object, angle: float, 
                 axis: str = 'Z', config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.angle = angle
        self.axis = axis.upper()
        self.original_rotation = target.rotation_euler.copy()
        
    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            # Start rotation
            self.target.keyframe_insert(data_path="rotation_euler", frame=start_frame)
            
            # End rotation
            axis_idx = {'X': 0, 'Y': 1, 'Z': 2}[self.axis]
            final_rotation = self.original_rotation.copy()
            final_rotation[axis_idx] += self.angle
            
            self.target.rotation_euler = final_rotation
            self.target.keyframe_insert(data_path="rotation_euler", frame=end_frame)
            
        except Exception as e:
            self.logger.error(f"Error creating rotation animation: {str(e)}")
            return start_frame
        
class FlashAround(Animation):
    """Create a flash/highlight effect around an object"""
    def __init__(self, target: bpy.types.Object, color: Tuple[float, float, float] = (1, 1, 0),
                 thickness: float = 0.1, config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.color = color
        self.thickness = thickness
        self.highlight_obj = None
    
    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            # Create emission material
            mat = bpy.data.materials.new(name="highlight_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            
            nodes = mat.node_tree.nodes
            links = mat.node_tree.links
            
            # Clear existing nodes
            nodes.clear()
            
            # Add new nodes
            emission = nodes.new('ShaderNodeEmission')
            output = nodes.new('ShaderNodeOutputMaterial')
            
            # Set up nodes
            emission.inputs['Color'].default_value = (*self.color, 1)
            links.new(emission.outputs['Emission'], output.inputs['Surface'])
            
            # Create highlight object
            bpy.ops.mesh.primitive_circle_add(
                vertices=32,
                radius=self.target.dimensions.length/2 + self.thickness,
                location=self.target.location
            )
            self.highlight_obj = bpy.context.active_object
            self.highlight_obj.data.materials.append(mat)
            
            # Animate emission strength using material node tree
            strength_path = 'nodes["Emission"].inputs[1].default_value'
            
            # Start (no emission)
            emission.inputs['Strength'].default_value = 0
            mat.node_tree.keyframe_insert(data_path=strength_path, frame=start_frame)
            
            # Peak (full emission)
            mid_frame = (start_frame + end_frame) // 2
            emission.inputs['Strength'].default_value = 5
            mat.node_tree.keyframe_insert(data_path=strength_path, frame=mid_frame)
            
            # End (no emission)
            emission.inputs['Strength'].default_value = 0
            mat.node_tree.keyframe_insert(data_path=strength_path, frame=end_frame)
            
            return end_frame
            
        except Exception as e:
            self.logger.error(f"Error creating FlashAround animation: {str(e)}")
            return start_frame

    def cleanup(self):
        """Remove highlight object when done"""
        if self.highlight_obj:
            bpy.data.objects.remove(self.highlight_obj, do_unlink=True)

==================================================

File: SceneX/src/animation/sequence.py
Contents:
# SceneX/src/animation/sequence.py

from typing import List
from .base import Animation, AnimationConfig

class AnimationSequence:
    def __init__(self, *animations: Animation, config: AnimationConfig = None):
        self.animations = animations
        self.config = config or AnimationConfig()
        
    def create_keyframes(self, start_frame: int) -> int:
        current_frame = start_frame
        for anim in self.animations:
            anim.config = anim.config or self.config
            current_frame = anim.create_animation(current_frame)
        return current_frame

class AnimationGroup:
    def __init__(self, *animations: Animation, config: AnimationConfig = None):
        self.animations = animations
        self.config = config or AnimationConfig()
        
    def create_keyframes(self, start_frame: int) -> int:
        for anim in self.animations:
            anim.config = anim.config or self.config
            anim.create_animation(start_frame)
        return start_frame + self.config.duration

class Succession(AnimationSequence):
    """Animations that smoothly flow into each other"""
    def create_keyframes(self, start_frame: int) -> int:
        overlap_frames = 10  # Frames where animations overlap
        current_frame = start_frame
        
        for i, anim in enumerate(self.animations):
            if i > 0:  # Start this animation before previous one ends
                current_frame -= overlap_frames
            current_frame = anim.create_animation(current_frame)
            
        return current_frame

==================================================

File: SceneX/src/animation/material_animations.py
Contents:
# src/animation/material_animations.py


import bpy
from typing import Optional, Tuple, Dict, Any, List
from .base import Animation, AnimationConfig
from ..utils.logger import SceneXLogger

class MaterialAnimation(Animation):
    """Animate material color changes"""
    def __init__(self, target: bpy.types.Object, 
                 start_color: Tuple[float, float, float, float],
                 end_color: Tuple[float, float, float, float], 
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.start_color = start_color
        self.end_color = end_color
        self.logger = SceneXLogger("MaterialAnimation")

    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            if not self.target.active_material:
                self.logger.warning("No active material found on target object")
                return start_frame
                
            mat = self.target.active_material
            principled = mat.node_tree.nodes.get('Principled BSDF')
            if not principled:
                self.logger.warning("No Principled BSDF node found in material")
                return start_frame
                
            # Start color
            principled.inputs['Base Color'].default_value = self.start_color
            principled.inputs['Base Color'].keyframe_insert(data_path="default_value", frame=start_frame)
            
            # End color
            principled.inputs['Base Color'].default_value = self.end_color
            principled.inputs['Base Color'].keyframe_insert(data_path="default_value", frame=end_frame)
            
            self.logger.info(f"Created color animation from {self.start_color} to {self.end_color}")
            return end_frame
            
        except Exception as e:
            self.logger.error(f"Error creating material animation: {str(e)}")
            return start_frame

class EmissionAnimation(Animation):
    """Animate emission strength changes"""
    def __init__(self, target: bpy.types.Object, 
                 start_strength: float, 
                 end_strength: float, 
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.start_strength = start_strength
        self.end_strength = end_strength
        self.logger = SceneXLogger("EmissionAnimation")

    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            if not self.target.active_material:
                self.logger.warning("No active material found on target object")
                return start_frame
                
            mat = self.target.active_material
            nodes = mat.node_tree.nodes
            emission = nodes.get("Emission")
            if not emission:
                self.logger.warning("No Emission node found in material")
                return start_frame
                
            # Start strength
            emission.inputs["Strength"].default_value = self.start_strength
            emission.inputs["Strength"].keyframe_insert(data_path="default_value", frame=start_frame)
            
            # End strength
            emission.inputs["Strength"].default_value = self.end_strength
            emission.inputs["Strength"].keyframe_insert(data_path="default_value", frame=end_frame)
            
            self.logger.info(f"Created emission animation from {self.start_strength} to {self.end_strength}")
            return end_frame
            
        except Exception as e:
            self.logger.error(f"Error creating emission animation: {str(e)}")
            return start_frame
        
        
class MaterialPropertyAnimation(Animation):
    """Animate any material property"""
    def __init__(self, target: bpy.types.Object,
                 property_path: str,
                 start_value: float,
                 end_value: float,
                 node_name: str = 'Principled BSDF',
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.property_path = property_path
        self.start_value = start_value
        self.end_value = end_value
        self.node_name = node_name
        self.logger = SceneXLogger("MaterialPropertyAnimation")

    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            if not self.target.active_material:
                self.logger.warning("No active material found")
                return start_frame

            mat = self.target.active_material
            node = mat.node_tree.nodes.get(self.node_name)
            if not node:
                self.logger.warning(f"Node {self.node_name} not found")
                return start_frame

            # Set start value
            node.inputs[self.property_path].default_value = self.start_value
            node.inputs[self.property_path].keyframe_insert(
                data_path="default_value", frame=start_frame)

            # Set end value
            node.inputs[self.property_path].default_value = self.end_value
            node.inputs[self.property_path].keyframe_insert(
                data_path="default_value", frame=end_frame)

            return end_frame

        except Exception as e:
            self.logger.error(f"Error animating material property: {str(e)}")
            return start_frame

class MaterialPresetAnimation(Animation):
    """Animate between material presets"""
    def __init__(self, target: bpy.types.Object,
                 preset_sequence: List[Dict[str, float]],
                 node_name: str = 'Principled BSDF',
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.preset_sequence = preset_sequence
        self.node_name = node_name
        self.logger = SceneXLogger("MaterialPresetAnimation")

    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            if not self.target.active_material:
                self.logger.warning("No active material found")
                return start_frame

            mat = self.target.active_material
            node = mat.node_tree.nodes.get(self.node_name)
            if not node:
                self.logger.warning(f"Node {self.node_name} not found")
                return start_frame

            frame_interval = (end_frame - start_frame) / (len(self.preset_sequence) - 1)
            
            for i, preset in enumerate(self.preset_sequence):
                current_frame = start_frame + (i * frame_interval)
                
                for prop_name, value in preset.items():
                    if prop_name in node.inputs:
                        node.inputs[prop_name].default_value = value
                        node.inputs[prop_name].keyframe_insert(
                            data_path="default_value", frame=current_frame)

            return end_frame

        except Exception as e:
            self.logger.error(f"Error animating material preset: {str(e)}")
            return start_frame

class MaterialBlendAnimation(Animation):
    """Blend between two complete materials"""
    def __init__(self, target: bpy.types.Object,
                 material1: bpy.types.Material,
                 material2: bpy.types.Material,
                 config: Optional[AnimationConfig] = None):
        super().__init__(target, config)
        self.material1 = material1
        self.material2 = material2
        self.logger = SceneXLogger("MaterialBlendAnimation")

    def create_keyframes(self, start_frame: int, end_frame: int):
        try:
            # Create blend material
            blend_mat = bpy.data.materials.new(name="blend_material")
            blend_mat.use_nodes = True
            nodes = blend_mat.node_tree.nodes
            links = blend_mat.node_tree.links
            
            # Clear existing nodes
            nodes.clear()
            
            # Add nodes
            mat1 = nodes.new('ShaderNodeMaterial')
            mat2 = nodes.new('ShaderNodeMaterial')
            mix = nodes.new('ShaderNodeMixShader')
            output = nodes.new('ShaderNodeOutputMaterial')
            
            # Setup materials
            mat1.material = self.material1
            mat2.material = self.material2
            
            # Connect nodes
            links.new(mat1.outputs['Surface'], mix.inputs[1])
            links.new(mat2.outputs['Surface'], mix.inputs[2])
            links.new(mix.outputs['Shader'], output.inputs['Surface'])
            
            # Create keyframes
            mix.inputs[0].default_value = 0
            mix.inputs[0].keyframe_insert(data_path="default_value", frame=start_frame)
            
            mix.inputs[0].default_value = 1
            mix.inputs[0].keyframe_insert(data_path="default_value", frame=end_frame)
            
            # Assign blended material
            self.target.active_material = blend_mat
            
            return end_frame

        except Exception as e:
            self.logger.error(f"Error creating material blend: {str(e)}")
            return start_frame

# Example material presets
MATERIAL_PRESETS = {
    'metal': {
        'Metallic': 1.0,
        'Roughness': 0.2,
        'Base Color': (0.8, 0.8, 0.8, 1.0)
    },
    'plastic': {
        'Metallic': 0.0,
        'Roughness': 0.4,
        'Base Color': (0.2, 0.5, 1.0, 1.0)
    },
    'glass': {
        'Transmission': 1.0,
        'Roughness': 0.0,
        'Base Color': (0.8, 0.9, 1.0, 1.0),
        'IOR': 1.45
    }
}

==================================================

File: SceneX/src/animation/base.py
Contents:
# SceneX/src/animation/base.py
import bpy
import mathutils
from dataclasses import dataclass
from typing import Optional, Tuple, List, Callable
from ..utils.logger import SceneXLogger

@dataclass
class AnimationConfig:
    """Configuration for animations"""
    duration: int = 30  # Duration in frames
    start_frame: Optional[int] = None
    rate_func: Callable[[float], float] = lambda x: x  # Linear by default
    delay_frames: int = 0
    ease_type: str = 'EASE_IN_OUT'  # LINEAR, EASE_IN, EASE_OUT, EASE_IN_OUT

class Animation:
    """Base class for all animations"""
    
    def __init__(self, target: bpy.types.Object, config: Optional[AnimationConfig] = None):
        self.target = target
        self.config = config or AnimationConfig()
        self.logger = SceneXLogger("Animation")
        self.start_state = {}
        self.store_initial_state()

    def store_initial_state(self):
        """Store the initial state of the object"""
        if not self.target:
            return
            
        self.start_state = {
            "location": self.target.location.copy(),
            "rotation": self.target.rotation_euler.copy(),
            "scale": self.target.scale.copy()
        }
        
        # Store material properties if exists
        if self.target.active_material:
            mat = self.target.active_material
            if mat.use_nodes:
                principled = mat.node_tree.nodes.get('Principled BSDF')
                if principled:
                    self.start_state["color"] = principled.inputs['Base Color'].default_value[:]
                    self.start_state["alpha"] = principled.inputs['Alpha'].default_value

    def create_animation(self, start_frame: int):
        """Create the animation starting at the given frame"""
        if self.config.start_frame is None:
            self.config.start_frame = start_frame
            
        end_frame = self.config.start_frame + self.config.duration
        
        try:
            self.create_keyframes(self.config.start_frame, end_frame)
            self.setup_fcurves()
            return end_frame
        except Exception as e:
            self.logger.error(f"Error creating animation: {str(e)}")
            return start_frame

    def create_keyframes(self, start_frame: int, end_frame: int):
        """Override in subclasses to create specific keyframes"""
        raise NotImplementedError

    def setup_fcurves(self):
        """Setup F-curves with proper interpolation"""
        if not self.target.animation_data or not self.target.animation_data.action:
            return
            
        for fc in self.target.animation_data.action.fcurves:
            for kf in fc.keyframe_points:
                kf.interpolation = 'BEZIER'
                if self.config.ease_type == 'LINEAR':
                    kf.easing = 'LINEAR'
                else:
                    kf.easing = self.config.ease_type

==================================================

File: SceneX/src/animation/transform_between.py
Contents:
# src/animation/transform_between.py

import bpy
import bmesh
import random
from mathutils import Vector, interpolate
from .base import Animation, AnimationConfig
from ..utils.logger import SceneXLogger

class TransformBetween(Animation):
    """Transform one mesh object into another"""
    def __init__(self, source_obj: bpy.types.Object, target_obj: bpy.types.Object, 
                 config: AnimationConfig = None):
        super().__init__(source_obj, config)
        self.target_obj = target_obj
        self.logger = SceneXLogger("TransformBetween")
        
        # Store vertex data
        self.source_verts = [v.co.copy() for v in source_obj.data.vertices]
        self.target_verts = self._get_corresponding_verts()
        
    def _get_corresponding_verts(self):
        """Map vertices between source and target meshes"""
        source_verts = len(self.source_verts)
        target_verts = len(self.target_obj.data.vertices)
        
        if source_verts != target_verts:
            self.logger.warning(f"Vertex count mismatch: {source_verts} vs {target_verts}")
            # Resample target mesh to match source vertex count
            return self._resample_mesh(self.target_obj, source_verts)
            
        return [v.co.copy() for v in self.target_obj.data.vertices]
    
    def _resample_mesh(self, obj, target_count):
        """Resample mesh to have target number of vertices"""
        bm = bmesh.new()
        bm.from_mesh(obj.data)
        
        # Subdivide or simplify mesh to match vertex count
        while len(bm.verts) < target_count:
            bmesh.ops.subdivide_edges(bm, 
                edges=bm.edges[:], 
                cuts=1)
        
        while len(bm.verts) > target_count:
            bmesh.ops.dissolve_edges(bm,
                edges=[e for e in bm.edges if len(e.link_faces) == 2],
                use_verts=True)
        
        verts = [v.co.copy() for v in bm.verts]
        bm.free()
        return verts
    
    def create_keyframes(self, start_frame: int, end_frame: int):
        """Create vertex animation keyframes"""
        try:
            # Enable mesh shape keys
            if not self.target.data.shape_keys:
                self.target.shape_key_add(name="Basis")
            
            # Add target shape key
            shape_key = self.target.shape_key_add(name="Target")
            
            # Keyframe vertex positions
            for frame in range(start_frame, end_frame + 1):
                factor = (frame - start_frame) / (end_frame - start_frame)
                factor = self.config.rate_func(factor)
                
                # Interpolate vertex positions
                for i, (start, end) in enumerate(zip(self.source_verts, self.target_verts)):
                    shape_key.data[i].co = start.lerp(end, factor)
                
                shape_key.value = factor
                shape_key.keyframe_insert("value", frame=frame)
                
            self.logger.info("Created transform animation keyframes")
            
        except Exception as e:
            self.logger.error(f"Error creating transform animation: {str(e)}")

class MorphBetween(TransformBetween):
    """Morph between objects with different topologies using surface sampling"""
    def __init__(self, source_obj: bpy.types.Object, target_obj: bpy.types.Object, 
                 samples: int = 1000, config: AnimationConfig = None):
        self.samples = samples
        super().__init__(source_obj, target_obj, config)
    
    def _get_corresponding_verts(self):
        """Sample points on both meshes"""
        source_points = self._sample_surface(self.target, self.samples)
        target_points = self._sample_surface(self.target_obj, self.samples)
        return target_points
    
    def _sample_surface(self, obj, count):
        """Randomly sample points on mesh surface"""
        bm = bmesh.new()
        bm.from_mesh(obj.data)
        bmesh.ops.triangulate(bm, faces=bm.faces[:])
        
        total_area = sum(f.calc_area() for f in bm.faces)
        points = []
        
        for face in bm.faces:
            # Sample proportional to face area
            n_points = int((face.calc_area() / total_area) * count)
            points.extend(self._sample_triangle(face, n_points))
        
        bm.free()
        return points
    
    def _sample_triangle(self, face, count):
        """Generate random points within a triangle"""
        points = []
        verts = [v.co for v in face.verts]
        
        for _ in range(count):
            # Random barycentric coordinates
            u = random.random()
            v = random.random() * (1 - u)
            w = 1 - u - v
            
            # Interpolate position
            point = verts[0] * u + verts[1] * v + verts[2] * w
            points.append(point)
        
        return points

==================================================

File: SceneX/ui/ai_panel.py
Contents:
# ui/ai_panel.py

import bpy
from bpy.props import StringProperty
from ..src.ai.scene_generator import AISceneGenerator

class SCENEX_OT_GenerateScene(bpy.types.Operator):
    """Generate scene from natural language description"""
    bl_idname = "scenex.generate_scene"
    bl_label = "Generate Scene"
    bl_description = "Generate a scene from natural language description"
    bl_options = {'REGISTER', 'UNDO'}
    
    prompt: StringProperty(
        name="Description",
        description="Describe the architecture you want to create",
        default=""
    )
    
    def execute(self, context):
        if not self.prompt.strip():
            self.report({'ERROR'}, "Please provide a description")
            return {'CANCELLED'}
            
        generator = AISceneGenerator()
        try:
            # Process prompt and generate scene
            scene_data = generator.process_prompt(self.prompt)
            if scene_data:
                generator.generate_scene(scene_data)
                self.report({'INFO'}, "Scene generated successfully")
                return {'FINISHED'}
            else:
                self.report({'ERROR'}, "Could not generate scene from description")
                return {'CANCELLED'}
        except Exception as e:
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}
    
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self, width=400)
    
    def draw(self, context):
        layout = self.layout
        layout.prop(self, "prompt", text="")
        layout.label(text="Example: Create a serverless ML pipeline with API Gateway and Lambda")

class SCENEX_PT_AIPanel(bpy.types.Panel):
    """Panel for AI scene generation"""
    bl_label = "AI Scene Generator"
    bl_idname = "SCENEX_PT_ai"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "SceneX"
    
    def draw(self, context):
        layout = self.layout
        
        col = layout.column(align=True)
        col.operator("scenex.generate_scene", text="Generate Scene", icon='SHADERFX')
        
        # Add quick presets
        box = layout.box()
        box.label(text="Quick Presets:")
        col = box.column(align=True)
        col.operator("scenex.generate_scene", text="Serverless API").prompt = "Create serverless API with API Gateway and Lambda"
        col.operator("scenex.generate_scene", text="ML Pipeline").prompt = "Create ML pipeline with SageMaker and S3"
        col.operator("scenex.generate_scene", text="VPC Network").prompt = "Create VPC with public and private subnets"

# Register classes
classes = (
    SCENEX_OT_GenerateScene,
    SCENEX_PT_AIPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

==================================================

File: SceneX/ui/panels.py
Contents:
# ui/panels.py
import bpy

class SCENEX_PT_BasePanel:
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = "SceneX"

class SCENEX_PT_MainPanel(SCENEX_PT_BasePanel, bpy.types.Panel):
    """Main panel for SceneX"""
    bl_label = "SceneX"
    bl_idname = "SCENEX_PT_main"
    
    def draw(self, context):
        layout = self.layout
        
        # Preset menu
        row = layout.row(align=True)
        row.menu("SCENEX_MT_preset_menu", text="Presets")

class SCENEX_PT_AnimationPanel(SCENEX_PT_BasePanel, bpy.types.Panel):
    """Animation controls for SceneX"""
    bl_label = "Animation"
    bl_idname = "SCENEX_PT_animation"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.scenex
        
        col = layout.column(align=True)
        col.prop(props, "animation_type")
        col.prop(props, "animation_duration")
        col.prop(props, "rate_function")
        
        row = layout.row()
        row.operator("scenex.add_animation")

class SCENEX_PT_CameraPanel(SCENEX_PT_BasePanel, bpy.types.Panel):
    """Camera controls for SceneX"""
    bl_label = "Camera"
    bl_idname = "SCENEX_PT_camera"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.scenex
        
        col = layout.column(align=True)
        col.prop(props, "camera_movement")
        col.prop(props, "camera_target_distance")
        
        row = layout.row()
        row.operator("scenex.camera_move")

class SCENEX_PT_GridPanel(SCENEX_PT_BasePanel, bpy.types.Panel):
    """Grid controls for SceneX"""
    bl_label = "Grid"
    bl_idname = "SCENEX_PT_grid"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.scenex
        
        col = layout.column(align=True)
        col.prop(props, "grid_size")
        col.prop(props, "grid_subdivisions")
        col.prop(props, "show_labels")
        
        row = layout.row()
        row.operator("scenex.create_grid")

class SCENEX_PT_MaterialPanel(SCENEX_PT_BasePanel, bpy.types.Panel):
    """Material controls for SceneX"""
    bl_label = "Material"
    bl_idname = "SCENEX_PT_material"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.scenex
        
        col = layout.column(align=True)
        col.prop(props, "material_type")
        col.prop(props, "material_color")
        
        row = layout.row()
        row.operator("scenex.assign_material")

# Register/unregister all panels
classes = (
    SCENEX_PT_AnimationPanel,
    SCENEX_PT_CameraPanel,
    SCENEX_PT_GridPanel,
    SCENEX_PT_MaterialPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    print("SceneX Panels registered")

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    print("SceneX Panels unregistered")


==================================================

File: SceneX/ui/properties.py
Contents:
# ui/properties.py
import bpy
from bpy.props import (StringProperty, BoolProperty, FloatProperty, 
                      EnumProperty, FloatVectorProperty, IntProperty)
from ..src.animation.rate_functions import RateFuncType

def get_rate_func_items():
    return [(rf.name, rf.name.title().replace('_', ' '), 
             f"Use {rf.name.lower().replace('_', ' ')} rate function")
            for rf in RateFuncType]

class SceneXProperties(bpy.types.PropertyGroup):
    """Property group for SceneX addon settings"""
    
    # Animation Properties
    animation_duration: IntProperty(
        name="Duration",
        description="Duration of animation in frames",
        default=30,
        min=1,
        soft_max=300
    )
    
    animation_type: EnumProperty(
        name="Animation Type",
        description="Type of animation to create",
        items=[
            ('GROW_FROM_CENTER', "Grow From Center", "Grow object from its center point"),
            ('WRITE', "Write", "Write text character by character"),
            ('FADE_IN', "Fade In", "Fade object into view"),
            ('ROTATE', "Rotate", "Rotate object around axis"),
            ('FLASH_AROUND', "Flash Around", "Create a flash effect around object")
        ],
        default='FADE_IN'
    )
    
    rate_function: EnumProperty(
        name="Rate Function",
        description="Animation rate function to use",
        items=get_rate_func_items(),
        default='LINEAR'
    )
    
    # Camera Properties
    camera_movement: EnumProperty(
        name="Camera Movement",
        description="Type of camera movement to perform",
        items=[
            ('DOLLY', "Dolly", "Move camera forward/backward"),
            ('ORBIT', "Orbit", "Orbit around target"),
            ('FLY_TO', "Fly To", "Smoothly move to new position"),
            ('FRAME_OBJECT', "Frame Object", "Frame selected object")
        ],
        default='DOLLY'
    )
    
    camera_target_distance: FloatProperty(
        name="Target Distance",
        description="Distance to maintain from camera target",
        default=10.0,
        min=0.1,
        soft_max=100.0
    )
    
    # Grid Properties
    grid_size: FloatProperty(
        name="Grid Size",
        description="Size of the coordinate grid",
        default=10.0,
        min=1.0,
        soft_max=50.0
    )
    
    grid_subdivisions: IntProperty(
        name="Grid Subdivisions",
        description="Number of grid subdivisions",
        default=10,
        min=1,
        soft_max=50
    )
    
    show_labels: BoolProperty(
        name="Show Labels",
        description="Show coordinate labels on grid",
        default=True
    )
    
    # Material Properties
    material_type: EnumProperty(
        name="Material Type",
        description="Type of material to create",
        items=[
            ('BASIC', "Basic", "Basic material with color"),
            ('GLASS', "Glass", "Transparent glass material"),
            ('EMISSION', "Emission", "Glowing emission material"),
            ('METALLIC', "Metallic", "Metallic material"),
            ('TOON', "Toon", "Toon/cel-shaded material")
        ],
        default='BASIC'
    )
    
    material_color: FloatVectorProperty(
        name="Color",
        description="Material color",
        subtype='COLOR',
        size=4,
        min=0.0,
        max=1.0,
        default=(1.0, 1.0, 1.0, 1.0)
    )

def register():
    bpy.utils.register_class(SceneXProperties)
    bpy.types.Scene.scenex = bpy.props.PointerProperty(type=SceneXProperties)
    print("SceneX Properties registered")

def unregister():
    del bpy.types.Scene.scenex
    bpy.utils.unregister_class(SceneXProperties)
    print("SceneX Properties unregistered")

==================================================

File: SceneX/ui/handlers.py
Contents:
# ui/handlers.py
import bpy
from ..src.utils.logger import SceneXLogger

logger = SceneXLogger("Handlers")

def update_animation_type(self, context):
    """Handle animation type changes"""
    try:
        if self.animation_type == 'WRITE' and context.active_object:
            if context.active_object.type != 'FONT':
                self.animation_type = 'FADE_IN'
                logger.warning("Write animation can only be applied to text objects")
                
    except Exception as e:
        logger.error(f"Error in animation type update: {str(e)}")

def update_camera_movement(self, context):
    """Handle camera movement type changes"""
    try:
        if not context.scene.camera:
            logger.warning("No camera in scene")
            return
            
        movement_type = self.camera_movement
        if movement_type == 'FRAME_OBJECT' and not context.selected_objects:
            logger.warning("No object selected to frame")
            return
            
        logger.info(f"Camera movement updated to: {movement_type}")
            
    except Exception as e:
        logger.error(f"Error in camera movement update: {str(e)}")

def update_material_type(self, context):
    """Handle material type changes"""
    try:
        if not context.active_object:
            logger.warning("No active object for material assignment")
            return
            
        # Update material preview if it exists
        if hasattr(context.active_object, 'active_material'):
            material_type = self.material_type
            # Future: Update material preview
            logger.info(f"Material type updated to: {material_type}")
            
    except Exception as e:
        logger.error(f"Error in material type update: {str(e)}")

def update_grid_settings(self, context):
    """Handle grid setting changes"""
    try:
        # Future: Update grid visualization
        logger.info("Grid settings updated")
        
    except Exception as e:
        logger.error(f"Error in grid settings update: {str(e)}")

# Register update handlers with properties
def register_handlers():
    """Register all property update handlers"""
    try:
        # Update SceneXProperties class to include update callbacks
        bpy.types.Scene.scenex.animation_type.update = update_animation_type
        bpy.types.Scene.scenex.camera_movement.update = update_camera_movement
        bpy.types.Scene.scenex.material_type.update = update_material_type
        bpy.types.Scene.scenex.grid_size.update = update_grid_settings
        bpy.types.Scene.scenex.grid_subdivisions.update = update_grid_settings
        
        logger.info("Property update handlers registered")
        
    except Exception as e:
        logger.error(f"Error registering update handlers: {str(e)}")

def unregister_handlers():
    """Unregister all property update handlers"""
    try:
        # Remove update callbacks
        bpy.types.Scene.scenex.animation_type.update = None
        bpy.types.Scene.scenex.camera_movement.update = None
        bpy.types.Scene.scenex.material_type.update = None
        bpy.types.Scene.scenex.grid_size.update = None
        bpy.types.Scene.scenex.grid_subdivisions.update = None
        
        logger.info("Property update handlers unregistered")
        
    except Exception as e:
        logger.error(f"Error unregistering update handlers: {str(e)}")

        

==================================================

File: SceneX/ui/operators.py
Contents:
# ui/operators.py
import bpy
from bpy.props import StringProperty, FloatProperty, EnumProperty
from ..src.animation.commonly_used_animations import (GrowFromCenter, Write, 
                                                    FadeInFrom, Rotate, FlashAround)
from ..src.utils.logger import SceneXLogger

logger = SceneXLogger("Operators")

class SCENEX_OT_AddAnimation(bpy.types.Operator):
    """Add animation to selected object"""
    bl_idname = "scenex.add_animation"
    bl_label = "Add Animation"
    bl_description = "Add selected animation to object"
    bl_options = {'REGISTER', 'UNDO'}
    
    @classmethod
    def poll(cls, context):
        return context.active_object is not None
    
    def execute(self, context):
        try:
            obj = context.active_object
            props = context.scene.scenex
            
            anim_type = props.animation_type
            duration = props.animation_duration
            
            if anim_type == 'GROW_FROM_CENTER':
                anim = GrowFromCenter(obj)
            elif anim_type == 'WRITE':
                anim = Write(obj)
            elif anim_type == 'FADE_IN':
                anim = FadeInFrom(obj, direction=(0, 0, 1))
            elif anim_type == 'ROTATE':
                anim = Rotate(obj, angle=3.14159)
            elif anim_type == 'FLASH_AROUND':
                anim = FlashAround(obj)
            
            current_frame = context.scene.frame_current
            anim.create_animation(current_frame)
            
            self.report({'INFO'}, f"Added {anim_type} animation")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error adding animation: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}

class SCENEX_OT_CameraMove(bpy.types.Operator):
    """Move camera using selected movement type"""
    bl_idname = "scenex.camera_move"
    bl_label = "Move Camera"
    bl_description = "Move camera using selected movement type"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        try:
            camera = context.scene.camera
            props = context.scene.scenex
            
            if not camera:
                self.report({'ERROR'}, "No camera in scene")
                return {'CANCELLED'}
            
            movement_type = props.camera_movement
            
            # Implementation will vary based on movement type
            self.report({'INFO'}, f"Executed {movement_type} camera movement")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error moving camera: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}

class SCENEX_OT_CreateGrid(bpy.types.Operator):
    """Create coordinate grid"""
    bl_idname = "scenex.create_grid"
    bl_label = "Create Grid"
    bl_description = "Create coordinate grid system"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        try:
            props = context.scene.scenex
            # Grid creation implementation
            self.report({'INFO'}, "Created coordinate grid")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error creating grid: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}

class SCENEX_OT_AssignMaterial(bpy.types.Operator):
    """Assign material to selected object"""
    bl_idname = "scenex.assign_material"
    bl_label = "Assign Material"
    bl_description = "Assign selected material type to object"
    bl_options = {'REGISTER', 'UNDO'}
    
    @classmethod
    def poll(cls, context):
        return context.active_object is not None
    
    def execute(self, context):
        try:
            obj = context.active_object
            props = context.scene.scenex
            
            # Material assignment implementation
            self.report({'INFO'}, f"Assigned {props.material_type} material")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error assigning material: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}

# Register/unregister all operators
classes = (
    SCENEX_OT_AddAnimation,
    SCENEX_OT_CameraMove,
    SCENEX_OT_CreateGrid,
    SCENEX_OT_AssignMaterial,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    print("SceneX Operators registered")

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    print("SceneX Operators unregistered")


==================================================

File: SceneX/ui/presets.py
Contents:
# ui/presets.py
import bpy
import os
import json
from bpy.props import StringProperty
from bpy.types import Operator, Menu
from ..src.utils.logger import SceneXLogger

logger = SceneXLogger("Presets")

class SCENEX_MT_PresetMenu(Menu):
    bl_label = "SceneX Presets"
    bl_idname = "SCENEX_MT_preset_menu"
    preset_subdir = "scenex/presets"
    preset_operator = "script.execute_preset"
    
    def draw(self, context):
        self.draw_preset(context)
    
    def draw_preset(self, context):
        layout = self.layout
        layout.operator("scenex.save_preset", text="Save Current Settings")
        layout.separator()
        
        # Add preset operators
        layout.operator_context = 'EXEC_DEFAULT'
        
        # Animation presets
        layout.label(text="Animation Presets:")
        layout.operator("scenex.load_preset", text="Basic Fade In").preset_name = "basic_fade"
        layout.operator("scenex.load_preset", text="Dramatic Entrance").preset_name = "dramatic_entrance"
        
        # Camera presets
        layout.label(text="Camera Presets:")
        layout.operator("scenex.load_preset", text="Overview Shot").preset_name = "camera_overview"
        layout.operator("scenex.load_preset", text="Close Up").preset_name = "camera_closeup"
        
        # Material presets
        layout.label(text="Material Presets:")
        layout.operator("scenex.load_preset", text="Glass Material").preset_name = "glass_material"
        layout.operator("scenex.load_preset", text="Metallic Material").preset_name = "metallic_material"

class SCENEX_OT_SavePreset(Operator):
    """Save current settings as a preset"""
    bl_idname = "scenex.save_preset"
    bl_label = "Save Preset"
    bl_description = "Save current SceneX settings as a preset"
    bl_options = {'REGISTER', 'UNDO'}
    
    preset_name: StringProperty(
        name="Preset Name",
        description="Name of the preset to save",
        default="New Preset"
    )
    
    def execute(self, context):
        try:
            props = context.scene.scenex
            preset_data = {
                "animation_type": props.animation_type,
                "animation_duration": props.animation_duration,
                "rate_function": props.rate_function,
                "camera_movement": props.camera_movement,
                "camera_target_distance": props.camera_target_distance,
                "material_type": props.material_type,
                "material_color": list(props.material_color),
                "grid_size": props.grid_size,
                "grid_subdivisions": props.grid_subdivisions,
                "show_labels": props.show_labels
            }
            
            # Create presets directory if it doesn't exist
            presets_path = os.path.join(bpy.utils.user_resource('SCRIPTS'), 
                                      "presets", "scenex")
            os.makedirs(presets_path, exist_ok=True)
            
            # Save preset file
            preset_file = os.path.join(presets_path, f"{self.preset_name}.json")
            with open(preset_file, 'w') as f:
                json.dump(preset_data, f, indent=4)
            
            self.report({'INFO'}, f"Saved preset: {self.preset_name}")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error saving preset: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}
    
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)

class SCENEX_OT_LoadPreset(Operator):
    """Load a saved preset"""
    bl_idname = "scenex.load_preset"
    bl_label = "Load Preset"
    bl_description = "Load a saved SceneX preset"
    bl_options = {'REGISTER', 'UNDO'}
    
    preset_name: StringProperty(
        name="Preset Name",
        description="Name of the preset to load"
    )
    
    def execute(self, context):
        try:
            # Load preset file
            presets_path = os.path.join(bpy.utils.user_resource('SCRIPTS'), 
                                      "presets", "scenex")
            preset_file = os.path.join(presets_path, f"{self.preset_name}.json")
            
            if not os.path.exists(preset_file):
                # Load from default presets
                default_presets = self.get_default_presets()
                if self.preset_name in default_presets:
                    preset_data = default_presets[self.preset_name]
                else:
                    self.report({'ERROR'}, f"Preset not found: {self.preset_name}")
                    return {'CANCELLED'}
            else:
                with open(preset_file, 'r') as f:
                    preset_data = json.load(f)
            
            # Apply preset data
            props = context.scene.scenex
            for key, value in preset_data.items():
                if hasattr(props, key):
                    if key == "material_color":
                        setattr(props, key, tuple(value))
                    else:
                        setattr(props, key, value)
            
            self.report({'INFO'}, f"Loaded preset: {self.preset_name}")
            return {'FINISHED'}
            
        except Exception as e:
            logger.error(f"Error loading preset: {str(e)}")
            self.report({'ERROR'}, str(e))
            return {'CANCELLED'}
    
    def get_default_presets(self):
        """Get built-in default presets"""
        return {
            "basic_fade": {
                "animation_type": "FADE_IN",
                "animation_duration": 30,
                "rate_function": "SMOOTH"
            },
            "dramatic_entrance": {
                "animation_type": "GROW_FROM_CENTER",
                "animation_duration": 45,
                "rate_function": "EXPONENTIAL"
            },
            "camera_overview": {
                "camera_movement": "ORBIT",
                "camera_target_distance": 15.0
            },
            "camera_closeup": {
                "camera_movement": "DOLLY",
                "camera_target_distance": 5.0
            },
            "glass_material": {
                "material_type": "GLASS",
                "material_color": [0.9, 0.9, 1.0, 0.2]
            },
            "metallic_material": {
                "material_type": "METALLIC",
                "material_color": [0.8, 0.8, 0.8, 1.0]
            }
        }

# Register/unregister preset system
classes = (
    SCENEX_MT_PresetMenu,
    SCENEX_OT_SavePreset,
    SCENEX_OT_LoadPreset,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    print("SceneX Preset System registered")

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    print("SceneX Preset System unregistered")


==================================================

File: SceneX/docs/contributing.md
Contents:
# Contributing Guide

[Contributing guidelines...]

==================================================

File: SceneX/docs/quickstart.md
Contents:
# SceneX Documentation

## Overview
SceneX is a Blender animation framework inspired by Manim, designed for creating educational and technical animations. It provides high-level abstractions for geometry, animations, and scene composition.

## Quick Start

```python
from src.core.scene import Scene
from src.geometry.shapes import Circle, Square
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig
from mathutils import Vector

class MyFirstScene(Scene):
    def construct(self):
        # Create shapes
        circle = Circle(radius=0.5).create()
        square = Square(size=1.0).create()

        # Position objects
        self.coordinate_system.place_object(circle, Vector((-1, 0, 0)))
        self.coordinate_system.place_object(square, Vector((1, 0, 0)))

        # Animate
        config = AnimationConfig(duration=30)
        self.play(FadeInFrom(circle, Vector((0, -1, 0)), config=config))

# Run the scene
scene = MyFirstScene()
scene.construct()
```

## Core Components

### 1. Geometry System
- Basic Shapes: Circle, Square, Rectangle, Line
- Complex Shapes: Arrow, Arc, Star
- Text and LaTeX Support
- SVG Import

Example:
```python
# Creating shapes
circle = Circle(radius=0.5, color=(1, 0, 0, 1)).create()
arrow = Arrow(start=(-1, 0, 0), end=(1, 0, 0)).create()

# Text creation
text = Text("Hello World", size=1.0).create()
```

### 2. Animation System
- Basic Animations: FadeIn, FadeOut, Rotate
- Transform Animations
- Animation Sequences and Groups
- Custom Rate Functions

Example:
```python
# Single animation
self.play(FadeInFrom(circle, Vector((0, -1, 0)), config))

# Animation sequence
sequence = AnimationSequence(
    FadeInFrom(circle, Vector((0, -1, 0)), config),
    Rotate(circle, config)
)
self.play(sequence)
```

### 3. Scene Composition
- Object Groups
- Layout Management
- Camera Control
- Grid System

Example:
```python
# Create and manage groups
group = Group("shapes").add(circle, square)
layout = Layout()
layout.arrange(group.get_all_objects(), LayoutType.HORIZONTAL)

# Camera movement
camera_movement = CameraMovement(self.camera)
camera_movement.frame_object(group)
```

## Advanced Features

### 1. Rate Functions
Available rate functions for animations:
- LINEAR
- SMOOTH
- RUSH_INTO
- RUSH_FROM
- EASE_IN
- EASE_OUT
- EXPONENTIAL
- ELASTIC
- BOUNCE
- BACK

### 2. Layout Types
Available layout arrangements:
- HORIZONTAL
- VERTICAL
- GRID
- CIRCULAR
- SPIRAL

### 3. Camera Movements
- Dolly (forward/backward)
- Orbit
- Frame objects
- Fly to position

## Best Practices

1. Scene Organization
```python
class WellOrganizedScene(Scene):
    def construct(self):
        # Setup
        self.setup_objects()
        
        # Animations
        self.animate_sequence()
        
        # Cleanup
        self.cleanup()
        
    def setup_objects(self):
        # Create and position objects
        pass
        
    def animate_sequence(self):
        # Define animation sequence
        pass
        
    def cleanup(self):
        # Cleanup code
        pass
```

2. Object Naming
```python
# Good practice
main_circle = Circle(radius=0.5).create()
main_circle.name = "main_circle"

# Group related objects
equation_group = Group("equation")
equation_group.add(symbol1, symbol2, equals_sign)
```

3. Animation Timing
```python
# Use consistent timing
standard_duration = 30
quick_duration = 15
slow_duration = 60

config = AnimationConfig(duration=standard_duration)
```

## Common Patterns

1. Creating Technical Diagrams
```python
def create_technical_diagram():
    # Create components
    components = [
        Square(size=1.0).create(),
        Circle(radius=0.5).create(),
        Arrow(start=(0,0), end=(1,1)).create()
    ]
    
    # Arrange components
    layout = Layout()
    layout.arrange(components, LayoutType.HORIZONTAL)
    
    # Add labels
    labels = [
        Text("Component A").create(),
        Text("Component B").create()
    ]
    
    return components, labels
```

2. Educational Animations
```python
def create_math_animation():
    # Create equation
    equation = LaTeXText("E = mc^2").create()
    
    # Highlight parts
    self.play(
        FadeInFrom(equation, Vector((0, -1, 0)), config),
        FlashAround(equation, color=(1, 1, 0))
    )
```

## Troubleshooting

Common issues and solutions:
1. Object not visible: Check material settings and camera position
2. Animation not playing: Verify frame ranges and animation configuration
3. Layout issues: Check object dimensions and spacing parameters

## Contributing

Guidelines for contributing:
1. Follow PEP 8 style guide
2. Add unit tests for new features
3. Update documentation
4. Use type hints
5. Follow existing patterns

==================================================

File: SceneX/docs/reference/animations.md
Contents:
# Animation System Reference

## Animation Base Class

[Base class documentation...]

## Animation Types

[Animation types reference...]

==================================================

File: SceneX/docs/reference/scene.md
Contents:
# Scene Management Reference

## Scene Class

[Scene class documentation...]

## Scene Methods

[Method documentation...]

==================================================

File: SceneX/docs/reference/camera.md
Contents:
# Camera System Reference

## Camera Configuration

[Configuration documentation...]

## Camera Methods

[Method documentation...]

==================================================

File: SceneX/docs/reference/geometry.md
Contents:
# Geometry System Reference

## Classes

[Class documentation...]

## Methods

[Method documentation...]

==================================================

File: SceneX/docs/tutorials/shapes.md
Contents:
# Geometric Shapes

## Basic Shapes

[Basic shapes documentation...]

## Complex Shapes

[Complex shapes guide...]

==================================================

File: SceneX/docs/tutorials/animations.md
Contents:
# Working with Animations

## Animation Types

[Animation types explanation...]

## Creating Custom Animations

[Custom animation guide...]

==================================================

File: SceneX/docs/tutorials/camera.md
Contents:
# Camera Control

## Camera Setup

[Camera setup guide...]

## Camera Movements

[Camera movement examples...]

==================================================

File: SceneX/docs/tutorials/basic_scene.md
Contents:
# Creating Your First Scene

## Scene Setup

[Scene setup instructions...]

## Basic Objects

[Working with objects...]

## Simple Animations

[Basic animation examples...]

==================================================

File: SceneX/docs/examples/educational.md
Contents:
# Educational Presentation Examples

## Lecture Slides

[Lecture slide examples...]

## Interactive Demonstrations

[Interactive demo examples...]

==================================================

File: SceneX/docs/examples/technical.md
Contents:
# Technical Diagram Examples

## Basic Diagrams

[Basic diagram examples...]

## Complex Systems

[Complex system examples...]

==================================================

File: SceneX/docs/examples/mathematical.md
Contents:
# Mathematical Animation Examples

## Equation Animations

[Equation animation examples...]

## Graph Animations

[Graph animation examples...]

==================================================

File: SceneX/tests/test_mobject.py
Contents:


==================================================

File: SceneX/tests/test_camera.py
Contents:


==================================================

File: SceneX/tests/test_coordinate_system.py
Contents:


==================================================

File: SceneX/tests/example_scenes/14_grid_test.py
Contents:
# SceneX/tests/example_scenes/14_grid_test.py

import bpy
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.scene.grid import GridSystem
from src.geometry.shapes import Circle
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig

class GridTest(Scene):
    def construct(self):
        self.logger.info("Starting grid test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create and setup grid system
        grid = GridSystem()
        grid.create_coordinate_system(
            x_range=(-5, 5),
            y_range=(-5, 5),
            grid_step=1.0,
            show_axes=True,
            show_grid=True,
            show_labels=True,
            axis_color=(1, 1, 1, 1),
            grid_color=(0.2, 0.2, 0.2, 0.5),
            line_width=0.01
        )

        # Create test object
        circle = Circle(radius=0.5).create()
        self.coordinate_system.place_object(circle, Vector((2, 2, 0)))

        # Animate
        config = AnimationConfig(duration=30)
        self.play(FadeInFrom(circle, Vector((0, -1, 0)), config=config))

if __name__ == "__main__":
    scene = GridTest()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/4_geometry_test.py
Contents:
# SceneX/tests/example_scenes/geometry_test.py
import bpy
import mathutils
import math
from src.core.scene import Scene

from src.geometry.shapes import (
    Line, Circle, Rectangle
)

class GeometryTestScene(Scene):
    def construct(self):
        self.logger.info("Starting geometry test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # # Setup timeline (30fps)
        # bpy.context.scene.render.fps = 30
        # bpy.context.scene.frame_start = 1
        # bpy.context.scene.frame_end = 300
        # current_frame = 1

        
        # Create various geometric objects
        # Line
        line = Line((-2, 0, 0), (2, 0, 0), 
                   color=(1, 0, 0, 1),
                   stroke_width=0.05)
        line.create()
        
        # Circle
        circle = Circle(radius=1.0,
                       color=(0, 1, 0, 1),
                       fill_opacity=0.5)
        circle.create()
        circle.align_to_grid(mathutils.Vector((0, 2, 0)))
        
        # Rectangle
        rect = Rectangle(width=2.0, height=1.0,
                        corner_radius=0.2,
                        color=(0, 0, 1, 1))
        rect.create()
        rect.align_to_grid(mathutils.Vector((0, -2, 0)))

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'  # Changed from 'Y' to 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

        # Return to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation showcase completed")

def main():
    try:
        scene = GeometryTestScene()
        scene.construct()
        print("Geometry test completed successfully")
    except Exception as e:
        print(f"Error running geometry test: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/18_Other_physics_simulations_to_be_done.txt
Contents:
Want me to add more physics templates? I can add:

Wave simulation
Fluid dynamics
Particle systems
Cloth simulation

==================================================

File: SceneX/tests/example_scenes/15_layout_test.py
Contents:
# SceneX/tests/example_scenes/15_layout_test.py

import bpy
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.geometry.shapes import Circle, Square
from src.scene.layout import Layout, LayoutType
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig

class LayoutTest(Scene):
    def construct(self):
        self.logger.info("Starting layout test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create test objects
        shapes = []
        for i in range(9):
            if i % 2 == 0:
                obj = Circle(radius=0.3).create()
            else:
                obj = Square(size=0.6).create()
            shapes.append(obj)

        # Test different layouts
        layout = Layout()
        
        # Test horizontal layout
        layout.arrange(shapes[:3], LayoutType.HORIZONTAL, 
                      spacing=1.0, center=Vector((0, 2, 0)))

        # Test vertical layout
        layout.arrange(shapes[3:6], LayoutType.VERTICAL, 
                      spacing=1.0, center=Vector((-2, 0, 0)))

        # Test grid layout
        layout.arrange(shapes[6:], LayoutType.GRID, 
                      spacing=1.0, center=Vector((2, 0, 0)), columns=2)

        # Animate
        config = AnimationConfig(duration=30)
        for obj in shapes:
            self.play(FadeInFrom(obj, Vector((0, -1, 0)), config=config))

if __name__ == "__main__":
    scene = LayoutTest()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/1_basic_scene_1_placing_mobjects__test.py
Contents:
# SceneX/tests/example_scenes/basic_scene.py
import bpy
import mathutils
from src.core.scene import Scene
from src.core.mobject import Mobject

class BasicTestScene(Scene):
    def construct(self):
        self.logger.info("Starting basic test scene construction")
        
        # Setup the scene first
        self.setup()
        
        # Create basic shapes
        self.logger.info("Creating shapes")
        cube = self.create_cube(size=1.0, location=(-2, 0, 0))
        if cube:
            self.logger.info("Cube created successfully")
        else:
            self.logger.error("Failed to create cube")
            return

        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        if sphere:
            self.logger.info("Sphere created successfully")
        else:
            self.logger.error("Failed to create sphere")
            return

        # Test coordinate system
        self.logger.info("Testing coordinate system placement")
        self.coordinate_system.place_object(cube, mathutils.Vector((-2, 0, 0)))
        self.coordinate_system.place_object(sphere, mathutils.Vector((2, 0, 0)))
        
        # Test camera
        self.logger.info("Testing camera framing")
        self.camera.frame_point(mathutils.Vector((0, 0, 0)))
        
        self.logger.info("Scene construction completed")

def main():
    try:
        # Create and run the test scene
        scene = BasicTestScene()
        scene.construct()
        print("Test scene completed successfully")
        
    except Exception as e:
        print(f"Error running test scene: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/21_scenex_ai_setup_1test.py
Contents:
import os
import json
import shutil
from pathlib import Path
from typing import Dict, Any

class SceneXAISetup:
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.ai_path = self.base_path / "src" / "ai"

    def setup_directory(self):
        """Create the complete AI directory structure"""
        try:
            # Create main directories
            directories = [
                "frontend/src/components",
                "frontend/src/hooks",
                "frontend/src/styles",
                "backend/api",
                "backend/services",
                "backend/utils",
                "core/generators",
                "core/processors",
                "core/models",
                "core/llm",
                "data/components",
                "data/presets",
                "data/relationships",
                "config",
                "tests"
            ]

            # Create all directories
            for dir_path in directories:
                full_path = self.ai_path / dir_path
                full_path.mkdir(parents=True, exist_ok=True)
                # Create __init__.py for Python packages
                if not dir_path.startswith("frontend"):
                    init_file = full_path / "__init__.py"
                    init_file.touch()

            # Create and populate files
            self._create_frontend_files()
            self._create_backend_files()
            self._create_core_files()
            self._create_data_files()
            self._create_config_files()
            self._create_test_files()

            print("SceneX AI directory structure created successfully!")

        except Exception as e:
            print(f"Error creating directory structure: {str(e)}")
            raise

    def _write_file(self, path: Path, content: str):
        """Write content to file, creating directories if needed"""
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding='utf-8')

    def _create_frontend_files(self):
        """Create frontend configuration and component files"""
        # package.json
        package_json = {
            "name": "scenex-ai-frontend",
            "private": True,
            "version": "0.1.0",
            "type": "module",
            "scripts": {
                "dev": "vite",
                "build": "tsc && vite build",
                "preview": "vite preview"
            },
            "dependencies": {
                "@radix-ui/react-alert-dialog": "^1.0.5",
                "@radix-ui/react-slot": "^1.0.2",
                "class-variance-authority": "^0.7.0",
                "clsx": "^2.0.0",
                "lucide-react": "^0.263.1",
                "react": "^18.2.0",
                "react-dom": "^18.2.0",
                "tailwind-merge": "^2.0.0",
                "tailwindcss-animate": "^1.0.7"
            },
            "devDependencies": {
                "@types/node": "^20.8.2",
                "@types/react": "^18.2.25",
                "@types/react-dom": "^18.2.10",
                "@vitejs/plugin-react": "^4.1.0",
                "autoprefixer": "^10.4.16",
                "postcss": "^8.4.31",
                "tailwindcss": "^3.3.3",
                "typescript": "^5.2.2",
                "vite": "^4.4.11"
            }
        }
        
        package_json_path = self.ai_path / "frontend" / "package.json"
        self._write_file(package_json_path, json.dumps(package_json, indent=2))

        # Create other frontend files
        frontend_files = {
            "vite.config.js": '''
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})''',
            "tsconfig.json": '''
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}''',
            "src/styles/globals.css": '''
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}''',
            "src/components/AISceneGenerator.tsx": '''
import React, { useState } from 'react';
import { Send, Loader2 } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';

const AISceneGenerator = () => {
  const [loading, setLoading] = useState(false);
  const [prompt, setPrompt] = useState('');

  const handleSubmit = async () => {
    setLoading(true);
    try {
      // Call backend API
      const response = await fetch('/api/generate-scene', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt })
      });
      
      const data = await response.json();
      // Handle response
    } catch (error) {
      console.error('Error:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-4xl mx-auto">
      <CardHeader>
        <CardTitle>AI Scene Generator</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <textarea
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          className="w-full h-32 p-2 border rounded-lg"
          placeholder="Describe your scene..."
        />
        <button
          onClick={handleSubmit}
          disabled={loading}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg"
        >
          {loading ? <Loader2 className="animate-spin" /> : <Send />}
          Generate Scene
        </button>
      </CardContent>
    </Card>
  );
};

export default AISceneGenerator;'''
        }

        for file_path, content in frontend_files.items():
            full_path = self.ai_path / "frontend" / file_path
            self._write_file(full_path, content.strip())

    def _create_backend_files(self):
        """Create backend API and service files"""
        backend_files = {
            "api/routes.py": '''
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional, Dict
from ..core.processors.prompt_processor import PromptProcessor
from ..core.generators.scene_generator import SceneGenerator
from ...utils.logger import SceneXLogger

app = FastAPI()
logger = SceneXLogger("SceneXAPI")

class SceneRequest(BaseModel):
    prompt: str
    options: Optional[Dict] = None

@app.post("/api/generate-scene")
async def generate_scene(request: SceneRequest):
    try:
        processor = PromptProcessor()
        scene_data = processor.process_prompt(request.prompt)
        
        generator = SceneGenerator()
        scene = generator.generate_scene(scene_data)
        
        return {"status": "success", "data": scene}
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
'''
        }

        for file_path, content in backend_files.items():
            full_path = self.ai_path / "backend" / file_path
            self._write_file(full_path, content.strip())

    def _create_core_files(self):
        """Create core functionality files"""
        core_files = {
            "llm/claude_client.py": '''
import anthropic
from typing import Dict
from ...utils.logger import SceneXLogger

class ClaudeClient:
    def __init__(self):
        self.client = anthropic.Client()
        self.logger = SceneXLogger("ClaudeClient")
    
    async def process_architecture(self, prompt: str) -> Dict:
        try:
            response = await self.client.messages.create(
                model="claude-3-sonnet-20240229",
                max_tokens=1000,
                messages=[{"role": "user", "content": prompt}]
            )
            return self._parse_response(response.content)
        except Exception as e:
            self.logger.error(f"Claude error: {str(e)}")
            raise
''',
            "generators/scene_generator.py": '''
import bpy
from typing import Dict
from ...utils.logger import SceneXLogger

class SceneGenerator:
    def __init__(self):
        self.logger = SceneXLogger("SceneGenerator")
    
    def generate_scene(self, scene_data: Dict):
        try:
            # Create scene elements
            for component in scene_data["components"]:
                self._create_component(component)
                
            return {"status": "success"}
        except Exception as e:
            self.logger.error(f"Error: {str(e)}")
            raise
'''
        }

        for file_path, content in core_files.items():
            full_path = self.ai_path / "core" / file_path
            self._write_file(full_path, content.strip())

    def _create_data_files(self):
        """Create data definition files"""
        data_files = {
            "components/aws_components.py": '''
AWS_COMPONENTS = {
    "lambda": {
        "shape": "Rectangle",
        "color": (0.9, 0.5, 0.1, 1.0),
        "label": "Lambda",
        "category": "compute"
    },
    "s3": {
        "shape": "Square",
        "color": (0.5, 0.2, 0.9, 1.0),
        "label": "S3",
        "category": "storage"
    }
}'''
        }

        for file_path, content in data_files.items():
            full_path = self.ai_path / "data" / file_path
            self._write_file(full_path, content.strip())

    def _create_config_files(self):
        """Create configuration files"""
        config_files = {
            "settings.py": '''
# API Configuration
CLAUDE_API_KEY = "your_api_key_here"
API_ENDPOINT = "http://localhost:8000"

# Scene Generation Settings
DEFAULT_SCENE_CONFIG = {
    "grid_size": 10,
    "spacing": 2.0,
    "animation_duration": 30
}'''
        }

        for file_path, content in config_files.items():
            full_path = self.ai_path / "config" / file_path
            self._write_file(full_path, content.strip())

    def _create_test_files(self):
        """Create test files"""
        test_files = {
            "test_integration.py": '''
import asyncio
import unittest
from ..core.llm.claude_client import ClaudeClient
from ..core.generators.scene_generator import SceneGenerator

class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.claude = ClaudeClient()
        self.generator = SceneGenerator()
    
    async def test_basic_scene(self):
        prompt = "Create a serverless API with Lambda and API Gateway"
        architecture = await self.claude.process_architecture(prompt)
        self.assertIn("components", architecture)
        
        scene = self.generator.generate_scene(architecture)
        self.assertIsNotNone(scene)

if __name__ == '__main__':
    unittest.main()'''
        }

        for file_path, content in test_files.items():
            full_path = self.ai_path / "tests" / file_path
            self._write_file(full_path, content.strip())


# Usage
if __name__ == "__main__":
    # Get the path to the Blender addons directory
    blender_addons_path = os.path.expanduser("~\\AppData\\Roaming\\Blender Foundation\\Blender\\4.2\\scripts\\addons\\SceneX")
    
    try:
        setup = SceneXAISetup(blender_addons_path)
        setup.setup_directory()
    except Exception as e:
        print(f"Setup failed: {str(e)}")

==================================================

File: SceneX/tests/example_scenes/8_latex-1-test.py
Contents:
import bpy
import math
from mathutils import Vector
from src.core.scene import Scene
from src.text.text_support import LaTeXText
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig


class LaTeXTestScene(Scene):
    def construct(self):
        self.logger.info("Starting materials test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        # bpy.ops.object.camera_add(location=(7, -7, 5))
        # camera = bpy.context.active_object
        # camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        bpy.ops.object.camera_add(location=(0, -10, 5))  # Move back for better view
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(30), 0, 0)  # Less steep angle
        
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # LaTeX Equations (Corrected for Matplotlib)
        equations = [
            ("Einstein", "E = mc^2"),
            ("Gaussian Integral", "\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}"),
            ("Matrix Form", "\\\\left( \\begin{matrix} a & b \\\\ c & d \\end{matrix} \\\\right)"),
            ("Summation", "\\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6}")
        ]

        tex_objects = []
        for name, tex in equations:
            obj = LaTeXText(tex=tex, size=1.2, color=(1, 1, 1, 1)).create()
            if obj:
                self.logger.info(f"LaTeX object created for {name}")
                tex_objects.append(obj)
            else:
                self.logger.error(f"Failed to create LaTeX object for {name}")

        # Positioning and Animation
        spacing = 1.5
        for i, obj in enumerate(tex_objects):
            obj.location = Vector((0, 2 - i * spacing, 0))

        # Fade-In Animation
        config = AnimationConfig(duration=30)
        for obj in tex_objects:
            self.play(FadeInFrom(obj, direction=Vector((-1, 0, 0)), config=config))

        # Render to File
        bpy.context.scene.render.filepath = "C:/Users/ernes/Desktop/latex_render.png"
        bpy.ops.render.render(write_still=True)


if __name__ == "__main__":
    scene = LaTeXTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/1_basic_scene_4_camera_animation_test.py
Contents:
# SceneX/tests/example_scenes/basic_scene_3_add_camera.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.core.coordinate_system import GridConfig
from src.camera.camera import CameraConfig, CameraSystem

class BasicTestScene(Scene):
    def construct(self):
        self.logger.info("Starting basic test scene construction")
        
        # Setup scene
        self.setup()
        
        # Configure camera
        self.camera = CameraSystem(CameraConfig(
            distance=15.0,
            angle=45.0
        ))
        
        # Set initial camera position and keyframe
        initial_pos = mathutils.Vector((0, -15, 15))
        self.camera.camera.location = initial_pos
        self.camera.camera.keyframe_insert(data_path="location", frame=1)
        self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=1)
        
        # Create coordinate system with grid
        self.coordinate_system.create_grid(GridConfig(
            x_range=(-5, 5),
            y_range=(-3, 3),
            line_thickness=0.02
        ))
        
        # Create shapes
        cube = self.create_cube(size=0.5, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.25, location=(2, 0, 0))
        
        # Place objects
        self.coordinate_system.place_object(cube, mathutils.Vector((-2, 1, 0)))
        self.coordinate_system.place_object(sphere, mathutils.Vector((2, -1, 0)))
        
        # Setup timeline
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 250
        current_frame = 1

        # Animation sequence

        # Move 1: Initial position to front view (frames 1-50)
        current_frame = 1
        self.camera.camera.location = initial_pos
        self.camera.camera.keyframe_insert(data_path="location", frame=current_frame)
        self.camera.camera.rotation_euler = (math.radians(45), 0, 0)
        self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=current_frame)

        current_frame = 50
        front_pos = mathutils.Vector((0, -8, 8))
        self.camera.camera.location = front_pos
        self.camera.camera.keyframe_insert(data_path="location", frame=current_frame)
        self.camera.camera.rotation_euler = (math.radians(45), 0, 0)
        self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=current_frame)

        # Move 2: Circle around scene (frames 50-150)
        for frame in range(50, 151, 10):
            angle = (frame - 50) * (2 * math.pi) / 100  # Full rotation over 100 frames
            radius = 10
            x = radius * math.sin(angle)
            y = -radius * math.cos(angle)
            z = 8
            
            self.camera.camera.location = mathutils.Vector((x, y, z))
            self.camera.camera.keyframe_insert(data_path="location", frame=frame)
            
            # Point camera at center
            direction = -self.camera.camera.location.normalized()
            rot_quat = direction.to_track_quat('-Z', 'Y')
            self.camera.camera.rotation_euler = rot_quat.to_euler()
            self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=frame)

        # Move 3: Pull back (frames 150-200)
        current_frame = 200
        back_pos = mathutils.Vector((0, -15, 15))
        self.camera.camera.location = back_pos
        self.camera.camera.keyframe_insert(data_path="location", frame=current_frame)
        self.camera.camera.rotation_euler = (math.radians(45), 0, 0)
        self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=current_frame)

        # Move 4: Side view (frames 200-250)
        current_frame = 250
        side_pos = mathutils.Vector((15, 0, 5))
        self.camera.camera.location = side_pos
        self.camera.camera.keyframe_insert(data_path="location", frame=current_frame)
        self.camera.camera.rotation_euler = (math.radians(15), math.radians(90), 0)
        self.camera.camera.keyframe_insert(data_path="rotation_euler", frame=current_frame)

        # Set smooth interpolation for all keyframes
        if self.camera.camera.animation_data and self.camera.camera.animation_data.action:
            for fc in self.camera.camera.animation_data.action.fcurves:
                for kf in fc.keyframe_points:
                    kf.interpolation = 'BEZIER'
                    kf.easing = 'EASE_IN_OUT'

        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.region_3d.view_perspective = 'CAMERA'
                        space.lock_camera = True  # Lock camera to view

        # Set current frame to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Scene construction completed")

def main():
    try:
        # Create and run the test scene
        scene = BasicTestScene()
        scene.construct()
        print("Test scene completed successfully")
        
        # Start animation playback
        bpy.ops.screen.animation_play()
        
    except Exception as e:
        print(f"Error running test scene: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/2_animation_test_scene_4_commonly_used_animations_test copy.py
Contents:
# SceneX/tests/example_scenes/animation_test_scene.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.transform import Transform, FadeIn, FadeOut, Scale
from src.animation.base import AnimationConfig

# At the top of your test scene file
from src.animation.commonly_used_animations import (
    GrowFromCenter, GrowFromPoint, Write, 
    FadeInFrom, Rotate, FlashAround
)

class AnimationTestScene(Scene):
    def construct(self):
        self.logger.info("Starting animation test scene")
        
        # Clear scene and setup render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine and settings for Blender 4.2
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'  # Updated from BLENDER_EEVEE
        if hasattr(bpy.context.scene.eevee, "use_ssr"):  # Handle EEVEE Next settings
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
               
        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True
        
        # Create objects with initial materials
        cube = self.create_cube(size=1.0, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        
        # Setup initial materials with colors
        for obj, color in [(cube, (0.2, 0.4, 0.8, 1.0)), (sphere, (0.8, 0.2, 0.2, 1.0))]:
            mat = bpy.data.materials.new(name=f"{obj.name}_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            principled = mat.node_tree.nodes["Principled BSDF"]
            principled.inputs["Base Color"].default_value = color
            if obj.data.materials:
                obj.data.materials[0] = mat
            else:
                obj.data.materials.append(mat)
        
        # Setup timeline (30fps)
        bpy.context.scene.render.fps = 30
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1
                
        # Test GrowFromCenter
        cube = self.create_cube(size=1.0)
        grow = GrowFromCenter(cube, AnimationConfig(duration=30))
        current_frame = grow.create_animation(1)
        
        # Test FadeInFrom
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        fade_in = FadeInFrom(sphere, mathutils.Vector((-1, 0, 0)), 
                           config=AnimationConfig(duration=30))
        current_frame = fade_in.create_animation(current_frame + 10)
        
        # Test Write
        text = self.create_text("Hello", location=(0, 2, 0))
        write = Write(text, AnimationConfig(duration=60))
        current_frame = write.create_animation(current_frame + 10)
        
        # Test Rotate
        rotate = Rotate(cube, math.radians(360), 'Z', 
                      AnimationConfig(duration=60))
        current_frame = rotate.create_animation(current_frame + 10)
        
        # Test FlashAround
        flash = FlashAround(sphere, config=AnimationConfig(duration=30))
        current_frame = flash.create_animation(current_frame + 10)

        # Set up camera
        bpy.ops.object.camera_add(location=(5, -5, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(60), 0, math.radians(45))
        bpy.context.scene.camera = camera
        
        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
        
        # Set current frame to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation test scene completed")

def main():
    try:
        scene = AnimationTestScene()
        scene.construct()
        print("Animation test scene completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation test: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/2_animation_test_scene_3_fade_integrated_test.py
Contents:
# SceneX/tests/example_scenes/animation_test_scene.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.transform import Transform, FadeIn, FadeOut, Scale
from src.animation.base import AnimationConfig

class AnimationTestScene(Scene):
    def construct(self):
        self.logger.info("Starting animation test scene")
        
        # Clear scene and setup render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine and settings for Blender 4.2
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'  # Updated from BLENDER_EEVEE
        if hasattr(bpy.context.scene.eevee, "use_ssr"):  # Handle EEVEE Next settings
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
               
        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True
        
        # Create objects with initial materials
        cube = self.create_cube(size=1.0, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        
        # Setup initial materials with colors
        for obj, color in [(cube, (0.2, 0.4, 0.8, 1.0)), (sphere, (0.8, 0.2, 0.2, 1.0))]:
            mat = bpy.data.materials.new(name=f"{obj.name}_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            principled = mat.node_tree.nodes["Principled BSDF"]
            principled.inputs["Base Color"].default_value = color
            if obj.data.materials:
                obj.data.materials[0] = mat
            else:
                obj.data.materials.append(mat)
        
        # Setup timeline (30fps)
        bpy.context.scene.render.fps = 30
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1
        
        # Animation sequence
        # Fade In (2 seconds)
        fade_in_config = AnimationConfig(duration=60)
        fade_in1 = FadeIn(cube, fade_in_config)
        fade_in2 = FadeIn(sphere, fade_in_config)
        current_frame = fade_in1.create_animation(current_frame)
        current_frame = fade_in2.create_animation(current_frame)
        
        # Transform and scale during full visibility (4 seconds)
        current_frame += 30  # Small pause after fade in
        
        transform_config = AnimationConfig(duration=120)
        end_state = {
            "location": mathutils.Vector((2, 2, 2)),
            "rotation": mathutils.Euler((math.radians(45), 0, 0)),
            "scale": mathutils.Vector((2, 2, 2))
        }
        transform = Transform(cube, end_state, transform_config)
        current_frame = transform.create_animation(current_frame)
        
        scale = Scale(sphere, 2.0, transform_config)
        current_frame = scale.create_animation(current_frame)
        
        # Fade Out (2 seconds)
        current_frame += 30  # Small pause before fade out
        fade_out_config = AnimationConfig(duration=60)
        fade_out1 = FadeOut(cube, fade_out_config)
        fade_out2 = FadeOut(sphere, fade_out_config)
        current_frame = fade_out1.create_animation(current_frame)
        current_frame = fade_out2.create_animation(current_frame)
        
        # Set up camera
        bpy.ops.object.camera_add(location=(5, -5, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(60), 0, math.radians(45))
        bpy.context.scene.camera = camera
        
        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
        
        # Set current frame to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation test scene completed")

def main():
    try:
        scene = AnimationTestScene()
        scene.construct()
        print("Animation test scene completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation test: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/7_text_latex_test.py
Contents:
# SceneX/tests/example_scenes/7_text_test.py

import bpy
import math
from mathutils import Vector
from src.core.scene import Scene
from src.text.text_support import Text
from src.animation.commonly_used_animations import Write, FadeInFrom
from src.animation.base import AnimationConfig

class TextTestScene(Scene):
    def construct(self):
        self.logger.info("Starting text test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create text objects
        title = Text("SceneX Demo", size=1.0, 
                    color=(1, 1, 1, 1)).create()
        
        subtitle = Text("Math & Physics", size=0.6,
                       color=(0.2, 0.8, 1, 1)).create()

        # Position objects
        self.coordinate_system.place_object(title, Vector((0, 2, 0)))
        self.coordinate_system.place_object(subtitle, Vector((0, 1, 0)))

        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

        # Set frame range
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 100
        bpy.context.scene.frame_current = 1

        # Create animations
        config = AnimationConfig(duration=50)
        
        animations = [
            Write(title, config=config),
            Write(subtitle, config=config)
        ]

        # Create keyframes
        current_frame = 1
        for anim in animations:
            start_frame = current_frame
            end_frame = start_frame + anim.config.duration
            anim.create_animation(start_frame)
            current_frame = end_frame

if __name__ == "__main__":
    scene = TextTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/11_animation_sequence_test.py
Contents:
# SceneX/tests/example_scenes/11_animation_sequence_test.py

import bpy
import math
from mathutils import Vector
from src.core.scene import Scene

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.geometry.shapes import Circle, Square
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.sequence import AnimationSequence, AnimationGroup, Succession
from src.animation.base import AnimationConfig

class AnimationSequenceTest(Scene):
    def construct(self):
        self.logger.info("Starting animation sequence test")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0


        # Create objects
        circle = Circle(radius=0.5).create()
        square = Square(size=1.0).create()
        objects = [circle, square]

        # Position objects
        self.coordinate_system.place_object(circle, Vector((-2, 0, 0)))
        self.coordinate_system.place_object(square, Vector((2, 0, 0)))

        config = AnimationConfig(duration=30)

        # Test sequence
        sequence = AnimationSequence(
            FadeInFrom(circle, Vector((0, -1, 0)), config=config),
            Rotate(circle, config=config),
            FadeInFrom(square, Vector((0, -1, 0)), config=config),
            Rotate(square, config=config)
        )

        # Test group (parallel)
        group = AnimationGroup(
            FadeInFrom(circle, Vector((1, 0, 0)), config=config),
            FadeInFrom(square, Vector((-1, 0, 0)), config=config)
        )

        # Test succession
        succession = Succession(
            FadeInFrom(circle, Vector((0, 1, 0)), config=config),
            Rotate(circle, config=config),
            FadeInFrom(square, Vector((0, 1, 0)), config=config)
        )

        # Play animations
        self.play(sequence)
        self.play(group)
        self.play(succession)

if __name__ == "__main__":
    scene = AnimationSequenceTest()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/17_template_tests.py
Contents:
# SceneX/tests/example_scenes/17_template_tests.py


# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.templates.technical import TechnicalDiagramScene
from src.templates.mathematical import MathematicalScene
from src.templates.educational import PresentationScene
from mathutils import Vector

class NetworkDiagram(TechnicalDiagramScene):
    def construct(self):
        # Create network components
        server = self.add_component("square", Vector((0, 2, 0)), "Server")
        client1 = self.add_component("circle", Vector((-2, 0, 0)), "Client 1")
        client2 = self.add_component("circle", Vector((2, 0, 0)), "Client 2")
        
        # Add connections
        self.connect_components(client1, server)
        self.connect_components(client2, server)
        
        # Animate
        self.animate_diagram()

class EquationDerivation(MathematicalScene):
    def construct(self):
        # Create equations
        eq1 = self.add_equation("E = mc^2", Vector((0, 2, 0)))
        eq2 = self.add_equation("F = ma", Vector((0, 0, 0)))
        eq3 = self.add_equation("PV = nRT", Vector((0, -2, 0)))
        
        # Animate
        self.animate_derivation()

class PhysicsLesson(PresentationScene):
    def construct(self):
        # Create slides
        self.add_slide("Newton's Laws", [
            "1. An object will remain at rest or in uniform motion unless acted upon by a force",
            "2. F = ma",
            "3. Every action has an equal and opposite reaction"
        ])
        
        self.add_slide("Conservation Laws", [
            "- Conservation of Energy",
            "- Conservation of Momentum",
            "- Conservation of Angular Momentum"
        ])
        
        # Animate presentation
        self.next_slide()

if __name__ == "__main__":
    # Test each template
    network = NetworkDiagram()
    network.construct()
    
    math = EquationDerivation()
    math.construct()
    
    lesson = PhysicsLesson()
    lesson.construct()

==================================================

File: SceneX/tests/example_scenes/6_materials_test copy.py
Contents:
# tests/example_scenes/6_materials_test.py

import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle
from src.geometry.complex_shapes import Star
from src.materials.material import Material, MaterialConfig, MaterialType
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.material_animations import MaterialAnimation, EmissionAnimation
from src.animation.base import AnimationConfig



class MaterialTestScene(Scene):
    def setup_scene(self):
        """Setup scene, camera, and lighting"""
        # Clear existing scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        
        # Setup render settings
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        bpy.context.scene.eevee.use_bloom = True
        bpy.context.scene.eevee.bloom_intensity = 1.0

        # Set up lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        sun.rotation_euler = (math.radians(45), math.radians(45), 0)
        
        # Add fill light
        bpy.ops.object.light_add(type='AREA', location=(-5, -5, 5))
        fill = bpy.context.active_object
        fill.data.energy = 200.0
        fill.rotation_euler = (math.radians(-45), 0, math.radians(-135))

        # Setup camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Setup camera constraints
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Set viewport shading
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].shading.type = 'RENDERED'
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

    def setup_basic_material(self, name, color):
        """Create a basic material with Principled BSDF"""
        mat = bpy.data.materials.new(name=name)
        mat.use_nodes = True
        
        # Clear existing nodes
        nodes = mat.node_tree.nodes
        nodes.clear()
        
        # Create new nodes
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        principled.inputs['Base Color'].default_value = color
        principled.name = "Principled BSDF"  # Explicitly set name
        
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Link nodes
        mat.node_tree.links.new(principled.outputs[0], output.inputs[0])
        
        return mat

    def setup_materials(self):
        """Setup all materials with proper nodes"""
        materials = {}
        
        # Basic material
        materials['basic'] = self.setup_basic_material("basic", (1, 0, 0, 1))
        
        # Glass material
        glass_mat = bpy.data.materials.new(name="glass")
        glass_mat.use_nodes = True
        glass_mat.blend_method = 'BLEND'
        glass_mat.use_screen_refraction = True
        glass_mat.use_backface_culling = False
        
        nodes = glass_mat.node_tree.nodes
        nodes.clear()
        glass_bsdf = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        glass_mat.node_tree.links.new(glass_bsdf.outputs[0], output.inputs[0])
        glass_bsdf.inputs["Color"].default_value = (0.8, 0.9, 1, 1)
        glass_bsdf.inputs["IOR"].default_value = 1.45
        materials['glass'] = glass_mat
        
        # Emission material
        emission_mat = bpy.data.materials.new(name="emission")
        emission_mat.use_nodes = True
        nodes = emission_mat.node_tree.nodes
        nodes.clear()
        
        emission = nodes.new('ShaderNodeEmission')
        emission.name = "Emission"  # Important for animation
        output = nodes.new('ShaderNodeOutputMaterial')
        emission_mat.node_tree.links.new(emission.outputs[0], output.inputs[0])
        emission.inputs["Color"].default_value = (0, 1, 0, 1)
        emission.inputs["Strength"].default_value = 1.0
        materials['emission'] = emission_mat
        
        # Metallic material
        metallic_mat = self.setup_basic_material("metal", (0.8, 0.8, 0.8, 1))
        principled = metallic_mat.node_tree.nodes["Principled BSDF"]
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = 0.1
        materials['metallic'] = metallic_mat
        
        # Toon material
        toon_mat = self.setup_basic_material("toon", (1, 0, 1, 1))
        materials['toon'] = toon_mat
        
        return materials

    def construct(self):
        self.logger.info("Starting materials test scene")
        
        # Setup scene
        self.setup_scene()
        
        # Create materials
        materials = self.setup_materials()
        
        # Create shapes with materials
        circle1 = Circle(radius=0.7).create()
        circle1.active_material = materials['basic']
        
        circle2 = Circle(radius=0.7).create()
        circle2.active_material = materials['glass']
        
        star = Star(points=5, outer_radius=0.7).create()
        star.active_material = materials['emission']
        
        rect = Rectangle(width=1.4, height=1.4).create()
        rect.active_material = materials['metallic']
        
        circle3 = Circle(radius=0.7).create()
        circle3.active_material = materials['toon']

        # Position objects
        self.coordinate_system.place_object(circle1, Vector((-2, 1, 0)))
        self.coordinate_system.place_object(circle2, Vector((0, 1, 0)))
        self.coordinate_system.place_object(star, Vector((2, 1, 0)))
        self.coordinate_system.place_object(rect, Vector((-1, -1, 0)))
        self.coordinate_system.place_object(circle3, Vector((1, -1, 0)))

        # Setup animation timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1
        
        # Create animations with proper timing
        animations = [
            MaterialAnimation(circle1, (1,0,0,1), (0,1,0,1),
                            config=AnimationConfig(duration=30)),
            FadeInFrom(circle2, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=30)),
            EmissionAnimation(star, 1.0, 10.0,
                            config=AnimationConfig(duration=30, delay_frames=60)),
            FadeInFrom(rect, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=90)),
            Rotate(circle3, angle=math.pi*2,
                  config=AnimationConfig(duration=30, delay_frames=120))
        ]

        # Create keyframes for each animation
        for anim in animations:
            start_frame = current_frame + (anim.config.delay_frames or 0)
            end_frame = start_frame + anim.config.duration
            anim.create_animation(start_frame)
            current_frame = end_frame

        # Set scene frame range
        bpy.context.scene.frame_end = current_frame + 20
        bpy.context.scene.frame_set(1)

if __name__ == "__main__":
    scene = MaterialTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/19_transform_and_snap_test.py
Contents:
# tests/example_scenes/test_transform_and_snap.py

import bpy
import sys
import os
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)



# # Add SceneX to path
# sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from src.core.scene import Scene
from src.animation.transform_between import TransformBetween, MorphBetween
from src.animation.base import AnimationConfig
from src.geometry.snapping import SnapSystem, SmartConnector
from src.animation.commonly_used_animations import FadeInFrom

class TransformTestScene(Scene):
    def __init__(self):
        super().__init__()
        self.snap_system = SnapSystem(grid_size=1.0)
        self.connector = SmartConnector()
        
    def construct(self):
        # Setup scene
        self.setup()
        
        # Create initial shapes
        cube = self.create_cube(size=1.0, location=(-3, 0, 0))
        sphere = self.create_sphere(radius=0.5, location=(3, 0, 0))
        cylinder = self.create_cylinder(radius=0.3, depth=2.0, location=(0, 2, 0))
        
        # Snap objects to grid
        for obj in [cube, sphere, cylinder]:
            self.snap_system.snap_to_grid(obj)
        
        # Create connections
        self.connector.connect_with_type(cube, sphere, 'DIRECT')
        self.connector.connect_with_type(sphere, cylinder, 'ARC')
        
        # Setup transform animation
        config = AnimationConfig(duration=60)
        transform = TransformBetween(cube, sphere, config)
        
        # Create animation sequence
        start_frame = 1
        
        # Fade in objects
        fade_config = AnimationConfig(duration=30)
        self.play(FadeInFrom(cube, Vector((0, 0, 1)), fade_config))
        self.play(FadeInFrom(sphere, Vector((0, 0, 1)), fade_config))
        self.play(FadeInFrom(cylinder, Vector((0, 0, 1)), fade_config))
        
        # Transform animation
        start_frame = 90  # Start after fade-ins
        transform.create_animation(start_frame)
        
        # Update timeline
        bpy.context.scene.frame_end = start_frame + config.duration

def run_test():
    # Clear existing scene
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Create and run test scene
    scene = TransformTestScene()
    scene.construct()

    
    # # Setup scene and render engine
    # bpy.ops.object.select_all(action='SELECT')
    # bpy.ops.object.delete()
    
    # bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
    # if hasattr(bpy.context.scene.eevee, "use_ssr"):
    #     bpy.context.scene.eevee.use_ssr = True
    #     bpy.context.scene.eevee.use_ssr_refraction = True
    
    # # Configure viewport for rendered preview
    # for area in bpy.context.screen.areas:
    #     if area.type == 'VIEW_3D':
    #         for space in area.spaces:
    #             if space.type == 'VIEW_3D':
    #                 space.shading.type = 'RENDERED'
    #                 space.shading.use_scene_lights = True
    #                 space.shading.use_scene_world = True

    # # Set up camera to target origin
    # # bpy.ops.object.camera_add(location=(7, -7, 5))
    # # camera = bpy.context.active_object
    # # camera.rotation_euler = (math.radians(45), 0, math.radians(45))
    
    # bpy.ops.object.camera_add(location=(0, -10, 5))  # Move back for better view
    # camera = bpy.context.active_object
    # camera.rotation_euler = (math.radians(30), 0, 0)  # Less steep angle
    
    
    # # Add Empty at origin as camera target
    # bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
    # target = bpy.context.active_object
    # target.name = "CameraTarget"
    
    # # Add Track To constraint to camera
    # track = camera.constraints.new(type='TRACK_TO')
    # track.target = target
    # track.track_axis = 'TRACK_NEGATIVE_Z'
    # track.up_axis = 'UP_Y'
    
    # bpy.context.scene.camera = camera

    # # Add lighting
    # bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
    # sun = bpy.context.active_object
    # sun.data.energy = 3.0
    
    print("Test scene created successfully")

if __name__ == "__main__":
    run_test()

==================================================

File: SceneX/tests/example_scenes/22_test_integration.py
Contents:
# src/ai/tests/test_integration.py
import asyncio
import bpy
from ..core.llm.claude_client import ClaudeClient
from ..core.generators.scene_generator import SceneGenerator
from ..backend.api.routes import generate_scene
from ...utils.logger import SceneXLogger

class IntegrationTest:
    def __init__(self):
        self.logger = SceneXLogger("IntegrationTest")
        self.claude = ClaudeClient()
        self.generator = SceneGenerator()

    async def test_basic_scene(self):
        """Test basic scene generation flow"""
        try:
            # Test prompt
            prompt = """Create a serverless ML inference API with:
            1. API Gateway for REST endpoint
            2. Lambda function for processing
            3. SageMaker endpoint for ML inference
            4. S3 bucket for storing results"""

            # 1. Test Claude processing
            self.logger.info("Testing Claude processing...")
            architecture = await self.claude.process_architecture(prompt)
            assert "components" in architecture, "Missing components in architecture"
            assert "connections" in architecture, "Missing connections in architecture"

            # 2. Test scene generation
            self.logger.info("Testing scene generation...")
            scene = self.generator.generate_scene(architecture)
            assert scene, "Failed to generate scene"

            # 3. Verify Blender objects
            self.logger.info("Verifying Blender objects...")
            for component in architecture["components"]:
                obj_name = f"{component['type']}_{component['name']}"
                obj = bpy.data.objects.get(obj_name)
                assert obj, f"Missing object: {obj_name}"

            # 4. Test connections
            self.logger.info("Verifying connections...")
            for connection in architecture["connections"]:
                from_obj = bpy.data.objects.get(f"{connection['from']}")
                to_obj = bpy.data.objects.get(f"{connection['to']}")
                assert from_obj and to_obj, "Missing connection objects"

            self.logger.info("All tests passed successfully!")
            return True

        except Exception as e:
            self.logger.error(f"Integration test failed: {str(e)}")
            return False

def run_tests():
    """Run all integration tests"""
    test = IntegrationTest()
    asyncio.run(test.test_basic_scene())

if __name__ == "__main__":
    run_tests()

==================================================

File: SceneX/tests/example_scenes/8_latex-1-test copy.py
Contents:
# SceneX/tests/example_scenes/8_latex_test.py

import bpy
import math
from mathutils import Vector
from src.core.scene import Scene
from src.text.text_support import Text, LaTeXText
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig

class LaTeXTestScene(Scene):
    def construct(self):
        self.logger.info("Starting text test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create LaTeX equations
        equations = [
            ("Simple", "E = mc^2"),
            ("Integral", "\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}"),
            ("Matrix", "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}"),
            ("Sum", "\\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6}")
        ]

        tex_objects = []
        for name, tex in equations:
            obj = LaTeXText(tex, size=0.6, color=(1, 1, 1, 1)).create()
            if obj:  # Only add if LaTeX creation successful
                tex_objects.append(obj)

        # Position vertically
        spacing = 1.5
        for i, obj in enumerate(tex_objects):
            self.coordinate_system.place_object(obj, Vector((0, 2-i*spacing, 0)))

        # Animate equations appearing one by one
        config = AnimationConfig(duration=30)
        
        for obj in tex_objects:
            self.play(FadeInFrom(obj, direction=Vector((-1, 0, 0)), config=config))

if __name__ == "__main__":
    scene = LaTeXTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/6_material-test-fixed-animation.py
Contents:
# tests/example_scenes/6_materials_test.py

import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle 
from src.geometry.complex_shapes import Star
from src.materials.material import Material, MaterialConfig, MaterialType
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.material_animations import MaterialAnimation, EmissionAnimation
from src.animation.base import AnimationConfig


setup_scene

    def setup_basic_material(self, name, color):
        """Create a basic material with Principled BSDF"""
        mat = bpy.data.materials.new(name=name)
        mat.use_nodes = True
        
        # Clear existing nodes
        nodes = mat.node_tree.nodes
        nodes.clear()
        
        # Create new nodes
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        principled.inputs['Base Color'].default_value = color
        principled.name = "Principled BSDF"  # Explicitly set name
        
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Link nodes
        mat.node_tree.links.new(principled.outputs[0], output.inputs[0])
        
        return mat

    def setup_materials(self):
        """Setup all materials with proper nodes"""
        materials = {}
        
        # Basic material
        materials['basic'] = self.setup_basic_material("basic", (1, 0, 0, 1))
        
        # Glass material
        glass_mat = bpy.data.materials.new(name="glass")
        glass_mat.use_nodes = True
        glass_mat.blend_method = 'BLEND'
        glass_mat.use_screen_refraction = True
        glass_mat.use_backface_culling = False
        
        nodes = glass_mat.node_tree.nodes
        nodes.clear()
        glass_bsdf = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        glass_mat.node_tree.links.new(glass_bsdf.outputs[0], output.inputs[0])
        glass_bsdf.inputs["Color"].default_value = (0.8, 0.9, 1, 1)
        glass_bsdf.inputs["IOR"].default_value = 1.45
        materials['glass'] = glass_mat
        
        # Emission material
        emission_mat = bpy.data.materials.new(name="emission")
        emission_mat.use_nodes = True
        nodes = emission_mat.node_tree.nodes
        nodes.clear()
        
        emission = nodes.new('ShaderNodeEmission')
        emission.name = "Emission"  # Important for animation
        output = nodes.new('ShaderNodeOutputMaterial')
        emission_mat.node_tree.links.new(emission.outputs[0], output.inputs[0])
        emission.inputs["Color"].default_value = (0, 1, 0, 1)
        emission.inputs["Strength"].default_value = 1.0
        materials['emission'] = emission_mat
        
        # Metallic material
        metallic_mat = self.setup_basic_material("metal", (0.8, 0.8, 0.8, 1))
        principled = metallic_mat.node_tree.nodes["Principled BSDF"]
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = 0.1
        materials['metallic'] = metallic_mat
        
        # Toon material
        toon_mat = self.setup_basic_material("toon", (1, 0, 1, 1))
        materials['toon'] = toon_mat
        
        return materials

    def construct(self):
        self.logger.info("Starting materials test scene")
        
        # Setup scene
        self.setup_scene()
        
        # Create materials
        materials = self.setup_materials()
        
        # Create shapes with materials
        circle1 = Circle(radius=0.7).create()
        circle1.active_material = materials['basic']
        
        circle2 = Circle(radius=0.7).create()
        circle2.active_material = materials['glass']
        
        star = Star(points=5, outer_radius=0.7).create()
        star.active_material = materials['emission']
        
        rect = Rectangle(width=1.4, height=1.4).create()
        rect.active_material = materials['metallic']
        
        circle3 = Circle(radius=0.7).create()
        circle3.active_material = materials['toon']

        # Position objects
        self.coordinate_system.place_object(circle1, Vector((-2, 1, 0)))
        self.coordinate_system.place_object(circle2, Vector((0, 1, 0)))
        self.coordinate_system.place_object(star, Vector((2, 1, 0)))
        self.coordinate_system.place_object(rect, Vector((-1, -1, 0)))
        self.coordinate_system.place_object(circle3, Vector((1, -1, 0)))

        # Setup animation timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1
        
        # Create animations with proper timing
        animations = [
            MaterialAnimation(circle1, (1,0,0,1), (0,1,0,1),
                            config=AnimationConfig(duration=30)),
            FadeInFrom(circle2, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=30)),
            EmissionAnimation(star, 1.0, 10.0,
                            config=AnimationConfig(duration=30, delay_frames=60)),
            FadeInFrom(rect, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=90)),
            Rotate(circle3, angle=math.pi*2,
                  config=AnimationConfig(duration=30, delay_frames=120))
        ]

        # Create keyframes for each animation
        for anim in animations:
            start_frame = current_frame + (anim.config.delay_frames or 0)
            end_frame = start_frame + anim.config.duration
            anim.create_animation(start_frame)
            current_frame = end_frame

        # Set scene frame range
        bpy.context.scene.frame_end = current_frame + 20
        bpy.context.scene.frame_set(1)

if __name__ == "__main__":
    scene = MaterialTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/3_animation_showcase_test_1_FlashAround_test.py
Contents:
# SceneX/tests/example_scenes/animation_showcase_test.py

# SceneX/tests/example_scenes/animation_showcase_test.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.base import AnimationConfig
from src.animation.commonly_used_animations import (
    GrowFromCenter, GrowFromPoint, Write, 
    FadeInFrom, Rotate, FlashAround
)

class AnimationShowcaseScene(Scene):
    def construct(self):
        self.logger.info("Starting animation showcase scene")
        
        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Setup timeline (30fps)
        bpy.context.scene.render.fps = 30
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1

        # Row 1 - Top objects
        # GrowFromCenter Demo
        self.logger.info("Testing GrowFromCenter")
        cube = self.create_cube(size=1.0, location=(-2, 2, 0))
        grow = GrowFromCenter(cube, AnimationConfig(duration=30))
        current_frame = grow.create_animation(current_frame)
        
        # GrowFromPoint Demo
        self.logger.info("Testing GrowFromPoint")
        sphere = self.create_sphere(radius=0.5, location=(0, 2, 0))
        point = mathutils.Vector((-1, 2, 0))
        grow_point = GrowFromPoint(sphere, point, AnimationConfig(duration=30))
        current_frame = grow_point.create_animation(current_frame + 10)
        
        # FadeInFrom Demo
        self.logger.info("Testing FadeInFrom")
        cube2 = self.create_cube(size=0.8, location=(2, 2, 0))
        fade_in = FadeInFrom(cube2, mathutils.Vector((-1, 1, 0)), 
                           distance=3.0, config=AnimationConfig(duration=45))
        current_frame = fade_in.create_animation(current_frame + 10)

        # Row 2 - Center row with text
        # Write Demo
        self.logger.info("Testing Write")
        text = self.create_text("Welcome to SceneX", location=(0, 0, 0))
        write = Write(text, AnimationConfig(duration=60))
        current_frame = write.create_animation(current_frame + 10)

        # Row 3 - Bottom objects
        # Rotate Demo
        self.logger.info("Testing Rotate")
        cylinder = self.create_cylinder(radius=0.3, depth=1.5, location=(-2, -2, 0))
        rotate = Rotate(cylinder, math.radians(360), 'Z', 
                       config=AnimationConfig(duration=60))
        current_frame = rotate.create_animation(current_frame + 10)

        # FlashAround Demo
        self.logger.info("Testing FlashAround")
        target_sphere = self.create_sphere(radius=0.7, location=(2, -2, 0))
        flash = FlashAround(target_sphere, color=(1, 1, 0), 
                          config=AnimationConfig(duration=45))
        current_frame = flash.create_animation(current_frame + 10)

        # Set up camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

        # Return to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation showcase completed")

def main():
    try:
        scene = AnimationShowcaseScene()
        scene.construct()
        print("Animation showcase completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation showcase: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/20_material_animations_test.py
Contents:
# tests/example_scenes/20_material_animations_test.py

import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle, Square
from src.animation.material_animations import (
    MaterialPropertyAnimation,
    MaterialPresetAnimation,
    MaterialBlendAnimation,
    MATERIAL_PRESETS
)
from src.animation.base import AnimationConfig

class MaterialAnimationTestScene(Scene):

    def setup_world_background(self):
        """Setup world background with a subtle gradient"""
        world = bpy.context.scene.world
        if not world:
            world = bpy.data.worlds.new("World")
            bpy.context.scene.world = world
            
        world.use_nodes = True
        nodes = world.node_tree.nodes
        links = world.node_tree.links
        
        # Clear existing nodes
        nodes.clear()
        
        # Create nodes for gradient background
        sky = nodes.new('ShaderNodeSkyTexture')
        sky.sky_type = 'NISHITA'
        sky.altitude = 0.5
        sky.air_density = 1.0
        sky.dust_density = 1.0
        
        mapping = nodes.new('ShaderNodeMapping')
        mapping.inputs['Rotation'].default_value = (0.5, 0.7, 0)
        
        tex_coord = nodes.new('ShaderNodeTexCoord')
        background = nodes.new('ShaderNodeBackground')
        output = nodes.new('ShaderNodeOutputWorld')
        
        # Connect nodes
        links.new(tex_coord.outputs['Generated'], mapping.inputs['Vector'])
        links.new(mapping.outputs['Vector'], sky.inputs['Vector'])
        links.new(sky.outputs['Color'], background.inputs['Color'])
        links.new(background.outputs['Background'], output.inputs['Surface'])
        
        # Adjust background strength
        background.inputs['Strength'].default_value = 0.5

    def create_environment(self):
        """Create ground plane and backdrop"""
        # Create ground plane
        bpy.ops.mesh.primitive_plane_add(size=20, location=(0, 0, -0.01))
        ground = bpy.context.active_object
        
        # Create ground material
        ground_mat = bpy.data.materials.new(name="ground_material")
        ground_mat.use_nodes = True
        nodes = ground_mat.node_tree.nodes
        links = ground_mat.node_tree.links
        nodes.clear()
        
        # Create nodes for gradient ground material
        noise = nodes.new('ShaderNodeTexNoise')
        noise.inputs['Scale'].default_value = 5.0
        noise.inputs['Detail'].default_value = 2.0
        
        color_ramp = nodes.new('ShaderNodeValToRGB')
        color_ramp.color_ramp.elements[0].position = 0.4
        color_ramp.color_ramp.elements[0].color = (0.1, 0.1, 0.1, 1)
        color_ramp.color_ramp.elements[1].position = 0.6
        color_ramp.color_ramp.elements[1].color = (0.2, 0.2, 0.2, 1)
        
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Connect nodes
        links.new(noise.outputs['Color'], color_ramp.inputs['Fac'])
        links.new(color_ramp.outputs['Color'], principled.inputs['Base Color'])
        links.new(principled.outputs['BSDF'], output.inputs['Surface'])
        
        # Set material properties
        principled.inputs['Roughness'].default_value = 0.7
        principled.inputs['Specular'].default_value = 0.1
        
        # Assign material to ground plane
        ground.data.materials.append(ground_mat)
        
        # Create backdrop (curved plane)
        bpy.ops.mesh.primitive_plane_add(size=20)
        backdrop = bpy.context.active_object
        backdrop.location = (0, 10, 10)
        backdrop.rotation_euler = (math.radians(45), 0, 0)
        
        # Add subdivision and curve modifiers
        subdiv = backdrop.modifiers.new(name="Subdivision", type='SUBSURF')
        subdiv.levels = 3
        
        curve = backdrop.modifiers.new(name="Curve", type='SIMPLE_DEFORM')
        curve.deform_method = 'BEND'
        curve.angle = math.radians(45)
        
        # Create backdrop material
        backdrop_mat = bpy.data.materials.new(name="backdrop_material")
        backdrop_mat.use_nodes = True
        nodes = backdrop_mat.node_tree.nodes
        nodes.clear()
        
        # Create simple gradient material
        gradient = nodes.new('ShaderNodeTexGradient')
        color_ramp = nodes.new('ShaderNodeValToRGB')
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Setup gradient colors
        color_ramp.color_ramp.elements[0].position = 0.3
        color_ramp.color_ramp.elements[0].color = (0.15, 0.15, 0.15, 1)
        color_ramp.color_ramp.elements[1].position = 0.7
        color_ramp.color_ramp.elements[1].color = (0.3, 0.3, 0.3, 1)
        
        # Connect nodes
        links = backdrop_mat.node_tree.links
        links.new(gradient.outputs['Color'], color_ramp.inputs['Fac'])
        links.new(color_ramp.outputs['Color'], principled.inputs['Base Color'])
        links.new(principled.outputs['BSDF'], output.inputs['Surface'])
        
        # Assign material to backdrop
        backdrop.data.materials.append(backdrop_mat)
        
        return ground, backdrop

    def setup_scene(self):
        """Setup complete scene with background and lighting"""
        # Clear existing scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Setup world background
        self.setup_world_background()
        
        # Create environment
        ground, backdrop = self.create_environment()
        
        # Set render engine and settings
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        bpy.context.scene.eevee.use_bloom = True
        bpy.context.scene.eevee.bloom_intensity = 1.0
        
        # Setup lighting
        # Key light
        bpy.ops.object.light_add(type='AREA', location=(5, -5, 8))
        key_light = bpy.context.active_object
        key_light.data.energy = 500.0
        key_light.rotation_euler = (math.radians(45), 0, math.radians(45))
        key_light.data.size = 5.0
        
        # Fill light
        bpy.ops.object.light_add(type='AREA', location=(-5, -2, 4))
        fill_light = bpy.context.active_object
        fill_light.data.energy = 200.0
        fill_light.rotation_euler = (math.radians(30), 0, math.radians(-60))
        fill_light.data.size = 3.0
        
        # Rim light
        bpy.ops.object.light_add(type='AREA', location=(0, 5, 6))
        rim_light = bpy.context.active_object
        rim_light.data.energy = 300.0
        rim_light.rotation_euler = (math.radians(-45), 0, 0)
        rim_light.data.size = 4.0
        
        # Setup camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Setup camera constraints
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera
        
        # Set viewport shading
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].shading.type = 'RENDERED'
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True
   
    def construct(self):
        self.logger.info("Starting material animations test scene")
        
        # Setup scene with background
        self.setup_scene()
        
        # Create test objects
        sphere1 = self.create_sphere(radius=0.5, location=(-2, 0, 0))
        sphere2 = self.create_sphere(radius=0.5, location=(0, 0, 0))
        sphere3 = self.create_sphere(radius=0.5, location=(2, 0, 0))
        
        # Create materials
        metal_mat = self.create_material_from_preset('metal')
        plastic_mat = self.create_material_from_preset('plastic')
        glass_mat = self.create_material_from_preset('glass')
        
        # Assign initial materials
        sphere1.active_material = metal_mat
        sphere2.active_material = plastic_mat
        sphere3.active_material = glass_mat
        
        # Create animations
        current_frame = 1
        base_duration = 60
        
        # 1. Property Animation - Roughness transition
        roughness_anim = MaterialPropertyAnimation(
            sphere1,
            "Roughness",
            0.0,
            1.0,
            config=AnimationConfig(duration=base_duration)
        )
        current_frame = roughness_anim.create_animation(current_frame)
        
        # 2. Preset Sequence Animation
        preset_sequence = [
            MATERIAL_PRESETS['plastic'],
            MATERIAL_PRESETS['metal'],
            MATERIAL_PRESETS['glass']
        ]
        preset_anim = MaterialPresetAnimation(
            sphere2,
            preset_sequence,
            config=AnimationConfig(duration=base_duration * 2)
        )
        current_frame = preset_anim.create_animation(current_frame)
        
        # 3. Material Blend Animation
        blend_anim = MaterialBlendAnimation(
            sphere3,
            metal_mat,
            glass_mat,
            config=AnimationConfig(duration=base_duration)
        )
        current_frame = blend_anim.create_animation(current_frame)
        
        # Set frame range
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = current_frame + 20
        
    def create_material_from_preset(self, preset_name):
        """Create a material from a preset"""
        mat = bpy.data.materials.new(name=preset_name)
        mat.use_nodes = True
        
        principled = mat.node_tree.nodes["Principled BSDF"]
        for prop, value in MATERIAL_PRESETS[preset_name].items():
            if prop in principled.inputs:
                principled.inputs[prop].default_value = value
                
        return mat

if __name__ == "__main__":
    scene = MaterialAnimationTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/2_animation_test_scene_1_test.py
Contents:
# SceneX/tests/example_scenes/animation_test_scene.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.transform import Transform, FadeIn, FadeOut, Scale
from src.animation.base import AnimationConfig

class AnimationTestScene(Scene):
    def construct(self):
        self.logger.info("Starting animation test scene")
        
        # Clear existing objects
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        sun = bpy.context.active_object
        sun.data.energy = 5.0

        # Configure viewport for better visibility
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'MATERIAL'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Create objects with initial materials
        cube = self.create_cube(size=1.0, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        
        # Set up materials with color for better visibility
        for obj in [cube, sphere]:
            mat = bpy.data.materials.new(name=f"{obj.name}_material")
            mat.use_nodes = True
            principled = mat.node_tree.nodes.get('Principled BSDF')
            if principled:
                # Set a base color (blue for cube, red for sphere)
                if obj == cube:
                    principled.inputs['Base Color'].default_value = (0.2, 0.4, 0.8, 1.0)
                else:
                    principled.inputs['Base Color'].default_value = (0.8, 0.2, 0.2, 1.0)
            
            if obj.data.materials:
                obj.data.materials[0] = mat
            else:
                obj.data.materials.append(mat)

        # Setup timeline
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1
        
        # Animation sequence
        fade_in_config = AnimationConfig(duration=30, ease_type='EASE_IN')
        fade_in1 = FadeIn(cube, fade_in_config)
        fade_in2 = FadeIn(sphere, fade_in_config)
        current_frame = fade_in1.create_animation(current_frame)
        current_frame = fade_in2.create_animation(current_frame)
        
        # Transform cube
        transform_config = AnimationConfig(duration=60)
        end_state = {
            "location": mathutils.Vector((2, 2, 2)),
            "rotation": mathutils.Euler((math.radians(45), 0, 0)),
            "scale": mathutils.Vector((2, 2, 2))
        }
        transform = Transform(cube, end_state, transform_config)
        current_frame = transform.create_animation(current_frame + 10)
        
        # Scale sphere
        scale_config = AnimationConfig(duration=30, ease_type='EASE_OUT')
        scale = Scale(sphere, 2.0, scale_config)
        current_frame = scale.create_animation(current_frame + 10)
        
        # Fade out both objects
        fade_out_config = AnimationConfig(duration=30, ease_type='EASE_IN_OUT')
        fade_out1 = FadeOut(cube, fade_out_config)
        fade_out2 = FadeOut(sphere, fade_out_config)
        current_frame = fade_out1.create_animation(current_frame + 30)
        current_frame = fade_out2.create_animation(current_frame)

        # Set up camera for better view
        bpy.ops.object.camera_add(location=(5, -5, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(60), 0, math.radians(45))
        bpy.context.scene.camera = camera
        
        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
        
        # Set current frame to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation test scene completed")

def main():
    try:
        scene = AnimationTestScene()
        scene.construct()
        print("Animation test scene completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation test: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/13_groups_test.py
Contents:
# SceneX/tests/example_scenes/13_groups_test.py

import bpy
import math
from mathutils import Vector, Matrix

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.geometry.shapes import Circle, Square
from src.scene.groups import Group
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.base import AnimationConfig

class GroupsTest(Scene):
    def construct(self):
        self.logger.info("Starting groups test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0


        # Create shapes for two groups
        circles = [Circle(radius=0.2).create() for _ in range(3)]
        squares = [Square(size=0.4).create() for _ in range(3)]

        # Position shapes
        positions = [Vector((-1, 0, 0)), Vector((0, 0, 0)), Vector((1, 0, 0))]
        for obj, pos in zip(circles, positions):
            self.coordinate_system.place_object(obj, pos + Vector((0, 1, 0)))
        for obj, pos in zip(squares, positions):
            self.coordinate_system.place_object(obj, pos + Vector((0, -1, 0)))

        # Create groups
        circle_group = Group("circles").add(*circles)
        square_group = Group("squares").add(*squares)
        main_group = Group("main").add(circle_group, square_group)

        # Animate groups
        config = AnimationConfig(duration=30)

        # Rotate entire group
        rotation_matrix = Matrix.Rotation(math.radians(180), 4, 'Z')
        main_group.apply_transform(rotation_matrix)

        # Fade in animation
        for obj in main_group.get_all_objects():
            self.play(FadeInFrom(obj, Vector((0, -1, 0)), config=config))

if __name__ == "__main__":
    scene = GroupsTest()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/8_latex-2-test copy.py
Contents:
# SceneX/src/text/text_support.py

# import sys
# print("Python path during runtime:", sys.executable)
# print("Python path to site-packages:", sys.path)

# import sys
# import site

# # Append user site-packages to sys.path
# sys.path.append(site.getusersitepackages())

# print("Updated Python path to site-packages:", sys.path)



import bpy
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import io
import tempfile
from PIL import Image

from src.core.scene import Scene
from src.text.text_support import Text
from src.animation.commonly_used_animations import Write, FadeInFrom
from src.animation.base import AnimationConfig
from src.geometry.base import Geometry

class LaTeXText(Geometry):
    def __init__(self, tex: str, size: float = 1.0, **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size

    def create(self) -> bpy.types.Object:
        # Create figure with transparent background
        fig = plt.figure(figsize=(5, 1), dpi=300)
        fig.patch.set_alpha(0.0)
        
        # Add text using matplotlib's LaTeX renderer
        plt.text(0.5, 0.5, f"${self.tex}$", 
                horizontalalignment='center',
                verticalalignment='center',
                transform=fig.transFigure,
                color=self.color[:3])
        
        plt.axis('off')
        
        # Save to temporary PNG with transparency
        with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
            plt.savefig(tmp.name, 
                       transparent=True,
                       bbox_inches='tight',
                       pad_inches=0.1,
                       dpi=300)
            plt.close()
            
            # Create image texture
            img = bpy.data.images.load(tmp.name)
            
            # Create plane for the texture
            bpy.ops.mesh.primitive_plane_add(size=self.size)
            self.object = bpy.context.active_object
            
            # Create material
            mat = bpy.data.materials.new(name="latex_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            
            # Setup nodes for transparent texture
            nodes = mat.node_tree.nodes
            links = mat.node_tree.links
            nodes.clear()
            
            tex_image = nodes.new('ShaderNodeTexImage')
            tex_image.image = img
            
            principled = nodes.new('ShaderNodeBsdfPrincipled')
            output = nodes.new('ShaderNodeOutputMaterial')
            
            links.new(tex_image.outputs['Color'], principled.inputs['Base Color'])
            links.new(tex_image.outputs['Alpha'], principled.inputs['Alpha'])
            links.new(principled.outputs['BSDF'], output.inputs['Surface'])
            
            self.object.data.materials.append(mat)
            
            return self.object

==================================================

File: SceneX/tests/example_scenes/1_basic_scene_3_add_camera_test.py
Contents:
# SceneX/tests/example_scenes/basic_scene_3_add_camera.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.core.coordinate_system import GridConfig
from src.camera.camera import CameraConfig, CameraSystem

class BasicTestScene(Scene):
    def construct(self):
        self.logger.info("Starting basic test scene construction")
        
        # Setup the scene first
        self.setup()
        
        # Configure camera
        self.camera = CameraSystem(CameraConfig(
            distance=15.0,
            angle=45.0
        ))
        self.camera.setup()
        
        # Create coordinate system with grid
        self.coordinate_system.create_grid(GridConfig(
            x_range=(-5, 5),
            y_range=(-3, 3),
            line_thickness=0.02
        ))
        
        # Create basic shapes
        cube = self.create_cube(size=0.5, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.25, location=(2, 0, 0))
        
        # Place objects using coordinate system
        self.coordinate_system.place_object(cube, mathutils.Vector((-2, 1, 0)))
        self.coordinate_system.place_object(sphere, mathutils.Vector((2, -1, 0)))
        
        # Frame the scene
        self.camera.frame_point(mathutils.Vector((0, 0, 0)))
        
        # Add some camera movement
        self.camera.zoom(0.8)  # Zoom in slightly
        self.camera.rotate(math.radians(30), math.radians(45))  # Rotate for better view
        
        # Switch to camera view in all 3D viewports
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.region_3d.view_perspective = 'CAMERA'
        
        self.logger.info("Scene construction completed")

def main():
    try:
        # Create and run the test scene
        scene = BasicTestScene()
        scene.construct()
        print("Test scene completed successfully")
        
        # Keep Blender open
        bpy.ops.wm.window_fullscreen_toggle()  # Optional: toggle fullscreen
        
    except Exception as e:
        print(f"Error running test scene: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()


    ## blender --window-geometry 0 0 1920 1080 --python .\tests\example_scenes\basic_scene_3_add_camera.py

==================================================

File: SceneX/tests/example_scenes/16_camera_movement_test.py
Contents:
# SceneX/tests/example_scenes/16_camera_movement_test.py

import bpy
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.geometry.shapes import Circle, Square
from src.camera.movements import CameraMovement
from src.scene.groups import Group
from src.animation.base import AnimationConfig

class CameraMovementTest(Scene):
    def construct(self):
        self.logger.info("Starting camera movement test")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create test objects
        circle = Circle(radius=1.0).create()
        square = Square(size=2.0).create()
        group = Group("test_group").add(circle, square)

        # Position objects
        circle.location = Vector((-2, 0, 0))
        square.location = Vector((2, 0, 0))

        # Initialize camera movement
        cam_move = CameraMovement(self.camera)

        # Test camera movements
        cam_move.dolly(-5, duration=30)  # Move back
        cam_move.orbit(math.pi, duration=60)  # Orbit 180 degrees
        cam_move.frame_object(group)  # Frame both objects
        cam_move.fly_to(Vector((5, -5, 5)), Vector((0, 0, 0)), duration=30)

if __name__ == "__main__":
    scene = CameraMovementTest()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/18_physics_test.py
Contents:
# SceneX/tests/example_scenes/18_physics_test.py

from src.templates.physics import (
    PendulumScene,
    CollisionScene,
    SpringScene
)
from mathutils import Vector

class DoublePendulumTest(PendulumScene):
    def construct(self):
        self.logger.info("Starting double pendulum simulation")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        # bpy.ops.object.camera_add(location=(7, -7, 5))
        # camera = bpy.context.active_object
        # camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        bpy.ops.object.camera_add(location=(0, -10, 5))  # Move back for better view
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(30), 0, 0)  # Less steep angle
        
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0
        
        # Setup scene and physics
        self.setup_physics()
        self.gravity = (0, 0, -9.81)
        
        # Create first pendulum
        anchor1 = Vector((0, 0, 5))
        bob1_pos = Vector((2, 0, 3))
        self.setup_pendulum()
        
        # Create second pendulum
        anchor2 = bob1_pos
        bob2_pos = Vector((4, 0, 1))
        self.length = 2.0
        self.setup_pendulum()

class CollisionTest(CollisionScene):
    def construct(self):
        self.logger.info("Starting collision simulation")

        # Setup scene and physics
        self.setup_physics()
        
        # Create objects for collision
        self.setup_collision(num_objects=7)

class SpringTest(SpringScene):
    def construct(self):
        self.logger.info("Starting spring simulation")

        # Setup scene and physics
        self.setup_physics()
        
        # Create spring system
        self.setup_spring(spring_constant=15.0)

def run_physics_tests():
    # Test double pendulum
    pendulum_scene = DoublePendulumTest()
    pendulum_scene.construct()
    
    # Test collisions
    collision_scene = CollisionTest()
    collision_scene.construct()
    
    # Test spring
    spring_scene = SpringTest()
    spring_scene.construct()

if __name__ == "__main__":
    run_physics_tests()

==================================================

File: SceneX/tests/example_scenes/8_latex-1-test-gpt-working-2.py
Contents:
import bpy
import math
from mathutils import Vector
from src.core.scene import Scene
from src.text.text_support import LaTeXText
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig


class LaTeXTestScene(Scene):
    def construct(self):
        self.logger.info("Starting materials test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # LaTeX Equations (Corrected for Matplotlib)
        equations = [
            ("Einstein", "E = mc^2"),
            ("Gaussian Integral", "\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}"),
            ("Matrix Form", "\\\\left( \\begin{matrix} a & b \\\\ c & d \\end{matrix} \\\\right)"),
            ("Summation", "\\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6}")
        ]

        tex_objects = []
        for name, tex in equations:
            obj = LaTeXText(tex=tex, size=1.2, color=(1, 1, 1, 1)).create()
            if obj:
                self.logger.info(f"LaTeX object created for {name}")
                tex_objects.append(obj)
            else:
                self.logger.error(f"Failed to create LaTeX object for {name}")

        # Positioning and Animation
        spacing = 1.5
        for i, obj in enumerate(tex_objects):
            obj.location = Vector((0, 2 - i * spacing, 0))

        # Fade-In Animation
        config = AnimationConfig(duration=30)
        for obj in tex_objects:
            self.play(FadeInFrom(obj, direction=Vector((-1, 0, 0)), config=config))

        # Render to File
        bpy.context.scene.render.filepath = "C:/Users/ernes/Desktop/latex_render.png"
        bpy.ops.render.render(write_still=True)


if __name__ == "__main__":
    scene = LaTeXTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/2_animation_test_scene_4_commonly_used_animations_test.py
Contents:
# SceneX/tests/example_scenes/commonly_used_animations.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.transform import Transform, FadeIn, FadeOut, Scale
from src.animation.base import AnimationConfig
from src.animation.commonly_used_animations import (  # Updated import path
    GrowFromCenter, GrowFromPoint, Write, 
    FadeInFrom, Rotate, FlashAround
)

class AnimationTestScene(Scene):
    def create_text(self, content: str, location: tuple[float, float, float] = (0, 0, 0)) -> bpy.types.Object:
        bpy.ops.object.text_add(location=location)
        text_obj = bpy.context.object
        text_obj.data.body = content
        return text_obj

    def construct(self):
        self.logger.info("Starting animation test scene")
        
        # Clear scene and setup render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine and settings for Blender 4.2
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'  # Updated from BLENDER_EEVEE
        if hasattr(bpy.context.scene.eevee, "use_ssr"):  # Handle EEVEE Next settings
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
               
        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True
        
        # Create objects with initial materials
        cube = self.create_cube(size=1.0, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        
        # Setup initial materials with colors
        for obj, color in [(cube, (0.2, 0.4, 0.8, 1.0)), (sphere, (0.8, 0.2, 0.2, 1.0))]:
            mat = bpy.data.materials.new(name=f"{obj.name}_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            principled = mat.node_tree.nodes["Principled BSDF"]
            principled.inputs["Base Color"].default_value = color
            if obj.data.materials:
                obj.data.materials[0] = mat
            else:
                obj.data.materials.append(mat)
        
        # Setup timeline (30fps)
        bpy.context.scene.render.fps = 30
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1
                
        # Test GrowFromCenter
        cube = self.create_cube(size=1.0)
        grow = GrowFromCenter(cube, AnimationConfig(duration=30))
        current_frame = grow.create_animation(1)
        
        # Test FadeInFrom
        sphere = self.create_sphere(radius=0.5, location=(2, 0, 0))
        fade_in = FadeInFrom(sphere, mathutils.Vector((-1, 0, 0)), 
                           config=AnimationConfig(duration=30))
        current_frame = fade_in.create_animation(current_frame + 10)
        
        # # Test Write
        text_obj = self.create_text("Hello", location=(-1, 1, 1))
        write_anim = Write(text_obj, AnimationConfig(duration=60))
        current_frame = write_anim.create_animation(current_frame)
        
        # Test Rotate
        rotate = Rotate(cube, math.radians(360), 'Z', 
                      AnimationConfig(duration=60))
        current_frame = rotate.create_animation(current_frame + 10)
        
        # Test FlashAround
        flash = FlashAround(sphere, config=AnimationConfig(duration=30))
        current_frame = flash.create_animation(current_frame + 10)

        # Set up camera
        bpy.ops.object.camera_add(location=(5, -5, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(60), 0, math.radians(45))
        bpy.context.scene.camera = camera
        
        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
        
        # Set current frame to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation test scene completed")

def main():
    try:
        scene = AnimationTestScene()
        scene.construct()
        print("Animation test scene completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation test: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/10_alignment_test.py
Contents:
# SceneX/tests/example_scenes/10_alignment_test.py

import bpy
import math
from mathutils import Vector


# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle
from src.geometry.alignment import AlignmentHandler, AlignmentType
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig

class AlignmentTestScene(Scene):
    def construct(self):
        self.logger.info("Starting alignment test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Create shapes
        shapes = []
        for i in range(5):
            circle = Circle(radius=0.3).create()
            shapes.append(circle)

        # Initial random positions
        positions = [
            Vector((-2, 1, 0)),
            Vector((-1, -0.5, 0)),
            Vector((0, 0.8, 0)),
            Vector((1, -0.3, 0)),
            Vector((2, 0.5, 0))
        ]

        for obj, pos in zip(shapes, positions):
            self.coordinate_system.place_object(obj, pos)

        # Create alignment handler
        handler = AlignmentHandler()

        # Demo different alignments
        config = AnimationConfig(duration=30)

        # Horizontal distribution
        self.play(FadeInFrom(shapes[0], Vector((0, -1, 0)), config=config))
        handler.distribute_objects(shapes, direction=AlignmentType.DISTRIBUTE_H)

        # Vertical alignment
        self.play(FadeInFrom(shapes[0], Vector((0, -1, 0)), config=config))
        handler.align_objects(shapes, AlignmentType.CENTER)

        # Grid arrangement
        self.play(FadeInFrom(shapes[0], Vector((0, -1, 0)), config=config))
        handler.grid_arrange(shapes, rows=2, cols=3, spacing=(1.0, 1.0))

if __name__ == "__main__":
    scene = AlignmentTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/9_svg_test.py
Contents:
# tests/example_scenes/9_svg_test.py

import bpy
import sys
import os
from pathlib import Path

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.svg.svg_handler import SVGHandler
from src.camera.camera import CameraConfig, CameraSystem
from src.animation.commonly_used_animations import FadeInFrom
from src.animation.base import AnimationConfig

class SVGTestScene(Scene):
    def __init__(self):
        super().__init__()
        self.svg_handler = SVGHandler()
        
    def construct(self):
        # Setup scene
        self.setup()
        
        # Set camera for better view
        camera_config = CameraConfig(
            frame_width=14.0,
            frame_height=8.0,
            position=(0, -10, 5)
        )
        self.camera = CameraSystem(camera_config)
        
        # Import SVG with moderate scale
        svg_container = self.svg_handler.import_svg(
            "SceneX_logo.svg",
            scale=2.0,  # More reasonable scale
            location=(0, 0, 0)  # Center at origin
        )
        
        if not svg_container:
            self.logger.error("Failed to import SVG")
            return
            
        # Get SVG dimensions for reference
        dimensions = self.svg_handler.get_svg_dimensions(svg_container)
        self.logger.info(f"SVG dimensions: {dimensions}")
        
        # Add fade-in animation - now using Vector for direction
        config = AnimationConfig(duration=30)
        direction = Vector((0, 0, 1))  # Convert tuple to Vector
        self.play(FadeInFrom(svg_container, direction=direction, config=config))

def test_svg():
    # Clear existing scene
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Create and run test scene
    scene = SVGTestScene()
    scene.construct()
    
    print("SVG test scene completed")

if __name__ == "__main__":
    test_svg()

==================================================

File: SceneX/tests/example_scenes/23-blender-compatible-test.py
Contents:
import bpy
import os
import sys
from pathlib import Path
import math

def setup_paths():
    """Setup the Python path to include SceneX modules"""
    current_dir = Path(__file__).parent.parent  # SceneX root
    if str(current_dir) not in sys.path:
        sys.path.append(str(current_dir))
        print(f"Added {current_dir} to Python path")

class SceneSetup:
    """Handle scene configuration and setup"""
    
    @staticmethod
    def setup_render_engine():
        """Configure render engine settings"""
        try:
            scene = bpy.context.scene
            # Set render engine
            if hasattr(scene.render, "engine"):
                scene.render.engine = 'CYCLES'  # Use Cycles as fallback
                
            # Try to set EEVEE Next if available
            engines = [e.identifier for e in bpy.types.RenderEngine.bl_rna.properties['type'].enum_items]
            if 'BLENDER_EEVEE_NEXT' in engines:
                scene.render.engine = 'BLENDER_EEVEE_NEXT'
                
            # Configure EEVEE settings if available
            if hasattr(scene, "eevee"):
                scene.eevee.use_ssr = True
                scene.eevee.use_ssr_refraction = True
                scene.eevee.use_gtao = True
                scene.eevee.gtao_distance = 0.2
                scene.eevee.use_bloom = True
        except Exception as e:
            print(f"Warning: Could not set render engine: {str(e)}")

class CameraSetup:
    """Handle camera setup and positioning"""
    
    @staticmethod
    def create_camera(location=(7, -7, 5)):
        """Create and configure camera"""
        try:
            # Remove existing cameras
            for obj in bpy.data.objects:
                if obj.type == 'CAMERA':
                    bpy.data.objects.remove(obj, do_unlink=True)
            
            # Create new camera
            bpy.ops.object.camera_add(location=location)
            camera = bpy.context.active_object
            camera.name = "SceneCamera"
            
            # Set camera properties
            camera.data.lens = 50
            camera.data.clip_start = 0.1
            camera.data.clip_end = 1000
            
            # Create target empty
            bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
            target = bpy.context.active_object
            target.name = "CameraTarget"
            
            # Setup tracking constraint
            track = camera.constraints.new(type='TRACK_TO')
            track.target = target
            track.track_axis = 'TRACK_NEGATIVE_Z'
            track.up_axis = 'UP_Y'
            
            # Make active camera
            bpy.context.scene.camera = camera

            # Switch all 3D viewports to camera view
            for area in bpy.context.screen.areas:
                if area.type == 'VIEW_3D':
                    # Switch to camera perspective
                    area.spaces[0].region_3d.view_perspective = 'CAMERA'
                    # Set this as the lock camera to view
                    area.spaces[0].use_camera_lock = True
                    # Set viewport shading
                    space = area.spaces[0]
                    space.shading.type = 'MATERIAL'
                    space.shading.use_scene_lights = True
                    space.shading.use_scene_world = True
            
            return camera, target
            
        except Exception as e:
            print(f"Error setting up camera: {str(e)}")
            return None, None

    @staticmethod
    def align_view_to_camera():
        """Align the 3D view to the active camera"""
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                override = bpy.context.copy()
                override['area'] = area
                bpy.ops.view3d.view_camera(override)
                area.spaces[0].use_camera_lock = True
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.tag_redraw()

class AWSComponentBuilder:
    """Helper class to build AWS components in Blender"""
    
    @staticmethod
    def create_lambda(location=(0, 0, 0), scale=(1.5, 1, 0.5)):
        bpy.ops.mesh.primitive_cube_add(size=1, location=location)
        obj = bpy.context.active_object
        obj.name = "lambda_function"
        obj.scale = scale
        
        # Add material
        mat = bpy.data.materials.new(name="lambda_material")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        nodes["Principled BSDF"].inputs["Base Color"].default_value = (0.9, 0.5, 0.1, 1)  # Orange
        obj.data.materials.append(mat)
        
        return obj
    
    @staticmethod
    def create_s3(location=(2, 0, 0)):
        bpy.ops.mesh.primitive_cylinder_add(radius=0.5, depth=1, location=location)
        obj = bpy.context.active_object
        obj.name = "s3_bucket"
        
        # Add material
        mat = bpy.data.materials.new(name="s3_material")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        nodes["Principled BSDF"].inputs["Base Color"].default_value = (0.5, 0.2, 0.9, 1)  # Purple
        obj.data.materials.append(mat)
        
        return obj
    
    @staticmethod
    def create_apigateway(location=(0, 2, 0)):
        bpy.ops.mesh.primitive_cube_add(size=1, location=location)
        obj = bpy.context.active_object
        obj.name = "api_gateway"
        obj.scale = (1, 0.2, 1)
        
        # Add material
        mat = bpy.data.materials.new(name="apigateway_material")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        nodes["Principled BSDF"].inputs["Base Color"].default_value = (0.2, 0.6, 0.8, 1)  # Blue
        obj.data.materials.append(mat)
        
        return obj

    @staticmethod
    def create_connection(start_obj, end_obj, name="connection"):
        """Create a connection line between two objects"""
        curve_data = bpy.data.curves.new(name, type='CURVE')
        curve_data.dimensions = '3D'
        
        polyline = curve_data.splines.new('POLY')
        polyline.points.add(1)
        
        # Get object centers
        start_pos = start_obj.location
        end_pos = end_obj.location
        
        polyline.points[0].co = (*start_pos, 1)
        polyline.points[1].co = (*end_pos, 1)
        
        curve_obj = bpy.data.objects.new(name, curve_data)
        curve_obj.data.bevel_depth = 0.02
        
        # Add material
        mat = bpy.data.materials.new(name=f"{name}_material")
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        nodes["Principled BSDF"].inputs["Base Color"].default_value = (0.2, 0.2, 0.2, 1)  # Dark gray
        curve_obj.data.materials.append(mat)
        
        bpy.context.scene.collection.objects.link(curve_obj)
        return curve_obj

class BlenderAISceneTest:
    """Test AI Scene Generation in Blender"""
    
    def __init__(self):
        self.builder = AWSComponentBuilder()
        self.setup_scene()
        
    def setup_scene(self):
        """Setup complete scene environment"""
        try:
            # Clear existing scene
            bpy.ops.object.select_all(action='SELECT')
            bpy.ops.object.delete()
            
            # Setup render engine
            SceneSetup.setup_render_engine()
            
            # Setup camera and lighting
            self.camera, self.target = CameraSetup.create_camera()
            self.setup_lighting()
            
            # Ensure camera view
            CameraSetup.align_view_to_camera()
            
            print("Scene setup completed successfully")
            
        except Exception as e:
            print(f"Error in scene setup: {str(e)}")

    def setup_lighting(self):
        """Set up scene lighting"""
        # Add main light
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0
        sun.data.angle = 0.1  # Sharper shadows
        
        # Add fill light
        bpy.ops.object.light_add(type='SUN', location=(-3, -3, 4))
        fill = bpy.context.active_object
        fill.data.energy = 1.0
        fill.data.angle = 0.3  # Softer shadows

    def create_mock_scene(self, scene_type="lambda_s3"):
        """Create a test scene based on type"""
        if scene_type == "lambda_s3":
            # Create Lambda and S3
            lambda_obj = self.builder.create_lambda()
            s3_obj = self.builder.create_s3()
            self.builder.create_connection(lambda_obj, s3_obj, "lambda_to_s3")
            
            # Position camera for this scene
            self.camera.location = (5, -5, 3)
            
        elif scene_type == "api_lambda_s3":
            # Create vertically arranged components
            api_obj = self.builder.create_apigateway((0, 2, 0))
            lambda_obj = self.builder.create_lambda((0, 0, 0))
            s3_obj = self.builder.create_s3((0, -2, 0))
            
            # Create connections
            self.builder.create_connection(api_obj, lambda_obj, "api_to_lambda")
            self.builder.create_connection(lambda_obj, s3_obj, "lambda_to_s3")
            
            # Position camera for this scene
            self.camera.location = (7, 0, 4)
        
        # Ensure camera view
        CameraSetup.align_view_to_camera()

    def test_scene_creation(self, scene_type="lambda_s3"):
        """Test the scene creation functionality"""
        try:
            print(f"Starting AI Scene Generation test for {scene_type}...")
            
            # Create test scene
            self.create_mock_scene(scene_type)
            
            # Verify objects were created
            expected_objects = {
                "lambda_s3": ["lambda_function", "s3_bucket", "lambda_to_s3"],
                "api_lambda_s3": ["api_gateway", "lambda_function", "s3_bucket", 
                                "api_to_lambda", "lambda_to_s3"]
            }
            
            for obj_name in expected_objects[scene_type]:
                obj = bpy.data.objects.get(obj_name)
                assert obj is not None, f"Object {obj_name} not found in scene"
                print(f"Verified object: {obj_name}")
            
            print("Scene generation test completed successfully")
            return True
            
        except Exception as e:
            print(f"Test failed: {str(e)}")
            return False

def main():
    """Main test function"""
    setup_paths()
    
    # Run tests for different scene types
    test = BlenderAISceneTest()
    
    # Test basic Lambda to S3 scene
    test.test_scene_creation("lambda_s3")
    
    # Clear and test API Gateway to Lambda to S3 scene
    test.setup_scene()
    test.test_scene_creation("api_lambda_s3")

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/21_integration_test.py
Contents:
# src/ai/tests/test_integration.py
import asyncio
import bpy
from ..core.llm.claude_client import ClaudeClient
from ..core.generators.scene_generator import SceneGenerator
from ..backend.api.routes import generate_scene
from ...utils.logger import SceneXLogger

class IntegrationTest:
    def __init__(self):
        self.logger = SceneXLogger("IntegrationTest")
        self.claude = ClaudeClient()
        self.generator = SceneGenerator()

    async def test_basic_scene(self):
        """Test basic scene generation flow"""
        try:
            # Test prompt
            prompt = """Create a serverless ML inference API with:
            1. API Gateway for REST endpoint
            2. Lambda function for processing
            3. SageMaker endpoint for ML inference
            4. S3 bucket for storing results"""

            # 1. Test Claude processing
            self.logger.info("Testing Claude processing...")
            architecture = await self.claude.process_architecture(prompt)
            assert "components" in architecture, "Missing components in architecture"
            assert "connections" in architecture, "Missing connections in architecture"

            # 2. Test scene generation
            self.logger.info("Testing scene generation...")
            scene = self.generator.generate_scene(architecture)
            assert scene, "Failed to generate scene"

            # 3. Verify Blender objects
            self.logger.info("Verifying Blender objects...")
            for component in architecture["components"]:
                obj_name = f"{component['type']}_{component['name']}"
                obj = bpy.data.objects.get(obj_name)
                assert obj, f"Missing object: {obj_name}"

            # 4. Test connections
            self.logger.info("Verifying connections...")
            for connection in architecture["connections"]:
                from_obj = bpy.data.objects.get(f"{connection['from']}")
                to_obj = bpy.data.objects.get(f"{connection['to']}")
                assert from_obj and to_obj, "Missing connection objects"

            self.logger.info("All tests passed successfully!")
            return True

        except Exception as e:
            self.logger.error(f"Integration test failed: {str(e)}")
            return False

def run_tests():
    """Run all integration tests"""
    test = IntegrationTest()
    asyncio.run(test.test_basic_scene())

if __name__ == "__main__":
    run_tests()

==================================================

File: SceneX/tests/example_scenes/5_geometry_complex_shapes_test.py
Contents:
# tests/example_scenes/5_geometry_complex_shapes_test.py

import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Line, Circle, Rectangle, Square
from src.geometry.complex_shapes import Arc, Arrow, Star
from src.svg.svg_handler import SVGHandler
from src.camera.camera import CameraConfig, CameraSystem
from src.animation.commonly_used_animations import (
    FadeInFrom,
    GrowFromCenter,
    Write,
    Rotate,
    FlashAround
)
from src.animation.base import AnimationConfig

class GeometryComplexTestScene(Scene):
    def construct(self):
        self.logger.info("Starting geometry complex shapes test scene")

        # Setup scene
        self.setup_scene()
        self.setup_lighting()
        
        # Create and animate shapes
        shapes = self.create_shapes()
        self.position_shapes(shapes)
        self.animate_shapes(shapes)

    def setup_scene(self):
        """Setup basic scene parameters"""
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()

        # Setup camera
        camera_config = CameraConfig(
            frame_width=14.0,
            frame_height=8.0,
            position=(7, -7, 5)
        )
        self.camera = CameraSystem(camera_config)

        # Set render engine and shading
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].shading.type = 'RENDERED'

    def setup_lighting(self):
        """Setup scene lighting"""
        # Add main directional light
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        sun.rotation_euler = (math.radians(45), math.radians(45), 0)

        # Add fill light
        bpy.ops.object.light_add(type='AREA', location=(-5, -5, 5))
        fill = bpy.context.active_object
        fill.data.energy = 200.0
        fill.rotation_euler = (math.radians(-45), 0, math.radians(-135))

        # Set world background to slightly darker grey
        world = bpy.context.scene.world
        if not world:
            world = bpy.data.worlds.new("World")
            bpy.context.scene.world = world
        world.use_nodes = True
        world.node_tree.nodes["Background"].inputs[0].default_value = (0.1, 0.1, 0.1, 1)

    def create_shapes(self):
        """Create all geometric shapes"""
        line = Line((-1, 0, 0), (1, 0, 0), 
                   color=(1, 0, 0, 1),
                   stroke_width=0.05).create()
                   
        circle = Circle(radius=0.7,
                       color=(0, 1, 0, 1),
                       fill_opacity=0.5).create()
        
        arc = Arc(radius=0.7,
                 start_angle=0,
                 end_angle=math.pi/2,
                 color=(0, 0, 1, 1),
                 stroke_width=0.05).create()
        
        arrow = Arrow(start=(-0.5, -0.5, 0),
                     end=(0.5, 0.5, 0),
                     head_length=0.2,
                     head_width=0.15,
                     color=(1, 1, 0, 1)).create()
        
        star = Star(points=5,
                   outer_radius=0.7,
                   inner_radius=0.3,
                   color=(1, 0, 1, 1)).create()
                   
        return {'line': line, 'circle': circle, 'arc': arc, 
                'arrow': arrow, 'star': star}

    def position_shapes(self, shapes):
        """Position all shapes in the scene"""
        positions = {
            'line': Vector((-2, 1, 0)),
            'circle': Vector((0, 1, 0)),
            'arc': Vector((2, 1, 0)),
            'arrow': Vector((-1.5, -1, 0)),
            'star': Vector((1.5, -1, 0))
        }
        
        for name, obj in shapes.items():
            self.coordinate_system.place_object(obj, positions[name])

    def animate_shapes(self, shapes):
        """Create and apply animations to shapes"""
        # Set initial timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1

        # Create animation configs with different start times
        configs = {
            'line': AnimationConfig(duration=20),
            'circle': AnimationConfig(duration=20, delay_frames=20),
            'arc': AnimationConfig(duration=20, delay_frames=40),
            'arrow': AnimationConfig(duration=20, delay_frames=60),
            'star_rotate': AnimationConfig(duration=30, delay_frames=80),
            'star_flash': AnimationConfig(duration=10, delay_frames=110)
        }

        try:
            # Line animation
            anim = GrowFromCenter(shapes['line'], configs['line'])
            current_frame = anim.create_animation(current_frame)

            # Circle animation
            fade_direction = Vector((0, -1, 0))
            anim = FadeInFrom(shapes['circle'], fade_direction, config=configs['circle'])
            current_frame = anim.create_animation(current_frame + configs['circle'].delay_frames)

            # Arc animation
            anim = GrowFromCenter(shapes['arc'], configs['arc'])
            current_frame = anim.create_animation(current_frame + configs['arc'].delay_frames)

            # Arrow animation
            arrow_direction = Vector((-1, 0, 0))
            anim = FadeInFrom(shapes['arrow'], arrow_direction, config=configs['arrow'])
            current_frame = anim.create_animation(current_frame + configs['arrow'].delay_frames)

            # Star animations
            rotate = Rotate(shapes['star'], math.pi * 2, axis='Z', config=configs['star_rotate'])
            current_frame = rotate.create_animation(current_frame + configs['star_rotate'].delay_frames)

            flash = FlashAround(shapes['star'], 
                              color=(1, 1, 0),
                              thickness=0.1,
                              config=configs['star_flash'])
            current_frame = flash.create_animation(current_frame + configs['star_flash'].delay_frames)

            # Set timeline end
            bpy.context.scene.frame_end = current_frame + 20  # Add some padding
            bpy.context.scene.frame_current = 1  # Reset to start

            self.logger.info(f"Animation timeline set: 1 to {current_frame}")

        except Exception as e:
            self.logger.error(f"Error creating animations: {str(e)}")
            raise


if __name__ == "__main__":
    scene = GeometryComplexTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/6_materials_test.py
Contents:
# tests/example_scenes/6_materials_test.py

import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle
from src.geometry.complex_shapes import Star
from src.materials.material import Material, MaterialConfig, MaterialType
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.material_animations import MaterialAnimation, EmissionAnimation
from src.animation.base import AnimationConfig



class MaterialTestScene(Scene):
    def setup_scene(self):
        """Setup scene, camera, and lighting"""
        
        # Clear existing scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        
        # Setup render settings
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        bpy.context.scene.eevee.use_bloom = True
        bpy.context.scene.eevee.bloom_intensity = 1.0

        # Set up lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 5.0
        sun.rotation_euler = (math.radians(45), math.radians(45), 0)
        
        # Add fill light
        bpy.ops.object.light_add(type='AREA', location=(-5, -5, 5))
        fill = bpy.context.active_object
        fill.data.energy = 200.0
        fill.rotation_euler = (math.radians(-45), 0, math.radians(-135))

        # Setup camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Setup camera constraints
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Set viewport shading
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].shading.type = 'RENDERED'
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

    def setup_basic_material(self, name, color):
        """Create a basic material with Principled BSDF"""
        mat = bpy.data.materials.new(name=name)
        mat.use_nodes = True
        
        # Clear existing nodes
        nodes = mat.node_tree.nodes
        nodes.clear()
        
        # Create new nodes
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        principled.inputs['Base Color'].default_value = color
        principled.name = "Principled BSDF"  # Explicitly set name
        
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Link nodes
        mat.node_tree.links.new(principled.outputs[0], output.inputs[0])
        
        return mat

    def setup_materials(self):
        """Setup all materials with proper nodes"""
        materials = {}
        
        # Basic material
        materials['basic'] = self.setup_basic_material("basic", (1, 0, 0, 1))
        
        # Glass material
        glass_mat = bpy.data.materials.new(name="glass")
        glass_mat.use_nodes = True
        glass_mat.blend_method = 'BLEND'
        glass_mat.use_screen_refraction = True
        glass_mat.use_backface_culling = False
        
        nodes = glass_mat.node_tree.nodes
        nodes.clear()
        glass_bsdf = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        glass_mat.node_tree.links.new(glass_bsdf.outputs[0], output.inputs[0])
        glass_bsdf.inputs["Color"].default_value = (0.8, 0.9, 1, 1)
        glass_bsdf.inputs["IOR"].default_value = 1.45
        materials['glass'] = glass_mat
        
        # Emission material
        emission_mat = bpy.data.materials.new(name="emission")
        emission_mat.use_nodes = True
        nodes = emission_mat.node_tree.nodes
        nodes.clear()
        
        emission = nodes.new('ShaderNodeEmission')
        emission.name = "Emission"  # Important for animation
        output = nodes.new('ShaderNodeOutputMaterial')
        emission_mat.node_tree.links.new(emission.outputs[0], output.inputs[0])
        emission.inputs["Color"].default_value = (0, 1, 0, 1)
        emission.inputs["Strength"].default_value = 1.0
        materials['emission'] = emission_mat
        
        # Metallic material
        metallic_mat = self.setup_basic_material("metal", (0.8, 0.8, 0.8, 1))
        principled = metallic_mat.node_tree.nodes["Principled BSDF"]
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = 0.1
        materials['metallic'] = metallic_mat
        
        # Toon material
        toon_mat = self.setup_basic_material("toon", (1, 0, 1, 1))
        materials['toon'] = toon_mat
        
        return materials

    def construct(self):
        self.logger.info("Starting materials test scene")
        
        # Setup scene
        self.setup_scene()
        
        # Create materials
        materials = self.setup_materials()
        
        # Create shapes with materials
        circle1 = Circle(radius=0.7).create()
        circle1.active_material = materials['basic']
        
        circle2 = Circle(radius=0.7).create()
        circle2.active_material = materials['glass']
        
        star = Star(points=5, outer_radius=0.7).create()
        star.active_material = materials['emission']
        
        rect = Rectangle(width=1.4, height=1.4).create()
        rect.active_material = materials['metallic']
        
        circle3 = Circle(radius=0.7).create()
        circle3.active_material = materials['toon']

        # Position objects
        self.coordinate_system.place_object(circle1, Vector((-2, 1, 0)))
        self.coordinate_system.place_object(circle2, Vector((0, 1, 0)))
        self.coordinate_system.place_object(star, Vector((2, 1, 0)))
        self.coordinate_system.place_object(rect, Vector((-1, -1, 0)))
        self.coordinate_system.place_object(circle3, Vector((1, -1, 0)))

        # Setup animation timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1
        
        # Create animations with proper timing
        animations = [
            MaterialAnimation(circle1, (1,0,0,1), (0,1,0,1),
                            config=AnimationConfig(duration=30)),
            FadeInFrom(circle2, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=30)),
            EmissionAnimation(star, 1.0, 10.0,
                            config=AnimationConfig(duration=30, delay_frames=60)),
            FadeInFrom(rect, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=90)),
            Rotate(circle3, angle=math.pi*2,
                  config=AnimationConfig(duration=30, delay_frames=120))
        ]

        # Create keyframes for each animation
        for anim in animations:
            start_frame = current_frame + (anim.config.delay_frames or 0)
            end_frame = start_frame + anim.config.duration
            anim.create_animation(start_frame)
            current_frame = end_frame

        # Set scene frame range
        bpy.context.scene.frame_end = current_frame + 20
        bpy.context.scene.frame_set(1)

if __name__ == "__main__":
    scene = MaterialTestScene()
    scene.construct()

==================================================

File: SceneX/tests/example_scenes/3_animation_showcase_test_2_FlashAround_test.py.py
Contents:
# SceneX/tests/example_scenes/animation_showcase_test.py
import bpy
import mathutils
import math
from src.core.scene import Scene
from src.animation.base import AnimationConfig

from src.animation.commonly_used_animations import (
    GrowFromCenter, GrowFromPoint, Write, 
    FadeInFrom, Rotate, FlashAround
)

class AnimationShowcaseScene(Scene):
    def construct(self):
        self.logger.info("Starting animation showcase scene")
        
        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Setup timeline (30fps)
        bpy.context.scene.render.fps = 30
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 300
        current_frame = 1

        # Row 1 - Top objects
        # GrowFromCenter Demo
        self.logger.info("Testing GrowFromCenter")
        cube = self.create_cube(size=1.0, location=(-2, 2, 0))
        grow = GrowFromCenter(cube, AnimationConfig(duration=30))
        current_frame = grow.create_animation(current_frame)
        
        # GrowFromPoint Demo
        self.logger.info("Testing GrowFromPoint")
        sphere = self.create_sphere(radius=0.5, location=(0, 2, 0))
        point = mathutils.Vector((-1, 2, 0))
        grow_point = GrowFromPoint(sphere, point, AnimationConfig(duration=30))
        current_frame = grow_point.create_animation(current_frame + 10)
        
        # FadeInFrom Demo
        self.logger.info("Testing FadeInFrom")
        cube2 = self.create_cube(size=0.8, location=(2, 2, 0))
        fade_in = FadeInFrom(cube2, mathutils.Vector((-1, 1, 0)), 
                           distance=3.0, config=AnimationConfig(duration=45))
        current_frame = fade_in.create_animation(current_frame + 10)

        # Row 2 - Center row with text
        # Write Demo
        self.logger.info("Testing Write")
        text = self.create_text("Welcome to SceneX", 
                              location=(-2, 0, 0),  # Moved left
                              size=0.5)  # Reduced size
        write = Write(text, AnimationConfig(duration=60))
        current_frame = write.create_animation(current_frame + 10)

        # Row 3 - Bottom objects
        # Rotate Demo
        self.logger.info("Testing Rotate")
        cylinder = self.create_cylinder(radius=0.3, depth=1.5, location=(-2, -2, 0))
        rotate = Rotate(cylinder, math.radians(360), 'Z', 
                       config=AnimationConfig(duration=60))
        current_frame = rotate.create_animation(current_frame + 10)

        # FlashAround Demo
        self.logger.info("Testing FlashAround")
        target_sphere = self.create_sphere(radius=0.7, location=(2, -2, 0))
        flash = FlashAround(target_sphere, color=(1, 1, 0), 
                          config=AnimationConfig(duration=45))
        current_frame = flash.create_animation(current_frame + 10)

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'  # Changed from 'Y' to 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

        # Switch to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'
                area.spaces[0].show_gizmo = True

        # Return to start
        bpy.context.scene.frame_set(1)
        
        self.logger.info("Animation showcase completed")

def main():
    try:
        scene = AnimationShowcaseScene()
        scene.construct()
        print("Animation showcase completed successfully")
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error running animation showcase: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/8_latex-2-test.py
Contents:
# import bpy
# import math
# from mathutils import Vector
# from src.core.scene import Scene
# from src.text.text_support import LaTeXText
# from src.animation.commonly_used_animations import FadeInFrom
# from src.animation.base import AnimationConfig

# class LaTeXTestScene(Scene):
#     def construct(self):
#         self.logger.info("Starting LaTeX test scene")

#         # Clear the scene
#         bpy.ops.object.select_all(action='SELECT')
#         bpy.ops.object.delete()

#         # Setup the render engine
#         bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
#         if hasattr(bpy.context.scene.eevee, "use_ssr"):
#             bpy.context.scene.eevee.use_ssr = True
#             bpy.context.scene.eevee.use_ssr_refraction = True

#         # Configure viewport
#         for area in bpy.context.screen.areas:
#             if area.type == 'VIEW_3D':
#                 for space in area.spaces:
#                     if space.type == 'VIEW_3D':
#                         space.shading.type = 'RENDERED'
#                         space.shading.use_scene_lights = True
#                         space.shading.use_scene_world = True

#         # Set up camera
#         bpy.ops.object.camera_add(location=(7, -7, 5))
#         camera = bpy.context.active_object
#         camera.rotation_euler = (math.radians(45), 0, math.radians(45))

#         bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
#         target = bpy.context.active_object
#         target.name = "CameraTarget"

#         track = camera.constraints.new(type='TRACK_TO')
#         track.target = target
#         track.track_axis = 'TRACK_NEGATIVE_Z'
#         track.up_axis = 'UP_Y'

#         bpy.context.scene.camera = camera

#         # # Add lighting
#         # bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
#         # sun = bpy.context.active_object
#         # sun.data.energy = 3.0

#         # Create LaTeX objects
#         equations = [
#             ("Einstein", "E = mc^2"),
#             ("Integral", "\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}"),
#             ("Matrix", "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}"),
#         ]

#         tex_objects = []
#         for name, tex in equations:
#             obj = LaTeXText(tex, size=1.5, color=(1, 1, 1, 1)).create()
#             if obj:
#                 tex_objects.append(obj)
#             else:
#                 self.logger.error(f"Failed to create LaTeX object for {name}")

#         # Position LaTeX objects
#         spacing = 1.5
#         for i, obj in enumerate(tex_objects):
#             obj.location = Vector((0, 2 - i * spacing, 0))

#         # Animate LaTeX appearing
#         config = AnimationConfig(duration=30)
#         for obj in tex_objects:
#             self.play(FadeInFrom(obj, direction=Vector((0, -1, 0)), config=config))

#         # Render the frame to confirm visualization
#         bpy.context.scene.render.filepath = "C:/Users/ernes/Desktop/latex_render.png"
#         bpy.ops.render.render(write_still=True)

# if __name__ == "__main__":
#     scene = LaTeXTestScene()
#     scene.construct()


# SceneX/src/text/text_support.py

# import sys
# print("Python path during runtime:", sys.executable)
# print("Python path to site-packages:", sys.path)

# import sys
# import site

# # Append user site-packages to sys.path
# sys.path.append(site.getusersitepackages())

# print("Updated Python path to site-packages:", sys.path)


import bpy
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import io
import tempfile
from PIL import Image

from src.core.scene import Scene
from src.text.text_support import LaTeXText, Text
from src.animation.commonly_used_animations import Write, FadeInFrom
from src.animation.base import AnimationConfig
from src.geometry.base import Geometry

class LaTeXText(Geometry):
    def __init__(self, tex: str, size: float = 1.0, **kwargs):
        super().__init__(**kwargs)
        self.tex = tex
        self.size = size


        self.logger.info("Starting materials test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0

    def create(self) -> bpy.types.Object:
        # Create figure with transparent background
        fig = plt.figure(figsize=(5, 1), dpi=300)
        fig.patch.set_alpha(0.0)
        
        # Add text using matplotlib's LaTeX renderer
        plt.text(0.5, 0.5, f"${self.tex}$", 
                horizontalalignment='center',
                verticalalignment='center',
                transform=fig.transFigure,
                color=self.color[:3])
        
        plt.axis('off')
        
        # Save to temporary PNG with transparency
        with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
            plt.savefig(tmp.name, 
                       transparent=True,
                       bbox_inches='tight',
                       pad_inches=0.1,
                       dpi=300)
            plt.close()
            
            # Create image texture
            img = bpy.data.images.load(tmp.name)
            
            # Create plane for the texture
            bpy.ops.mesh.primitive_plane_add(size=self.size)
            self.object = bpy.context.active_object
            
            # Create material
            mat = bpy.data.materials.new(name="latex_material")
            mat.use_nodes = True
            mat.blend_method = 'BLEND'
            
            # Setup nodes for transparent texture
            nodes = mat.node_tree.nodes
            links = mat.node_tree.links
            nodes.clear()
            
            tex_image = nodes.new('ShaderNodeTexImage')
            tex_image.image = img
            
            principled = nodes.new('ShaderNodeBsdfPrincipled')
            output = nodes.new('ShaderNodeOutputMaterial')
            
            links.new(tex_image.outputs['Color'], principled.inputs['Base Color'])
            links.new(tex_image.outputs['Alpha'], principled.inputs['Alpha'])
            links.new(principled.outputs['BSDF'], output.inputs['Surface'])
            
            self.object.data.materials.append(mat)
            
            return self.object

if __name__ == "__main__":
    scene = LaTeXText(tex="E = mc^2", size=1.5)
    scene.create()  # Correct method to create the LaTeX object


==================================================

File: SceneX/tests/example_scenes/2_animation_test_scene_2_fade_standalone_test.py
Contents:
# SceneX/tests/example_scenes/fade_test_simple.py
import bpy
import math

def create_test_scene():
    # Clear existing scene
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Set up scene timing (assuming 30fps)
    bpy.context.scene.frame_start = 1
    bpy.context.scene.frame_end = 180  # 6 seconds total
    bpy.context.scene.render.fps = 30
    
    # Create a cube
    bpy.ops.mesh.primitive_cube_add(size=2.0, location=(0, 0, 0))
    cube = bpy.context.active_object
    
    # Create and setup material for transparency
    mat = bpy.data.materials.new(name="FadeMaterial")
    mat.use_nodes = True
    mat.blend_method = 'BLEND'
    
    # Get the principled BSDF node
    principled = mat.node_tree.nodes["Principled BSDF"]
    principled.inputs["Base Color"].default_value = (0.8, 0.1, 0.1, 1.0)  # Red color
    
    # Assign material to cube
    cube.data.materials.append(mat)
    
    # Set up animation keyframes for fading
    # Fade in: 0-2 seconds (frames 1-60)
    principled.inputs['Alpha'].default_value = 0
    principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=1)
    principled.inputs['Alpha'].default_value = 1
    principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=60)
    
    # Full visibility: 2-4 seconds (frames 60-120)
    principled.inputs['Alpha'].default_value = 1
    principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=120)
    
    # Fade out: 4-6 seconds (frames 120-180)
    principled.inputs['Alpha'].default_value = 0
    principled.inputs['Alpha'].keyframe_insert(data_path="default_value", frame=180)
    
    # Set up camera
    bpy.ops.object.camera_add(location=(5, -5, 5))
    camera = bpy.context.active_object
    camera.rotation_euler = (math.radians(60), 0, math.radians(45))
    bpy.context.scene.camera = camera
    
    # Add lighting
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.active_object
    sun.data.energy = 5.0
    
    # Set up viewport
    for area in bpy.context.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    # Set to rendered view
                    space.shading.type = 'RENDERED'
                    # Switch to camera view
                    space.region_3d.view_perspective = 'CAMERA'
    
    # Set up render engine
    bpy.context.scene.render.engine = 'BLENDER_EEVEE'
    bpy.context.scene.eevee.use_ssr = True
    bpy.context.scene.eevee.use_ssr_refraction = True
    
    # Return to frame 1
    bpy.context.scene.frame_set(1)

def main():
    try:
        create_test_scene()
        print("Test scene created successfully")
        # Start animation playback
        bpy.ops.screen.animation_play()
    except Exception as e:
        print(f"Error creating test scene: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/6_materials_gpt_1_test.py
Contents:
import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle
from src.geometry.complex_shapes import Star
from src.materials.material import Material, MaterialConfig, MaterialType
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.material_animations import MaterialAnimation, EmissionAnimation
from src.animation.base import AnimationConfig


class MaterialTestScene(Scene):
    def setup_scene(self):
        """Setup scene, camera, and lighting"""
        # Clear existing scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        
        # Setup render settings
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        bpy.context.scene.eevee.use_bloom = True
        bpy.context.scene.eevee.bloom_intensity = 1.0

        # Add HDRI background for realistic reflections
        world = bpy.context.scene.world
        world.use_nodes = True
        env_tex = world.node_tree.nodes.new('ShaderNodeTexEnvironment')
        env_tex.image = bpy.data.images.load(
            "C:/Users/ernes/AppData/Roaming/Blender Foundation/Blender/4.2/scripts/addons/SceneX/src/hdr/metal_hdr_photos/metal_background_197638.jpg"
        )
        env_tex.location = (-300, 0)
        background = world.node_tree.nodes['Background']
        world.node_tree.links.new(env_tex.outputs['Color'], background.inputs['Color'])
        world.node_tree.nodes["Background"].inputs["Strength"].default_value = 1.5

        # Setup lights
        bpy.ops.object.light_add(type='AREA', location=(4, 4, 8))
        key_light = bpy.context.active_object
        key_light.data.energy = 300.0
        key_light.data.size = 5

        bpy.ops.object.light_add(type='AREA', location=(-4, -4, 6))
        fill_light = bpy.context.active_object
        fill_light.data.energy = 150.0
        fill_light.data.size = 3

        bpy.ops.object.light_add(type='POINT', location=(0, 0, 10))
        point_light = bpy.context.active_object
        point_light.data.energy = 100.0

        # Setup camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        bpy.context.scene.camera = camera

        # Set viewport to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'

    def setup_basic_material(self, name, color):
        """Create a basic material with Principled BSDF"""
        mat = bpy.data.materials.new(name=name)
        mat.use_nodes = True
        
        # Clear existing nodes
        nodes = mat.node_tree.nodes
        nodes.clear()
        
        # Create new nodes
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        principled.inputs['Base Color'].default_value = color
        principled.name = "Principled BSDF"  # Explicitly set name
        
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Link nodes
        mat.node_tree.links.new(principled.outputs[0], output.inputs[0])
        
        return mat

    def setup_materials(self):
        """Setup all materials with proper nodes"""
        materials = {}
        
        # Basic material
        materials['basic'] = self.setup_basic_material("basic", (1, 0, 0, 1))
        
        # Glass material
        glass_mat = bpy.data.materials.new(name="glass")
        glass_mat.use_nodes = True
        glass_mat.blend_method = 'BLEND'
        glass_mat.use_screen_refraction = True
        glass_mat.use_backface_culling = False
        
        nodes = glass_mat.node_tree.nodes
        nodes.clear()
        glass_bsdf = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        glass_mat.node_tree.links.new(glass_bsdf.outputs[0], output.inputs[0])
        glass_bsdf.inputs["Color"].default_value = (0.8, 0.9, 1, 1)
        glass_bsdf.inputs["IOR"].default_value = 1.45
        materials['glass'] = glass_mat
        
        # Emission material
        emission_mat = bpy.data.materials.new(name="emission")
        emission_mat.use_nodes = True
        nodes = emission_mat.node_tree.nodes
        nodes.clear()
        
        emission = nodes.new('ShaderNodeEmission')
        emission.name = "Emission"  # Important for animation
        output = nodes.new('ShaderNodeOutputMaterial')
        emission_mat.node_tree.links.new(emission.outputs[0], output.inputs[0])
        emission.inputs["Color"].default_value = (0, 1, 0, 1)
        emission.inputs["Strength"].default_value = 1.0
        materials['emission'] = emission_mat
        
        # Metallic material
        metallic_mat = self.setup_basic_material("metal", (0.8, 0.8, 0.8, 1))
        principled = metallic_mat.node_tree.nodes["Principled BSDF"]
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = 0.1
        materials['metallic'] = metallic_mat
        
        # Toon material
        toon_mat = self.setup_basic_material("toon", (1, 0, 1, 1))
        materials['toon'] = toon_mat
        
        return materials

    def construct(self):
        self.logger.info("Starting materials test scene")
        
        # Setup scene
        self.setup_scene()
        
        # Create materials
        materials = self.setup_materials()
        
        # Create shapes with materials
        circle1 = Circle(radius=0.7).create()
        circle1.active_material = materials['basic']
        
        circle2 = Circle(radius=0.7).create()
        circle2.active_material = materials['glass']
        
        star = Star(points=5, outer_radius=0.7).create()
        star.active_material = materials['emission']
        
        rect = Rectangle(width=1.4, height=1.4).create()
        rect.active_material = materials['metallic']
        
        circle3 = Circle(radius=0.7).create()
        circle3.active_material = materials['toon']

        # Position objects
        self.coordinate_system.place_object(circle1, Vector((-2, 1, 0)))
        self.coordinate_system.place_object(circle2, Vector((0, 1, 0)))
        self.coordinate_system.place_object(star, Vector((2, 1, 0)))
        self.coordinate_system.place_object(rect, Vector((-1, -1, 0)))
        self.coordinate_system.place_object(circle3, Vector((1, -1, 0)))

        # Setup animation timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1
        
        # Create animations with proper timing
        animations = [
            MaterialAnimation(circle1, (1,0,0,1), (0,1,0,1),
                            config=AnimationConfig(duration=30)),
            FadeInFrom(circle2, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=30)),
            EmissionAnimation(star, 1.0, 10.0,
                            config=AnimationConfig(duration=30, delay_frames=60)),
            FadeInFrom(rect, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=90)),
            Rotate(circle3, angle=math.pi*2,
                  config=AnimationConfig(duration=30, delay_frames=120))
        ]

        # Create keyframes for each animation
        for anim in animations:
            start_frame = current_frame + (anim.config.delay_frames or 0)
            end_frame = start_frame + anim.config.duration
            anim.create_animation(start_frame)
            current_frame = end_frame

        # Set scene frame range
        bpy.context.scene.frame_end = current_frame + 20
        bpy.context.scene.frame_set(1)

if __name__ == "__main__":
    scene = MaterialTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/6_materials_gpt_2_test.py
Contents:
import bpy
import sys
import os
from pathlib import Path
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

from src.core.scene import Scene
from src.geometry.shapes import Circle, Rectangle
from src.geometry.complex_shapes import Star
from src.materials.material import Material, MaterialConfig, MaterialType
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.material_animations import MaterialAnimation, EmissionAnimation
from src.animation.base import AnimationConfig


class MaterialTestScene(Scene):
    def setup_scene(self):
        """Setup scene, camera, and lighting"""
        # Clear existing scene
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        # Set render engine
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        
        # Setup render settings
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        bpy.context.scene.eevee.use_bloom = True
        bpy.context.scene.eevee.bloom_intensity = 1.0

        # Add HDRI background
        world = bpy.context.scene.world
        world.use_nodes = True
        env_tex = world.node_tree.nodes.new('ShaderNodeTexEnvironment')
        env_tex.image = bpy.data.images.load(
            "C:/Users/ernes/AppData/Roaming/Blender Foundation/Blender/4.2/scripts/addons/SceneX/src/hdr/metal_hdr_photos/metal_background_197638.jpg"
        )
        env_tex.location = (-300, 0)
        background = world.node_tree.nodes['Background']
        world.node_tree.links.new(env_tex.outputs['Color'], background.inputs['Color'])
        world.node_tree.nodes["Background"].inputs["Strength"].default_value = 1.5

        # Setup lights
        bpy.ops.object.light_add(type='AREA', location=(4, 4, 8))
        key_light = bpy.context.active_object
        key_light.data.energy = 300.0
        key_light.data.size = 5

        bpy.ops.object.light_add(type='AREA', location=(-4, -4, 6))
        fill_light = bpy.context.active_object
        fill_light.data.energy = 150.0
        fill_light.data.size = 3

        bpy.ops.object.light_add(type='POINT', location=(0, 0, 10))
        point_light = bpy.context.active_object
        point_light.data.energy = 100.0

        # Setup camera
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        bpy.context.scene.camera = camera

        # Set viewport to camera view
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.spaces[0].region_3d.view_perspective = 'CAMERA'

    def setup_basic_material(self, name, color):
        """Create a basic material with Principled BSDF"""
        mat = bpy.data.materials.new(name=name)
        mat.use_nodes = True
        
        # Clear existing nodes
        nodes = mat.node_tree.nodes
        nodes.clear()
        
        # Create new nodes
        principled = nodes.new('ShaderNodeBsdfPrincipled')
        principled.inputs['Base Color'].default_value = color
        principled.name = "Principled BSDF"  # Explicitly set name
        
        output = nodes.new('ShaderNodeOutputMaterial')
        
        # Link nodes
        mat.node_tree.links.new(principled.outputs[0], output.inputs[0])
        
        return mat

    def setup_materials(self):
        """Setup all materials with proper nodes"""
        materials = {}
        
        # Basic material
        materials['basic'] = self.setup_basic_material("basic", (1, 0, 0, 1))
        
        # Glass material
        glass_mat = bpy.data.materials.new(name="glass")
        glass_mat.use_nodes = True
        glass_mat.blend_method = 'BLEND'
        glass_mat.use_screen_refraction = True
        glass_mat.use_backface_culling = False
        
        nodes = glass_mat.node_tree.nodes
        nodes.clear()
        glass_bsdf = nodes.new('ShaderNodeBsdfGlass')
        output = nodes.new('ShaderNodeOutputMaterial')
        glass_mat.node_tree.links.new(glass_bsdf.outputs[0], output.inputs[0])
        glass_bsdf.inputs["Color"].default_value = (0.8, 0.9, 1, 1)
        glass_bsdf.inputs["IOR"].default_value = 1.45
        materials['glass'] = glass_mat
        
        # Emission material
        emission_mat = bpy.data.materials.new(name="emission")
        emission_mat.use_nodes = True
        nodes = emission_mat.node_tree.nodes
        nodes.clear()
        
        emission = nodes.new('ShaderNodeEmission')
        emission.name = "Emission"  # Important for animation
        output = nodes.new('ShaderNodeOutputMaterial')
        emission_mat.node_tree.links.new(emission.outputs[0], output.inputs[0])
        emission.inputs["Color"].default_value = (0, 1, 0, 1)
        emission.inputs["Strength"].default_value = 1.0
        materials['emission'] = emission_mat
        
        # Metallic material
        metallic_mat = self.setup_basic_material("metal", (0.8, 0.8, 0.8, 1))
        principled = metallic_mat.node_tree.nodes["Principled BSDF"]
        principled.inputs['Metallic'].default_value = 1.0
        principled.inputs['Roughness'].default_value = 0.1
        materials['metallic'] = metallic_mat
        
        # Toon material
        toon_mat = self.setup_basic_material("toon", (1, 0, 1, 1))
        materials['toon'] = toon_mat
        
        return materials

    def construct(self):
        self.logger.info("Starting materials test scene")
        
        # Setup scene
        self.setup_scene()
        
        # Create materials
        materials = self.setup_materials()
        
        # Create shapes with materials
        circle1 = Circle(radius=0.7).create()
        circle1.active_material = materials['basic']
        
        circle2 = Circle(radius=0.7).create()
        circle2.active_material = materials['glass']
        
        star = Star(points=5, outer_radius=0.7).create()
        star.active_material = materials['emission']
        
        rect = Rectangle(width=1.4, height=1.4).create()
        rect.active_material = materials['metallic']
        
        circle3 = Circle(radius=0.7).create()
        circle3.active_material = materials['toon']

        # Position objects
        self.coordinate_system.place_object(circle1, Vector((-2, 1, 0)))
        self.coordinate_system.place_object(circle2, Vector((0, 1, 0)))
        self.coordinate_system.place_object(star, Vector((2, 1, 0)))
        self.coordinate_system.place_object(rect, Vector((-1, -1, 0)))
        self.coordinate_system.place_object(circle3, Vector((1, -1, 0)))

        # Setup animation timeline
        bpy.context.scene.frame_start = 1
        current_frame = 1
        
        # Create animations with proper timing
        animations = [
            MaterialAnimation(circle1, (1,0,0,1), (0,1,0,1),
                            config=AnimationConfig(duration=30)),
            FadeInFrom(circle2, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=30)),
            EmissionAnimation(star, 1.0, 10.0,
                            config=AnimationConfig(duration=30, delay_frames=60)),
            FadeInFrom(rect, direction=Vector((0, -1, 0)),
                      config=AnimationConfig(duration=30, delay_frames=90)),
            Rotate(circle3, angle=math.pi*2,
                  config=AnimationConfig(duration=30, delay_frames=120))
        ]

        # Ensure all materials have the "Principled BSDF" node before animating
        for anim in animations:
            start_frame = current_frame + (anim.config.delay_frames or 0)
            end_frame = start_frame + anim.config.duration
            try:
                anim.create_animation(start_frame)
            except KeyError as e:
                self.logger.error(f"Animation error: {e}")
            current_frame = end_frame

        # Set scene frame range
        bpy.context.scene.frame_end = current_frame + 20
        bpy.context.scene.frame_set(1)

if __name__ == "__main__":
    scene = MaterialTestScene()
    scene.construct()


==================================================

File: SceneX/tests/example_scenes/1_basic_scene_2_add_coordinate_system_test.py
Contents:
# SceneX/tests/example_scenes/basic_scene_2.py
import bpy
import mathutils
from src.core.scene import Scene
from src.core.mobject import Mobject
from src.core.coordinate_system import GridConfig  # Add this import

class BasicTestScene(Scene):
    def construct(self):
        self.logger.info("Starting basic test scene construction")
        
        # Setup the scene first
        self.setup()
        
        # Create coordinate system with grid
        self.coordinate_system.create_grid(GridConfig(
            x_range=(-5, 5),
            y_range=(-3, 3),
            line_thickness=0.02
        ))
        
        # Create basic shapes
        cube = self.create_cube(size=0.5, location=(-2, 0, 0))
        sphere = self.create_sphere(radius=0.25, location=(2, 0, 0))
        
        # Place objects using coordinate system
        self.coordinate_system.place_object(cube, mathutils.Vector((-2, 1, 0)))
        self.coordinate_system.place_object(sphere, mathutils.Vector((2, -1, 0)))
        
        # Frame the scene
        self.camera.frame_point(mathutils.Vector((0, 0, 0)))
        
        self.logger.info("Scene construction completed")

def main():
    try:
        # Create and run the test scene
        scene = BasicTestScene()
        scene.construct()
        print("Test scene completed successfully")
        
    except Exception as e:
        print(f"Error running test scene: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

==================================================

File: SceneX/tests/example_scenes/12_rate_functions_test.py
Contents:
# SceneX/tests/example_scenes/12_rate_functions_test.py

import bpy
import math
from mathutils import Vector

# Add parent directory to path to find SceneX package
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(script_dir))
if parent_dir not in sys.path:
    sys.path.append(parent_dir)


from src.core.scene import Scene
from src.geometry.shapes import Circle
from src.animation.commonly_used_animations import FadeInFrom, Rotate
from src.animation.base import AnimationConfig
from src.animation.rate_functions import RateFuncType

class RateFunctionsTest(Scene):
    def construct(self):
        self.logger.info("Starting rate functions test scene")

        # Setup scene and render engine
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()
        
        bpy.context.scene.render.engine = 'BLENDER_EEVEE_NEXT'
        if hasattr(bpy.context.scene.eevee, "use_ssr"):
            bpy.context.scene.eevee.use_ssr = True
            bpy.context.scene.eevee.use_ssr_refraction = True
        
        # Configure viewport for rendered preview
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                for space in area.spaces:
                    if space.type == 'VIEW_3D':
                        space.shading.type = 'RENDERED'
                        space.shading.use_scene_lights = True
                        space.shading.use_scene_world = True

        # Set up camera to target origin
        bpy.ops.object.camera_add(location=(7, -7, 5))
        camera = bpy.context.active_object
        camera.rotation_euler = (math.radians(45), 0, math.radians(45))
        
        # Add Empty at origin as camera target
        bpy.ops.object.empty_add(type='PLAIN_AXES', location=(0, 0, 0))
        target = bpy.context.active_object
        target.name = "CameraTarget"
        
        # Add Track To constraint to camera
        track = camera.constraints.new(type='TRACK_TO')
        track.target = target
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        
        bpy.context.scene.camera = camera

        # Add lighting
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 8))
        sun = bpy.context.active_object
        sun.data.energy = 3.0


        # Create test objects
        circles = []
        for i in range(6):
            circle = Circle(radius=0.3).create()
            circles.append(circle)
            self.coordinate_system.place_object(circle, Vector((-3 + i, 2, 0)))

        # Test different rate functions
        rate_functions = [
            (RateFuncType.ELASTIC, "Elastic"),
            (RateFuncType.BOUNCE, "Bounce"),
            (RateFuncType.EASE_IN_OUT, "Ease In Out"),
            (RateFuncType.EXPONENTIAL, "Exponential"),
            (RateFuncType.BACK, "Back"),
            (RateFuncType.SMOOTH, "Smooth")
        ]

        for circle, (rate_func, name) in zip(circles, rate_functions):
            config = AnimationConfig(duration=60, rate_func=rate_func)
            self.play(
                FadeInFrom(circle, Vector((0, -2, 0)), config=config),
                Rotate(circle, config=config)
            )

if __name__ == "__main__":
    scene = RateFunctionsTest()
    scene.construct()

==================================================

